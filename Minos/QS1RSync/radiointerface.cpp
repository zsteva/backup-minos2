// **********************************************************************
//
// Copyright (c) 2003-2010 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************

// Ice version 3.4.0

// <auto-generated>
//
// Generated from file `radiointerface.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>

#include <radiointerface.h>
#include <Ice/LocalException.h>
#include <Ice/ObjectFactory.h>
#include <Ice/BasicStream.h>
#include <IceUtil/Iterator.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 304
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 0
#       error Ice patch level mismatch!
#   endif
#endif

static const ::std::string __QS1R__RadioCommander__setAgcMode_name = "setAgcMode";

static const ::std::string __QS1R__RadioCommander__getAgcMode_name = "getAgcMode";

static const ::std::string __QS1R__RadioCommander__setAgcMaxGain_name = "setAgcMaxGain";

static const ::std::string __QS1R__RadioCommander__getAgcMaxGain_name = "getAgcMaxGain";

static const ::std::string __QS1R__RadioCommander__setAgcFixedGain_name = "setAgcFixedGain";

static const ::std::string __QS1R__RadioCommander__getAgcFixedGain_name = "getAgcFixedGain";

static const ::std::string __QS1R__RadioCommander__setAgcAttack_name = "setAgcAttack";

static const ::std::string __QS1R__RadioCommander__getAgcAttack_name = "getAgcAttack";

static const ::std::string __QS1R__RadioCommander__setAgcDecay_name = "setAgcDecay";

static const ::std::string __QS1R__RadioCommander__getAgcDecay_name = "getAgcDecay";

static const ::std::string __QS1R__RadioCommander__setAgcHangTime_name = "setAgcHangTime";

static const ::std::string __QS1R__RadioCommander__getAgcHangTime_name = "getAgcHangTime";

static const ::std::string __QS1R__RadioCommander__setAgcHangThresh_name = "setAgcHangThresh";

static const ::std::string __QS1R__RadioCommander__getAgcHangThresh_name = "getAgcHangThresh";

static const ::std::string __QS1R__RadioCommander__setAgcSlope_name = "setAgcSlope";

static const ::std::string __QS1R__RadioCommander__getAgcSlope_name = "getAgcSlope";

static const ::std::string __QS1R__RadioCommander__getAgcFastGain_name = "getAgcFastGain";

static const ::std::string __QS1R__RadioCommander__getAgcCurrentGain_name = "getAgcCurrentGain";

static const ::std::string __QS1R__RadioCommander__setAnfSwitch_name = "setAnfSwitch";

static const ::std::string __QS1R__RadioCommander__getAnfSwitch_name = "getAnfSwitch";

static const ::std::string __QS1R__RadioCommander__setAnfDelay_name = "setAnfDelay";

static const ::std::string __QS1R__RadioCommander__getAnfDelay_name = "getAnfDelay";

static const ::std::string __QS1R__RadioCommander__setAnfTaps_name = "setAnfTaps";

static const ::std::string __QS1R__RadioCommander__getAnfTaps_name = "getAnfTaps";

static const ::std::string __QS1R__RadioCommander__setAnfGain_name = "setAnfGain";

static const ::std::string __QS1R__RadioCommander__getAnfGain_name = "getAnfGain";

static const ::std::string __QS1R__RadioCommander__setAnfLeak_name = "setAnfLeak";

static const ::std::string __QS1R__RadioCommander__getAnfLeak_name = "getAnfLeak";

static const ::std::string __QS1R__RadioCommander__setBinaural_name = "setBinaural";

static const ::std::string __QS1R__RadioCommander__getBinaural_name = "getBinaural";

static const ::std::string __QS1R__RadioCommander__setBlockSize_name = "setBlockSize";

static const ::std::string __QS1R__RadioCommander__getBlockSize_name = "getBlockSize";

static const ::std::string __QS1R__RadioCommander__setDemodMode_name = "setDemodMode";

static const ::std::string __QS1R__RadioCommander__getDemodMode_name = "getDemodMode";

static const ::std::string __QS1R__RadioCommander__setControlRegister_name = "setControlRegister";

static const ::std::string __QS1R__RadioCommander__getControlRegister_name = "getControlRegister";

static const ::std::string __QS1R__RadioCommander__setDecimationRegister_name = "setDecimationRegister";

static const ::std::string __QS1R__RadioCommander__getDecimationRegister_name = "getDecimationRegister";

static const ::std::string __QS1R__RadioCommander__setScalingRegister_name = "setScalingRegister";

static const ::std::string __QS1R__RadioCommander__getScalingRegister_name = "getScalingRegister";

static const ::std::string __QS1R__RadioCommander__getEepromEncFreqRegister_name = "getEepromEncFreqRegister";

static const ::std::string __QS1R__RadioCommander__setDither_name = "setDither";

static const ::std::string __QS1R__RadioCommander__getDither_name = "getDither";

static const ::std::string __QS1R__RadioCommander__setEncodeFreq_name = "setEncodeFreq";

static const ::std::string __QS1R__RadioCommander__getEncodeFreq_name = "getEncodeFreq";

static const ::std::string __QS1R__RadioCommander__setMeterCalibrationOffset_name = "setMeterCalibrationOffset";

static const ::std::string __QS1R__RadioCommander__getMeterCalibrationOffset_name = "getMeterCalibrationOffset";

static const ::std::string __QS1R__RadioCommander__setSpectrumCalibrationOffset_name = "setSpectrumCalibrationOffset";

static const ::std::string __QS1R__RadioCommander__getSpectrumCalibrationOffset_name = "getSpectrumCalibrationOffset";

static const ::std::string __QS1R__RadioCommander__setNrSwitch_name = "setNrSwitch";

static const ::std::string __QS1R__RadioCommander__getNrSwitch_name = "getNrSwitch";

static const ::std::string __QS1R__RadioCommander__setNrTaps_name = "setNrTaps";

static const ::std::string __QS1R__RadioCommander__getNrTaps_name = "getNrTaps";

static const ::std::string __QS1R__RadioCommander__setNrDelay_name = "setNrDelay";

static const ::std::string __QS1R__RadioCommander__getNrDelay_name = "getNrDelay";

static const ::std::string __QS1R__RadioCommander__setNrGain_name = "setNrGain";

static const ::std::string __QS1R__RadioCommander__getNrGain_name = "getNrGain";

static const ::std::string __QS1R__RadioCommander__setNrLeak_name = "setNrLeak";

static const ::std::string __QS1R__RadioCommander__getNrLeak_name = "getNrLeak";

static const ::std::string __QS1R__RadioCommander__setExit_name = "setExit";

static const ::std::string __QS1R__RadioCommander__setFrequency_name = "setFrequency";

static const ::std::string __QS1R__RadioCommander__getFrequency_name = "getFrequency";

static const ::std::string __QS1R__RadioCommander__setFilterLo_name = "setFilterLo";

static const ::std::string __QS1R__RadioCommander__getFilterLo_name = "getFilterLo";

static const ::std::string __QS1R__RadioCommander__setFilterHi_name = "setFilterHi";

static const ::std::string __QS1R__RadioCommander__getFilterHi_name = "getFilterHi";

static const ::std::string __QS1R__RadioCommander__setFilter_name = "setFilter";

static const ::std::string __QS1R__RadioCommander__setMute_name = "setMute";

static const ::std::string __QS1R__RadioCommander__getMute_name = "getMute";

static const ::std::string __QS1R__RadioCommander__setNb1Switch_name = "setNb1Switch";

static const ::std::string __QS1R__RadioCommander__setNb1Thresh_name = "setNb1Thresh";

static const ::std::string __QS1R__RadioCommander__getNb1Switch_name = "getNb1Switch";

static const ::std::string __QS1R__RadioCommander__getNb1Thresh_name = "getNb1Thresh";

static const ::std::string __QS1R__RadioCommander__setNb2Switch_name = "setNb2Switch";

static const ::std::string __QS1R__RadioCommander__setNb2Thresh_name = "setNb2Thresh";

static const ::std::string __QS1R__RadioCommander__getNb2Switch_name = "getNb2Switch";

static const ::std::string __QS1R__RadioCommander__getNb2Thresh_name = "getNb2Thresh";

static const ::std::string __QS1R__RadioCommander__setPga_name = "setPga";

static const ::std::string __QS1R__RadioCommander__getPga_name = "getPga";

static const ::std::string __QS1R__RadioCommander__setInbandPsSwitch_name = "setInbandPsSwitch";

static const ::std::string __QS1R__RadioCommander__getInbandPsSwitch_name = "getInbandPsSwitch";

static const ::std::string __QS1R__RadioCommander__getInbandPsSize_name = "getInbandPsSize";

static const ::std::string __QS1R__RadioCommander__setOutbandPsSwitch_name = "setOutbandPsSwitch";

static const ::std::string __QS1R__RadioCommander__getOutbandPsSwitch_name = "getOutbandPsSwitch";

static const ::std::string __QS1R__RadioCommander__getOutbandPsSize_name = "getOutbandPsSize";

static const ::std::string __QS1R__RadioCommander__getSpectrumBandwidth_name = "getSpectrumBandwidth";

static const ::std::string __QS1R__RadioCommander__setSpectrumBandwidth_name = "setSpectrumBandwidth";

static const ::std::string __QS1R__RadioCommander__getSpectrumBandwidths_name = "getSpectrumBandwidths";

static const ::std::string __QS1R__RadioCommander__setRand_name = "setRand";

static const ::std::string __QS1R__RadioCommander__getRand_name = "getRand";

static const ::std::string __QS1R__RadioCommander__getVersion_name = "getVersion";

static const ::std::string __QS1R__RadioCommander__setSamplerate_name = "setSamplerate";

static const ::std::string __QS1R__RadioCommander__getSamplerate_name = "getSamplerate";

static const ::std::string __QS1R__RadioCommander__setSMeterCorrection_name = "setSMeterCorrection";

static const ::std::string __QS1R__RadioCommander__getSMeterCorrection_name = "getSMeterCorrection";

static const ::std::string __QS1R__RadioCommander__getSMeterInstantaneous_name = "getSMeterInstantaneous";

static const ::std::string __QS1R__RadioCommander__getSMeterAverage_name = "getSMeterAverage";

static const ::std::string __QS1R__RadioCommander__setSquelchSwitch_name = "setSquelchSwitch";

static const ::std::string __QS1R__RadioCommander__getSquelchSwitch_name = "getSquelchSwitch";

static const ::std::string __QS1R__RadioCommander__setSquelchThresh_name = "setSquelchThresh";

static const ::std::string __QS1R__RadioCommander__getSquelchThresh_name = "getSquelchThresh";

static const ::std::string __QS1R__RadioCommander__setStart_name = "setStart";

static const ::std::string __QS1R__RadioCommander__getStart_name = "getStart";

static const ::std::string __QS1R__RadioCommander__setStop_name = "setStop";

static const ::std::string __QS1R__RadioCommander__getStop_name = "getStop";

static const ::std::string __QS1R__RadioCommander__setVolume_name = "setVolume";

static const ::std::string __QS1R__RadioCommander__setVolumeLeft_name = "setVolumeLeft";

static const ::std::string __QS1R__RadioCommander__getVolumeLeft_name = "getVolumeLeft";

static const ::std::string __QS1R__RadioCommander__setVolumeRight_name = "setVolumeRight";

static const ::std::string __QS1R__RadioCommander__getVolumeRight_name = "getVolumeRight";

static const ::std::string __QS1R__RadioCommander__setLoadFirmware_name = "setLoadFirmware";

static const ::std::string __QS1R__RadioCommander__setLoadFpga_name = "setLoadFpga";

static const ::std::string __QS1R__RadioCommander__getFpgaFileId_name = "getFpgaFileId";

static const ::std::string __QS1R__RadioCommander__getFirmwareFileName_name = "getFirmwareFileName";

static const ::std::string __QS1R__RadioCommander__getFpgaRbfName_name = "getFpgaRbfName";

static const ::std::string __QS1R__RadioCommander__getDateTime_name = "getDateTime";

static const ::std::string __QS1R__PowerSpectrumData__getSpecData_name = "getSpecData";

static const ::std::string __QS1R__PowerSpectrumData__getSpecDataSize_name = "getSpecDataSize";

static const ::std::string __QS1R__MeterData__getMeterData_name = "getMeterData";

::Ice::Object* IceInternal::upCast(::QS1R::RadioCommander* p) { return p; }
::IceProxy::Ice::Object* IceInternal::upCast(::IceProxy::QS1R::RadioCommander* p) { return p; }

::Ice::Object* IceInternal::upCast(::QS1R::PowerSpectrumData* p) { return p; }
::IceProxy::Ice::Object* IceInternal::upCast(::IceProxy::QS1R::PowerSpectrumData* p) { return p; }

::Ice::Object* IceInternal::upCast(::QS1R::MeterData* p) { return p; }
::IceProxy::Ice::Object* IceInternal::upCast(::IceProxy::QS1R::MeterData* p) { return p; }

void
QS1R::__read(::IceInternal::BasicStream* __is, ::QS1R::RadioCommanderPrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::QS1R::RadioCommander;
        v->__copyFrom(proxy);
    }
}

void
QS1R::__read(::IceInternal::BasicStream* __is, ::QS1R::PowerSpectrumDataPrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::QS1R::PowerSpectrumData;
        v->__copyFrom(proxy);
    }
}

void
QS1R::__read(::IceInternal::BasicStream* __is, ::QS1R::MeterDataPrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::QS1R::MeterData;
        v->__copyFrom(proxy);
    }
}

void
QS1R::MeterDataStruct::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(Instantaneous);
    __os->write(Average);
}

void
QS1R::MeterDataStruct::__read(::IceInternal::BasicStream* __is)
{
    __is->read(Instantaneous);
    __is->read(Average);
}

void
QS1R::__write(::IceInternal::BasicStream* __os, ::QS1R::AGCMODE v)
{
    __os->write(static_cast< ::Ice::Byte>(v), 5);
}

void
QS1R::__read(::IceInternal::BasicStream* __is, ::QS1R::AGCMODE& v)
{
    ::Ice::Byte val;
    __is->read(val, 5);
    v = static_cast< ::QS1R::AGCMODE>(val);
}

void
QS1R::__write(::IceInternal::BasicStream* __os, ::QS1R::DEMODMODE v)
{
    __os->write(static_cast< ::Ice::Byte>(v), 11);
}

void
QS1R::__read(::IceInternal::BasicStream* __is, ::QS1R::DEMODMODE& v)
{
    ::Ice::Byte val;
    __is->read(val, 11);
    v = static_cast< ::QS1R::DEMODMODE>(val);
}

void
IceProxy::QS1R::RadioCommander::setAgcMode(::Ice::Int channel, ::QS1R::AGCMODE value, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setAgcMode(channel, value, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setAgcMode(::Ice::Int channel, ::QS1R::AGCMODE value, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setAgcMode_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setAgcMode_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        ::QS1R::__write(__os, value);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setAgcMode(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setAgcMode_name);
}

::QS1R::AGCMODE
IceProxy::QS1R::RadioCommander::getAgcMode(::Ice::Int channel, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getAgcMode_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getAgcMode(channel, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getAgcMode(::Ice::Int channel, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getAgcMode_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getAgcMode_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getAgcMode_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::QS1R::AGCMODE
IceProxy::QS1R::RadioCommander::end_getAgcMode(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getAgcMode_name);
    ::QS1R::AGCMODE __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    ::QS1R::__read(__is, __ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::QS1R::RadioCommander::setAgcMaxGain(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setAgcMaxGain(channel, value, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setAgcMaxGain(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setAgcMaxGain_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setAgcMaxGain_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->write(value);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setAgcMaxGain(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setAgcMaxGain_name);
}

::Ice::Float
IceProxy::QS1R::RadioCommander::getAgcMaxGain(::Ice::Int channel, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getAgcMaxGain_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getAgcMaxGain(channel, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getAgcMaxGain(::Ice::Int channel, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getAgcMaxGain_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getAgcMaxGain_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getAgcMaxGain_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Float
IceProxy::QS1R::RadioCommander::end_getAgcMaxGain(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getAgcMaxGain_name);
    ::Ice::Float __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::QS1R::RadioCommander::setAgcFixedGain(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setAgcFixedGain(channel, value, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setAgcFixedGain(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setAgcFixedGain_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setAgcFixedGain_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->write(value);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setAgcFixedGain(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setAgcFixedGain_name);
}

::Ice::Float
IceProxy::QS1R::RadioCommander::getAgcFixedGain(::Ice::Int channel, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getAgcFixedGain_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getAgcFixedGain(channel, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getAgcFixedGain(::Ice::Int channel, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getAgcFixedGain_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getAgcFixedGain_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getAgcFixedGain_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Float
IceProxy::QS1R::RadioCommander::end_getAgcFixedGain(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getAgcFixedGain_name);
    ::Ice::Float __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::QS1R::RadioCommander::setAgcAttack(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setAgcAttack(channel, value, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setAgcAttack(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setAgcAttack_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setAgcAttack_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->write(value);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setAgcAttack(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setAgcAttack_name);
}

::Ice::Float
IceProxy::QS1R::RadioCommander::getAgcAttack(::Ice::Int channel, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getAgcAttack_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getAgcAttack(channel, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getAgcAttack(::Ice::Int channel, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getAgcAttack_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getAgcAttack_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getAgcAttack_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Float
IceProxy::QS1R::RadioCommander::end_getAgcAttack(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getAgcAttack_name);
    ::Ice::Float __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::QS1R::RadioCommander::setAgcDecay(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setAgcDecay(channel, value, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setAgcDecay(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setAgcDecay_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setAgcDecay_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->write(value);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setAgcDecay(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setAgcDecay_name);
}

::Ice::Float
IceProxy::QS1R::RadioCommander::getAgcDecay(::Ice::Int channel, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getAgcDecay_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getAgcDecay(channel, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getAgcDecay(::Ice::Int channel, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getAgcDecay_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getAgcDecay_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getAgcDecay_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Float
IceProxy::QS1R::RadioCommander::end_getAgcDecay(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getAgcDecay_name);
    ::Ice::Float __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::QS1R::RadioCommander::setAgcHangTime(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setAgcHangTime(channel, value, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setAgcHangTime(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setAgcHangTime_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setAgcHangTime_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->write(value);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setAgcHangTime(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setAgcHangTime_name);
}

::Ice::Float
IceProxy::QS1R::RadioCommander::getAgcHangTime(::Ice::Int channel, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getAgcHangTime_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getAgcHangTime(channel, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getAgcHangTime(::Ice::Int channel, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getAgcHangTime_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getAgcHangTime_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getAgcHangTime_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Float
IceProxy::QS1R::RadioCommander::end_getAgcHangTime(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getAgcHangTime_name);
    ::Ice::Float __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::QS1R::RadioCommander::setAgcHangThresh(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setAgcHangThresh(channel, value, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setAgcHangThresh(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setAgcHangThresh_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setAgcHangThresh_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->write(value);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setAgcHangThresh(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setAgcHangThresh_name);
}

::Ice::Float
IceProxy::QS1R::RadioCommander::getAgcHangThresh(::Ice::Int channel, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getAgcHangThresh_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getAgcHangThresh(channel, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getAgcHangThresh(::Ice::Int channel, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getAgcHangThresh_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getAgcHangThresh_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getAgcHangThresh_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Float
IceProxy::QS1R::RadioCommander::end_getAgcHangThresh(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getAgcHangThresh_name);
    ::Ice::Float __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::QS1R::RadioCommander::setAgcSlope(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setAgcSlope(channel, value, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setAgcSlope(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setAgcSlope_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setAgcSlope_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->write(value);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setAgcSlope(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setAgcSlope_name);
}

::Ice::Float
IceProxy::QS1R::RadioCommander::getAgcSlope(::Ice::Int channel, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getAgcSlope_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getAgcSlope(channel, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getAgcSlope(::Ice::Int channel, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getAgcSlope_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getAgcSlope_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getAgcSlope_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Float
IceProxy::QS1R::RadioCommander::end_getAgcSlope(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getAgcSlope_name);
    ::Ice::Float __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

::Ice::Float
IceProxy::QS1R::RadioCommander::getAgcFastGain(::Ice::Int channel, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getAgcFastGain_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getAgcFastGain(channel, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getAgcFastGain(::Ice::Int channel, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getAgcFastGain_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getAgcFastGain_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getAgcFastGain_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Float
IceProxy::QS1R::RadioCommander::end_getAgcFastGain(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getAgcFastGain_name);
    ::Ice::Float __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

::Ice::Float
IceProxy::QS1R::RadioCommander::getAgcCurrentGain(::Ice::Int channel, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getAgcCurrentGain_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getAgcCurrentGain(channel, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getAgcCurrentGain(::Ice::Int channel, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getAgcCurrentGain_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getAgcCurrentGain_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getAgcCurrentGain_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Float
IceProxy::QS1R::RadioCommander::end_getAgcCurrentGain(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getAgcCurrentGain_name);
    ::Ice::Float __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::QS1R::RadioCommander::setAnfSwitch(::Ice::Int channel, bool on, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setAnfSwitch(channel, on, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setAnfSwitch(::Ice::Int channel, bool on, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setAnfSwitch_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setAnfSwitch_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->write(on);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setAnfSwitch(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setAnfSwitch_name);
}

bool
IceProxy::QS1R::RadioCommander::getAnfSwitch(::Ice::Int channel, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getAnfSwitch_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getAnfSwitch(channel, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getAnfSwitch(::Ice::Int channel, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getAnfSwitch_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getAnfSwitch_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getAnfSwitch_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

bool
IceProxy::QS1R::RadioCommander::end_getAnfSwitch(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getAnfSwitch_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::QS1R::RadioCommander::setAnfDelay(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setAnfDelay(channel, value, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setAnfDelay(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setAnfDelay_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setAnfDelay_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->write(value);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setAnfDelay(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setAnfDelay_name);
}

::Ice::Int
IceProxy::QS1R::RadioCommander::getAnfDelay(::Ice::Int channel, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getAnfDelay_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getAnfDelay(channel, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getAnfDelay(::Ice::Int channel, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getAnfDelay_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getAnfDelay_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getAnfDelay_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::QS1R::RadioCommander::end_getAnfDelay(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getAnfDelay_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::QS1R::RadioCommander::setAnfTaps(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setAnfTaps(channel, value, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setAnfTaps(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setAnfTaps_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setAnfTaps_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->write(value);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setAnfTaps(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setAnfTaps_name);
}

::Ice::Int
IceProxy::QS1R::RadioCommander::getAnfTaps(::Ice::Int channel, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getAnfTaps_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getAnfTaps(channel, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getAnfTaps(::Ice::Int channel, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getAnfTaps_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getAnfTaps_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getAnfTaps_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::QS1R::RadioCommander::end_getAnfTaps(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getAnfTaps_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::QS1R::RadioCommander::setAnfGain(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setAnfGain(channel, value, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setAnfGain(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setAnfGain_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setAnfGain_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->write(value);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setAnfGain(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setAnfGain_name);
}

::Ice::Float
IceProxy::QS1R::RadioCommander::getAnfGain(::Ice::Int channel, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getAnfGain_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getAnfGain(channel, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getAnfGain(::Ice::Int channel, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getAnfGain_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getAnfGain_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getAnfGain_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Float
IceProxy::QS1R::RadioCommander::end_getAnfGain(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getAnfGain_name);
    ::Ice::Float __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::QS1R::RadioCommander::setAnfLeak(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setAnfLeak(channel, value, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setAnfLeak(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setAnfLeak_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setAnfLeak_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->write(value);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setAnfLeak(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setAnfLeak_name);
}

::Ice::Float
IceProxy::QS1R::RadioCommander::getAnfLeak(::Ice::Int channel, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getAnfLeak_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getAnfLeak(channel, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getAnfLeak(::Ice::Int channel, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getAnfLeak_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getAnfLeak_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getAnfLeak_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Float
IceProxy::QS1R::RadioCommander::end_getAnfLeak(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getAnfLeak_name);
    ::Ice::Float __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::QS1R::RadioCommander::setBinaural(bool on, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setBinaural(on, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setBinaural(bool on, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setBinaural_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setBinaural_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(on);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setBinaural(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setBinaural_name);
}

bool
IceProxy::QS1R::RadioCommander::getBinaural(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getBinaural_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getBinaural(__ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getBinaural(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getBinaural_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getBinaural_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getBinaural_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

bool
IceProxy::QS1R::RadioCommander::end_getBinaural(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getBinaural_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::QS1R::RadioCommander::setBlockSize(::Ice::Int value, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setBlockSize(value, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setBlockSize(::Ice::Int value, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setBlockSize_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setBlockSize_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(value);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setBlockSize(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setBlockSize_name);
}

::Ice::Int
IceProxy::QS1R::RadioCommander::getBlockSize(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getBlockSize_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getBlockSize(__ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getBlockSize(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getBlockSize_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getBlockSize_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getBlockSize_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::QS1R::RadioCommander::end_getBlockSize(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getBlockSize_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::QS1R::RadioCommander::setDemodMode(::Ice::Int channel, ::QS1R::DEMODMODE mode, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setDemodMode(channel, mode, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setDemodMode(::Ice::Int channel, ::QS1R::DEMODMODE mode, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setDemodMode_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setDemodMode_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        ::QS1R::__write(__os, mode);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setDemodMode(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setDemodMode_name);
}

::QS1R::DEMODMODE
IceProxy::QS1R::RadioCommander::getDemodMode(::Ice::Int channel, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getDemodMode_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getDemodMode(channel, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getDemodMode(::Ice::Int channel, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getDemodMode_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getDemodMode_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getDemodMode_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::QS1R::DEMODMODE
IceProxy::QS1R::RadioCommander::end_getDemodMode(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getDemodMode_name);
    ::QS1R::DEMODMODE __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    ::QS1R::__read(__is, __ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::QS1R::RadioCommander::setControlRegister(::Ice::Int value, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setControlRegister(value, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setControlRegister(::Ice::Int value, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setControlRegister_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setControlRegister_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(value);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setControlRegister(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setControlRegister_name);
}

::Ice::Int
IceProxy::QS1R::RadioCommander::getControlRegister(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getControlRegister_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getControlRegister(__ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getControlRegister(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getControlRegister_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getControlRegister_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getControlRegister_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::QS1R::RadioCommander::end_getControlRegister(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getControlRegister_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::QS1R::RadioCommander::setDecimationRegister(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setDecimationRegister(channel, value, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setDecimationRegister(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setDecimationRegister_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setDecimationRegister_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->write(value);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setDecimationRegister(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setDecimationRegister_name);
}

::Ice::Int
IceProxy::QS1R::RadioCommander::getDecimationRegister(::Ice::Int channel, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getDecimationRegister_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getDecimationRegister(channel, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getDecimationRegister(::Ice::Int channel, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getDecimationRegister_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getDecimationRegister_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getDecimationRegister_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::QS1R::RadioCommander::end_getDecimationRegister(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getDecimationRegister_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::QS1R::RadioCommander::setScalingRegister(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setScalingRegister(channel, value, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setScalingRegister(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setScalingRegister_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setScalingRegister_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->write(value);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setScalingRegister(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setScalingRegister_name);
}

::Ice::Int
IceProxy::QS1R::RadioCommander::getScalingRegister(::Ice::Int channel, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getScalingRegister_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getScalingRegister(channel, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getScalingRegister(::Ice::Int channel, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getScalingRegister_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getScalingRegister_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getScalingRegister_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::QS1R::RadioCommander::end_getScalingRegister(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getScalingRegister_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

::std::string
IceProxy::QS1R::RadioCommander::getEepromEncFreqRegister(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getEepromEncFreqRegister_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getEepromEncFreqRegister(__ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getEepromEncFreqRegister(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getEepromEncFreqRegister_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getEepromEncFreqRegister_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getEepromEncFreqRegister_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::std::string
IceProxy::QS1R::RadioCommander::end_getEepromEncFreqRegister(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getEepromEncFreqRegister_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::QS1R::RadioCommander::setDither(bool on, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setDither(on, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setDither(bool on, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setDither_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setDither_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(on);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setDither(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setDither_name);
}

bool
IceProxy::QS1R::RadioCommander::getDither(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getDither_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getDither(__ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getDither(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getDither_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getDither_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getDither_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

bool
IceProxy::QS1R::RadioCommander::end_getDither(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getDither_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::QS1R::RadioCommander::setEncodeFreq(::Ice::Float value, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setEncodeFreq(value, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setEncodeFreq(::Ice::Float value, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setEncodeFreq_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setEncodeFreq_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(value);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setEncodeFreq(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setEncodeFreq_name);
}

::Ice::Float
IceProxy::QS1R::RadioCommander::getEncodeFreq(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getEncodeFreq_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getEncodeFreq(__ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getEncodeFreq(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getEncodeFreq_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getEncodeFreq_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getEncodeFreq_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Float
IceProxy::QS1R::RadioCommander::end_getEncodeFreq(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getEncodeFreq_name);
    ::Ice::Float __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::QS1R::RadioCommander::setMeterCalibrationOffset(::Ice::Float value, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setMeterCalibrationOffset(value, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setMeterCalibrationOffset(::Ice::Float value, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setMeterCalibrationOffset_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setMeterCalibrationOffset_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(value);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setMeterCalibrationOffset(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setMeterCalibrationOffset_name);
}

::Ice::Float
IceProxy::QS1R::RadioCommander::getMeterCalibrationOffset(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getMeterCalibrationOffset_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getMeterCalibrationOffset(__ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getMeterCalibrationOffset(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getMeterCalibrationOffset_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getMeterCalibrationOffset_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getMeterCalibrationOffset_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Float
IceProxy::QS1R::RadioCommander::end_getMeterCalibrationOffset(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getMeterCalibrationOffset_name);
    ::Ice::Float __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::QS1R::RadioCommander::setSpectrumCalibrationOffset(::Ice::Float value, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setSpectrumCalibrationOffset(value, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setSpectrumCalibrationOffset(::Ice::Float value, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setSpectrumCalibrationOffset_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setSpectrumCalibrationOffset_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(value);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setSpectrumCalibrationOffset(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setSpectrumCalibrationOffset_name);
}

::Ice::Float
IceProxy::QS1R::RadioCommander::getSpectrumCalibrationOffset(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getSpectrumCalibrationOffset_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getSpectrumCalibrationOffset(__ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getSpectrumCalibrationOffset(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getSpectrumCalibrationOffset_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getSpectrumCalibrationOffset_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getSpectrumCalibrationOffset_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Float
IceProxy::QS1R::RadioCommander::end_getSpectrumCalibrationOffset(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getSpectrumCalibrationOffset_name);
    ::Ice::Float __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::QS1R::RadioCommander::setNrSwitch(::Ice::Int channel, bool on, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setNrSwitch(channel, on, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setNrSwitch(::Ice::Int channel, bool on, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setNrSwitch_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setNrSwitch_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->write(on);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setNrSwitch(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setNrSwitch_name);
}

bool
IceProxy::QS1R::RadioCommander::getNrSwitch(::Ice::Int channel, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getNrSwitch_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getNrSwitch(channel, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getNrSwitch(::Ice::Int channel, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getNrSwitch_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getNrSwitch_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getNrSwitch_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

bool
IceProxy::QS1R::RadioCommander::end_getNrSwitch(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getNrSwitch_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::QS1R::RadioCommander::setNrTaps(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setNrTaps(channel, value, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setNrTaps(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setNrTaps_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setNrTaps_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->write(value);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setNrTaps(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setNrTaps_name);
}

::Ice::Int
IceProxy::QS1R::RadioCommander::getNrTaps(::Ice::Int channel, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getNrTaps_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getNrTaps(channel, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getNrTaps(::Ice::Int channel, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getNrTaps_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getNrTaps_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getNrTaps_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::QS1R::RadioCommander::end_getNrTaps(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getNrTaps_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::QS1R::RadioCommander::setNrDelay(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setNrDelay(channel, value, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setNrDelay(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setNrDelay_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setNrDelay_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->write(value);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setNrDelay(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setNrDelay_name);
}

::Ice::Int
IceProxy::QS1R::RadioCommander::getNrDelay(::Ice::Int channel, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getNrDelay_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getNrDelay(channel, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getNrDelay(::Ice::Int channel, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getNrDelay_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getNrDelay_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getNrDelay_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::QS1R::RadioCommander::end_getNrDelay(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getNrDelay_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::QS1R::RadioCommander::setNrGain(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setNrGain(channel, value, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setNrGain(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setNrGain_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setNrGain_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->write(value);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setNrGain(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setNrGain_name);
}

::Ice::Float
IceProxy::QS1R::RadioCommander::getNrGain(::Ice::Int channel, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getNrGain_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getNrGain(channel, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getNrGain(::Ice::Int channel, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getNrGain_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getNrGain_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getNrGain_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Float
IceProxy::QS1R::RadioCommander::end_getNrGain(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getNrGain_name);
    ::Ice::Float __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::QS1R::RadioCommander::setNrLeak(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setNrLeak(channel, value, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setNrLeak(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setNrLeak_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setNrLeak_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->write(value);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setNrLeak(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setNrLeak_name);
}

::Ice::Float
IceProxy::QS1R::RadioCommander::getNrLeak(::Ice::Int channel, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getNrLeak_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getNrLeak(channel, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getNrLeak(::Ice::Int channel, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getNrLeak_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getNrLeak_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getNrLeak_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Float
IceProxy::QS1R::RadioCommander::end_getNrLeak(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getNrLeak_name);
    ::Ice::Float __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::QS1R::RadioCommander::setExit(bool on, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setExit(on, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setExit(bool on, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setExit_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setExit_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(on);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setExit(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setExit_name);
}

void
IceProxy::QS1R::RadioCommander::setFrequency(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setFrequency(channel, value, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setFrequency(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setFrequency_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setFrequency_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->write(value);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setFrequency(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setFrequency_name);
}

::Ice::Float
IceProxy::QS1R::RadioCommander::getFrequency(::Ice::Int channel, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getFrequency_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getFrequency(channel, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getFrequency(::Ice::Int channel, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getFrequency_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getFrequency_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getFrequency_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Float
IceProxy::QS1R::RadioCommander::end_getFrequency(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getFrequency_name);
    ::Ice::Float __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::QS1R::RadioCommander::setFilterLo(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setFilterLo(channel, value, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setFilterLo(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setFilterLo_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setFilterLo_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->write(value);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setFilterLo(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setFilterLo_name);
}

::Ice::Float
IceProxy::QS1R::RadioCommander::getFilterLo(::Ice::Int channel, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getFilterLo_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getFilterLo(channel, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getFilterLo(::Ice::Int channel, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getFilterLo_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getFilterLo_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getFilterLo_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Float
IceProxy::QS1R::RadioCommander::end_getFilterLo(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getFilterLo_name);
    ::Ice::Float __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::QS1R::RadioCommander::setFilterHi(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setFilterHi(channel, value, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setFilterHi(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setFilterHi_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setFilterHi_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->write(value);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setFilterHi(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setFilterHi_name);
}

::Ice::Float
IceProxy::QS1R::RadioCommander::getFilterHi(::Ice::Int channel, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getFilterHi_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getFilterHi(channel, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getFilterHi(::Ice::Int channel, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getFilterHi_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getFilterHi_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getFilterHi_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Float
IceProxy::QS1R::RadioCommander::end_getFilterHi(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getFilterHi_name);
    ::Ice::Float __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::QS1R::RadioCommander::setFilter(::Ice::Int channel, ::Ice::Float loval, ::Ice::Float hival, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setFilter(channel, loval, hival, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setFilter(::Ice::Int channel, ::Ice::Float loval, ::Ice::Float hival, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setFilter_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setFilter_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->write(loval);
        __os->write(hival);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setFilter(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setFilter_name);
}

void
IceProxy::QS1R::RadioCommander::setMute(::Ice::Int channel, bool on, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setMute(channel, on, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setMute(::Ice::Int channel, bool on, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setMute_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setMute_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->write(on);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setMute(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setMute_name);
}

bool
IceProxy::QS1R::RadioCommander::getMute(::Ice::Int channel, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getMute_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getMute(channel, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getMute(::Ice::Int channel, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getMute_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getMute_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getMute_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

bool
IceProxy::QS1R::RadioCommander::end_getMute(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getMute_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::QS1R::RadioCommander::setNb1Switch(::Ice::Int channel, bool on, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setNb1Switch(channel, on, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setNb1Switch(::Ice::Int channel, bool on, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setNb1Switch_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setNb1Switch_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->write(on);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setNb1Switch(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setNb1Switch_name);
}

void
IceProxy::QS1R::RadioCommander::setNb1Thresh(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setNb1Thresh(channel, value, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setNb1Thresh(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setNb1Thresh_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setNb1Thresh_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->write(value);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setNb1Thresh(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setNb1Thresh_name);
}

bool
IceProxy::QS1R::RadioCommander::getNb1Switch(::Ice::Int channel, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getNb1Switch_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getNb1Switch(channel, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getNb1Switch(::Ice::Int channel, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getNb1Switch_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getNb1Switch_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getNb1Switch_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

bool
IceProxy::QS1R::RadioCommander::end_getNb1Switch(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getNb1Switch_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

::Ice::Int
IceProxy::QS1R::RadioCommander::getNb1Thresh(::Ice::Int channel, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getNb1Thresh_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getNb1Thresh(channel, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getNb1Thresh(::Ice::Int channel, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getNb1Thresh_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getNb1Thresh_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getNb1Thresh_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::QS1R::RadioCommander::end_getNb1Thresh(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getNb1Thresh_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::QS1R::RadioCommander::setNb2Switch(::Ice::Int channel, bool on, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setNb2Switch(channel, on, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setNb2Switch(::Ice::Int channel, bool on, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setNb2Switch_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setNb2Switch_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->write(on);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setNb2Switch(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setNb2Switch_name);
}

void
IceProxy::QS1R::RadioCommander::setNb2Thresh(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setNb2Thresh(channel, value, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setNb2Thresh(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setNb2Thresh_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setNb2Thresh_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->write(value);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setNb2Thresh(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setNb2Thresh_name);
}

bool
IceProxy::QS1R::RadioCommander::getNb2Switch(::Ice::Int channel, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getNb2Switch_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getNb2Switch(channel, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getNb2Switch(::Ice::Int channel, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getNb2Switch_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getNb2Switch_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getNb2Switch_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

bool
IceProxy::QS1R::RadioCommander::end_getNb2Switch(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getNb2Switch_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

::Ice::Int
IceProxy::QS1R::RadioCommander::getNb2Thresh(::Ice::Int channel, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getNb2Thresh_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getNb2Thresh(channel, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getNb2Thresh(::Ice::Int channel, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getNb2Thresh_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getNb2Thresh_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getNb2Thresh_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::QS1R::RadioCommander::end_getNb2Thresh(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getNb2Thresh_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::QS1R::RadioCommander::setPga(bool on, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setPga(on, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setPga(bool on, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setPga_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setPga_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(on);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setPga(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setPga_name);
}

bool
IceProxy::QS1R::RadioCommander::getPga(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getPga_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getPga(__ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getPga(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getPga_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getPga_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getPga_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

bool
IceProxy::QS1R::RadioCommander::end_getPga(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getPga_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::QS1R::RadioCommander::setInbandPsSwitch(::Ice::Int channel, bool on, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setInbandPsSwitch(channel, on, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setInbandPsSwitch(::Ice::Int channel, bool on, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setInbandPsSwitch_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setInbandPsSwitch_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->write(on);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setInbandPsSwitch(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setInbandPsSwitch_name);
}

bool
IceProxy::QS1R::RadioCommander::getInbandPsSwitch(::Ice::Int channel, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getInbandPsSwitch_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getInbandPsSwitch(channel, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getInbandPsSwitch(::Ice::Int channel, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getInbandPsSwitch_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getInbandPsSwitch_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getInbandPsSwitch_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

bool
IceProxy::QS1R::RadioCommander::end_getInbandPsSwitch(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getInbandPsSwitch_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

::Ice::Int
IceProxy::QS1R::RadioCommander::getInbandPsSize(::Ice::Int channel, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getInbandPsSize_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getInbandPsSize(channel, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getInbandPsSize(::Ice::Int channel, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getInbandPsSize_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getInbandPsSize_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getInbandPsSize_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::QS1R::RadioCommander::end_getInbandPsSize(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getInbandPsSize_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::QS1R::RadioCommander::setOutbandPsSwitch(::Ice::Int channel, bool on, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setOutbandPsSwitch(channel, on, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setOutbandPsSwitch(::Ice::Int channel, bool on, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setOutbandPsSwitch_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setOutbandPsSwitch_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->write(on);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setOutbandPsSwitch(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setOutbandPsSwitch_name);
}

bool
IceProxy::QS1R::RadioCommander::getOutbandPsSwitch(::Ice::Int channel, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getOutbandPsSwitch_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getOutbandPsSwitch(channel, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getOutbandPsSwitch(::Ice::Int channel, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getOutbandPsSwitch_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getOutbandPsSwitch_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getOutbandPsSwitch_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

bool
IceProxy::QS1R::RadioCommander::end_getOutbandPsSwitch(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getOutbandPsSwitch_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

::Ice::Int
IceProxy::QS1R::RadioCommander::getOutbandPsSize(::Ice::Int channel, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getOutbandPsSize_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getOutbandPsSize(channel, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getOutbandPsSize(::Ice::Int channel, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getOutbandPsSize_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getOutbandPsSize_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getOutbandPsSize_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::QS1R::RadioCommander::end_getOutbandPsSize(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getOutbandPsSize_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

::std::string
IceProxy::QS1R::RadioCommander::getSpectrumBandwidth(::Ice::Int channel, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getSpectrumBandwidth_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getSpectrumBandwidth(channel, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getSpectrumBandwidth(::Ice::Int channel, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getSpectrumBandwidth_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getSpectrumBandwidth_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getSpectrumBandwidth_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::std::string
IceProxy::QS1R::RadioCommander::end_getSpectrumBandwidth(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getSpectrumBandwidth_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::QS1R::RadioCommander::setSpectrumBandwidth(::Ice::Int channel, const ::std::string& value, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setSpectrumBandwidth(channel, value, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setSpectrumBandwidth(::Ice::Int channel, const ::std::string& value, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setSpectrumBandwidth_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setSpectrumBandwidth_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->write(value);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setSpectrumBandwidth(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setSpectrumBandwidth_name);
}

::std::string
IceProxy::QS1R::RadioCommander::getSpectrumBandwidths(::Ice::Int channel, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getSpectrumBandwidths_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getSpectrumBandwidths(channel, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getSpectrumBandwidths(::Ice::Int channel, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getSpectrumBandwidths_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getSpectrumBandwidths_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getSpectrumBandwidths_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::std::string
IceProxy::QS1R::RadioCommander::end_getSpectrumBandwidths(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getSpectrumBandwidths_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::QS1R::RadioCommander::setRand(bool on, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setRand(on, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setRand(bool on, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setRand_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setRand_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(on);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setRand(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setRand_name);
}

bool
IceProxy::QS1R::RadioCommander::getRand(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getRand_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getRand(__ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getRand(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getRand_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getRand_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getRand_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

bool
IceProxy::QS1R::RadioCommander::end_getRand(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getRand_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

::std::string
IceProxy::QS1R::RadioCommander::getVersion(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getVersion_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getVersion(__ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getVersion(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getVersion_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getVersion_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getVersion_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::std::string
IceProxy::QS1R::RadioCommander::end_getVersion(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getVersion_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::QS1R::RadioCommander::setSamplerate(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setSamplerate(channel, value, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setSamplerate(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setSamplerate_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setSamplerate_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->write(value);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setSamplerate(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setSamplerate_name);
}

::Ice::Float
IceProxy::QS1R::RadioCommander::getSamplerate(::Ice::Int channel, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getSamplerate_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getSamplerate(channel, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getSamplerate(::Ice::Int channel, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getSamplerate_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getSamplerate_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getSamplerate_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Float
IceProxy::QS1R::RadioCommander::end_getSamplerate(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getSamplerate_name);
    ::Ice::Float __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::QS1R::RadioCommander::setSMeterCorrection(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setSMeterCorrection(channel, value, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setSMeterCorrection(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setSMeterCorrection_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setSMeterCorrection_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->write(value);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setSMeterCorrection(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setSMeterCorrection_name);
}

::Ice::Float
IceProxy::QS1R::RadioCommander::getSMeterCorrection(::Ice::Int channel, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getSMeterCorrection_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getSMeterCorrection(channel, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getSMeterCorrection(::Ice::Int channel, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getSMeterCorrection_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getSMeterCorrection_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getSMeterCorrection_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Float
IceProxy::QS1R::RadioCommander::end_getSMeterCorrection(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getSMeterCorrection_name);
    ::Ice::Float __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

::Ice::Float
IceProxy::QS1R::RadioCommander::getSMeterInstantaneous(::Ice::Int channel, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getSMeterInstantaneous_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getSMeterInstantaneous(channel, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getSMeterInstantaneous(::Ice::Int channel, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getSMeterInstantaneous_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getSMeterInstantaneous_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getSMeterInstantaneous_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Float
IceProxy::QS1R::RadioCommander::end_getSMeterInstantaneous(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getSMeterInstantaneous_name);
    ::Ice::Float __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

::Ice::Float
IceProxy::QS1R::RadioCommander::getSMeterAverage(::Ice::Int channel, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getSMeterAverage_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getSMeterAverage(channel, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getSMeterAverage(::Ice::Int channel, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getSMeterAverage_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getSMeterAverage_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getSMeterAverage_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Float
IceProxy::QS1R::RadioCommander::end_getSMeterAverage(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getSMeterAverage_name);
    ::Ice::Float __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::QS1R::RadioCommander::setSquelchSwitch(::Ice::Int channel, bool on, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setSquelchSwitch(channel, on, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setSquelchSwitch(::Ice::Int channel, bool on, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setSquelchSwitch_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setSquelchSwitch_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->write(on);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setSquelchSwitch(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setSquelchSwitch_name);
}

bool
IceProxy::QS1R::RadioCommander::getSquelchSwitch(::Ice::Int channel, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getSquelchSwitch_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getSquelchSwitch(channel, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getSquelchSwitch(::Ice::Int channel, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getSquelchSwitch_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getSquelchSwitch_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getSquelchSwitch_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

bool
IceProxy::QS1R::RadioCommander::end_getSquelchSwitch(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getSquelchSwitch_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::QS1R::RadioCommander::setSquelchThresh(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setSquelchThresh(channel, value, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setSquelchThresh(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setSquelchThresh_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setSquelchThresh_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->write(value);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setSquelchThresh(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setSquelchThresh_name);
}

::Ice::Float
IceProxy::QS1R::RadioCommander::getSquelchThresh(::Ice::Int channel, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getSquelchThresh_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getSquelchThresh(channel, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getSquelchThresh(::Ice::Int channel, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getSquelchThresh_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getSquelchThresh_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getSquelchThresh_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Float
IceProxy::QS1R::RadioCommander::end_getSquelchThresh(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getSquelchThresh_name);
    ::Ice::Float __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::QS1R::RadioCommander::setStart(bool on, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setStart(on, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setStart(bool on, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setStart_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setStart_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(on);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setStart(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setStart_name);
}

bool
IceProxy::QS1R::RadioCommander::getStart(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getStart_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getStart(__ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getStart(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getStart_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getStart_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getStart_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

bool
IceProxy::QS1R::RadioCommander::end_getStart(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getStart_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::QS1R::RadioCommander::setStop(bool on, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setStop(on, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setStop(bool on, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setStop_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setStop_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(on);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setStop(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setStop_name);
}

bool
IceProxy::QS1R::RadioCommander::getStop(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getStop_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getStop(__ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getStop(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getStop_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getStop_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getStop_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

bool
IceProxy::QS1R::RadioCommander::end_getStop(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getStop_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::QS1R::RadioCommander::setVolume(::Ice::Int channel, ::Ice::Float valleft, ::Ice::Float valright, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setVolume(channel, valleft, valright, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setVolume(::Ice::Int channel, ::Ice::Float valleft, ::Ice::Float valright, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setVolume_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setVolume_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->write(valleft);
        __os->write(valright);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setVolume(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setVolume_name);
}

void
IceProxy::QS1R::RadioCommander::setVolumeLeft(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setVolumeLeft(channel, value, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setVolumeLeft(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setVolumeLeft_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setVolumeLeft_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->write(value);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setVolumeLeft(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setVolumeLeft_name);
}

::Ice::Float
IceProxy::QS1R::RadioCommander::getVolumeLeft(::Ice::Int channel, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getVolumeLeft_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getVolumeLeft(channel, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getVolumeLeft(::Ice::Int channel, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getVolumeLeft_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getVolumeLeft_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getVolumeLeft_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Float
IceProxy::QS1R::RadioCommander::end_getVolumeLeft(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getVolumeLeft_name);
    ::Ice::Float __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::QS1R::RadioCommander::setVolumeRight(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setVolumeRight(channel, value, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setVolumeRight(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setVolumeRight_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setVolumeRight_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->write(value);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setVolumeRight(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setVolumeRight_name);
}

::Ice::Float
IceProxy::QS1R::RadioCommander::getVolumeRight(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getVolumeRight_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getVolumeRight(channel, value, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getVolumeRight(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getVolumeRight_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getVolumeRight_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getVolumeRight_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->write(value);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Float
IceProxy::QS1R::RadioCommander::end_getVolumeRight(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getVolumeRight_name);
    ::Ice::Float __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::QS1R::RadioCommander::setLoadFirmware(bool go, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setLoadFirmware(go, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setLoadFirmware(bool go, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setLoadFirmware_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setLoadFirmware_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(go);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setLoadFirmware(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setLoadFirmware_name);
}

void
IceProxy::QS1R::RadioCommander::setLoadFpga(bool go, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            __del->setLoadFpga(go, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_setLoadFpga(bool go, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__setLoadFpga_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__setLoadFpga_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(go);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::QS1R::RadioCommander::end_setLoadFpga(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __QS1R__RadioCommander__setLoadFpga_name);
}

::std::string
IceProxy::QS1R::RadioCommander::getFpgaFileId(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getFpgaFileId_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getFpgaFileId(__ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getFpgaFileId(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getFpgaFileId_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getFpgaFileId_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getFpgaFileId_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::std::string
IceProxy::QS1R::RadioCommander::end_getFpgaFileId(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getFpgaFileId_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

::std::string
IceProxy::QS1R::RadioCommander::getFirmwareFileName(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getFirmwareFileName_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getFirmwareFileName(__ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getFirmwareFileName(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getFirmwareFileName_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getFirmwareFileName_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getFirmwareFileName_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::std::string
IceProxy::QS1R::RadioCommander::end_getFirmwareFileName(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getFirmwareFileName_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

::std::string
IceProxy::QS1R::RadioCommander::getFpgaRbfName(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getFpgaRbfName_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getFpgaRbfName(__ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getFpgaRbfName(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getFpgaRbfName_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getFpgaRbfName_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getFpgaRbfName_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::std::string
IceProxy::QS1R::RadioCommander::end_getFpgaRbfName(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getFpgaRbfName_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

::std::string
IceProxy::QS1R::RadioCommander::getDateTime(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__RadioCommander__getDateTime_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::RadioCommander* __del = dynamic_cast< ::IceDelegate::QS1R::RadioCommander*>(__delBase.get());
            return __del->getDateTime(__ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::RadioCommander::begin_getDateTime(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__RadioCommander__getDateTime_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__RadioCommander__getDateTime_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__RadioCommander__getDateTime_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::std::string
IceProxy::QS1R::RadioCommander::end_getDateTime(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__RadioCommander__getDateTime_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

const ::std::string&
IceProxy::QS1R::RadioCommander::ice_staticId()
{
    return ::QS1R::RadioCommander::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::QS1R::RadioCommander::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::QS1R::RadioCommander);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::QS1R::RadioCommander::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::QS1R::RadioCommander);
}

::IceProxy::Ice::Object*
IceProxy::QS1R::RadioCommander::__newInstance() const
{
    return new RadioCommander;
}

::QS1R::SpecBuffer
IceProxy::QS1R::PowerSpectrumData::getSpecData(::Ice::Int channel, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__PowerSpectrumData__getSpecData_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::PowerSpectrumData* __del = dynamic_cast< ::IceDelegate::QS1R::PowerSpectrumData*>(__delBase.get());
            return __del->getSpecData(channel, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::PowerSpectrumData::begin_getSpecData(::Ice::Int channel, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__PowerSpectrumData__getSpecData_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__PowerSpectrumData__getSpecData_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__PowerSpectrumData__getSpecData_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::QS1R::SpecBuffer
IceProxy::QS1R::PowerSpectrumData::end_getSpecData(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__PowerSpectrumData__getSpecData_name);
    ::QS1R::SpecBuffer __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

::Ice::Int
IceProxy::QS1R::PowerSpectrumData::getSpecDataSize(::Ice::Int channel, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__PowerSpectrumData__getSpecDataSize_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::PowerSpectrumData* __del = dynamic_cast< ::IceDelegate::QS1R::PowerSpectrumData*>(__delBase.get());
            return __del->getSpecDataSize(channel, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::PowerSpectrumData::begin_getSpecDataSize(::Ice::Int channel, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__PowerSpectrumData__getSpecDataSize_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__PowerSpectrumData__getSpecDataSize_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__PowerSpectrumData__getSpecDataSize_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::QS1R::PowerSpectrumData::end_getSpecDataSize(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__PowerSpectrumData__getSpecDataSize_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

const ::std::string&
IceProxy::QS1R::PowerSpectrumData::ice_staticId()
{
    return ::QS1R::PowerSpectrumData::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::QS1R::PowerSpectrumData::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::QS1R::PowerSpectrumData);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::QS1R::PowerSpectrumData::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::QS1R::PowerSpectrumData);
}

::IceProxy::Ice::Object*
IceProxy::QS1R::PowerSpectrumData::__newInstance() const
{
    return new PowerSpectrumData;
}

::QS1R::MeterDataStruct
IceProxy::QS1R::MeterData::getMeterData(::Ice::Int channel, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__QS1R__MeterData__getMeterData_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::QS1R::MeterData* __del = dynamic_cast< ::IceDelegate::QS1R::MeterData*>(__delBase.get());
            return __del->getMeterData(channel, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::QS1R::MeterData::begin_getMeterData(::Ice::Int channel, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__QS1R__MeterData__getMeterData_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __QS1R__MeterData__getMeterData_name, __del, __cookie);
    try
    {
        __result->__prepare(__QS1R__MeterData__getMeterData_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(channel);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::QS1R::MeterDataStruct
IceProxy::QS1R::MeterData::end_getMeterData(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __QS1R__MeterData__getMeterData_name);
    ::QS1R::MeterDataStruct __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __ret.__read(__is);
    __is->endReadEncaps();
    return __ret;
}

const ::std::string&
IceProxy::QS1R::MeterData::ice_staticId()
{
    return ::QS1R::MeterData::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::QS1R::MeterData::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::QS1R::MeterData);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::QS1R::MeterData::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::QS1R::MeterData);
}

::IceProxy::Ice::Object*
IceProxy::QS1R::MeterData::__newInstance() const
{
    return new MeterData;
}

void
IceDelegateM::QS1R::RadioCommander::setAgcMode(::Ice::Int channel, ::QS1R::AGCMODE value, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setAgcMode_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
        ::QS1R::__write(__os, value);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::QS1R::AGCMODE
IceDelegateM::QS1R::RadioCommander::getAgcMode(::Ice::Int channel, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getAgcMode_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::QS1R::AGCMODE __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        ::QS1R::__read(__is, __ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::QS1R::RadioCommander::setAgcMaxGain(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setAgcMaxGain_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
        __os->write(value);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::Ice::Float
IceDelegateM::QS1R::RadioCommander::getAgcMaxGain(::Ice::Int channel, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getAgcMaxGain_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Float __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::QS1R::RadioCommander::setAgcFixedGain(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setAgcFixedGain_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
        __os->write(value);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::Ice::Float
IceDelegateM::QS1R::RadioCommander::getAgcFixedGain(::Ice::Int channel, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getAgcFixedGain_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Float __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::QS1R::RadioCommander::setAgcAttack(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setAgcAttack_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
        __os->write(value);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::Ice::Float
IceDelegateM::QS1R::RadioCommander::getAgcAttack(::Ice::Int channel, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getAgcAttack_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Float __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::QS1R::RadioCommander::setAgcDecay(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setAgcDecay_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
        __os->write(value);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::Ice::Float
IceDelegateM::QS1R::RadioCommander::getAgcDecay(::Ice::Int channel, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getAgcDecay_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Float __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::QS1R::RadioCommander::setAgcHangTime(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setAgcHangTime_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
        __os->write(value);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::Ice::Float
IceDelegateM::QS1R::RadioCommander::getAgcHangTime(::Ice::Int channel, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getAgcHangTime_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Float __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::QS1R::RadioCommander::setAgcHangThresh(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setAgcHangThresh_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
        __os->write(value);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::Ice::Float
IceDelegateM::QS1R::RadioCommander::getAgcHangThresh(::Ice::Int channel, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getAgcHangThresh_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Float __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::QS1R::RadioCommander::setAgcSlope(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setAgcSlope_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
        __os->write(value);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::Ice::Float
IceDelegateM::QS1R::RadioCommander::getAgcSlope(::Ice::Int channel, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getAgcSlope_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Float __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Float
IceDelegateM::QS1R::RadioCommander::getAgcFastGain(::Ice::Int channel, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getAgcFastGain_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Float __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Float
IceDelegateM::QS1R::RadioCommander::getAgcCurrentGain(::Ice::Int channel, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getAgcCurrentGain_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Float __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::QS1R::RadioCommander::setAnfSwitch(::Ice::Int channel, bool on, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setAnfSwitch_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
        __os->write(on);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

bool
IceDelegateM::QS1R::RadioCommander::getAnfSwitch(::Ice::Int channel, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getAnfSwitch_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    bool __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::QS1R::RadioCommander::setAnfDelay(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setAnfDelay_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
        __os->write(value);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::Ice::Int
IceDelegateM::QS1R::RadioCommander::getAnfDelay(::Ice::Int channel, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getAnfDelay_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::QS1R::RadioCommander::setAnfTaps(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setAnfTaps_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
        __os->write(value);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::Ice::Int
IceDelegateM::QS1R::RadioCommander::getAnfTaps(::Ice::Int channel, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getAnfTaps_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::QS1R::RadioCommander::setAnfGain(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setAnfGain_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
        __os->write(value);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::Ice::Float
IceDelegateM::QS1R::RadioCommander::getAnfGain(::Ice::Int channel, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getAnfGain_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Float __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::QS1R::RadioCommander::setAnfLeak(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setAnfLeak_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
        __os->write(value);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::Ice::Float
IceDelegateM::QS1R::RadioCommander::getAnfLeak(::Ice::Int channel, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getAnfLeak_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Float __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::QS1R::RadioCommander::setBinaural(bool on, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setBinaural_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(on);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

bool
IceDelegateM::QS1R::RadioCommander::getBinaural(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getBinaural_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    bool __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::QS1R::RadioCommander::setBlockSize(::Ice::Int value, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setBlockSize_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(value);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::Ice::Int
IceDelegateM::QS1R::RadioCommander::getBlockSize(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getBlockSize_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::QS1R::RadioCommander::setDemodMode(::Ice::Int channel, ::QS1R::DEMODMODE mode, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setDemodMode_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
        ::QS1R::__write(__os, mode);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::QS1R::DEMODMODE
IceDelegateM::QS1R::RadioCommander::getDemodMode(::Ice::Int channel, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getDemodMode_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::QS1R::DEMODMODE __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        ::QS1R::__read(__is, __ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::QS1R::RadioCommander::setControlRegister(::Ice::Int value, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setControlRegister_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(value);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::Ice::Int
IceDelegateM::QS1R::RadioCommander::getControlRegister(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getControlRegister_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::QS1R::RadioCommander::setDecimationRegister(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setDecimationRegister_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
        __os->write(value);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::Ice::Int
IceDelegateM::QS1R::RadioCommander::getDecimationRegister(::Ice::Int channel, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getDecimationRegister_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::QS1R::RadioCommander::setScalingRegister(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setScalingRegister_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
        __os->write(value);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::Ice::Int
IceDelegateM::QS1R::RadioCommander::getScalingRegister(::Ice::Int channel, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getScalingRegister_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::QS1R::RadioCommander::getEepromEncFreqRegister(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getEepromEncFreqRegister_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    ::std::string __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::QS1R::RadioCommander::setDither(bool on, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setDither_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(on);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

bool
IceDelegateM::QS1R::RadioCommander::getDither(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getDither_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    bool __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::QS1R::RadioCommander::setEncodeFreq(::Ice::Float value, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setEncodeFreq_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(value);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::Ice::Float
IceDelegateM::QS1R::RadioCommander::getEncodeFreq(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getEncodeFreq_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    ::Ice::Float __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::QS1R::RadioCommander::setMeterCalibrationOffset(::Ice::Float value, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setMeterCalibrationOffset_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(value);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::Ice::Float
IceDelegateM::QS1R::RadioCommander::getMeterCalibrationOffset(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getMeterCalibrationOffset_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    ::Ice::Float __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::QS1R::RadioCommander::setSpectrumCalibrationOffset(::Ice::Float value, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setSpectrumCalibrationOffset_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(value);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::Ice::Float
IceDelegateM::QS1R::RadioCommander::getSpectrumCalibrationOffset(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getSpectrumCalibrationOffset_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    ::Ice::Float __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::QS1R::RadioCommander::setNrSwitch(::Ice::Int channel, bool on, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setNrSwitch_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
        __os->write(on);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

bool
IceDelegateM::QS1R::RadioCommander::getNrSwitch(::Ice::Int channel, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getNrSwitch_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    bool __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::QS1R::RadioCommander::setNrTaps(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setNrTaps_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
        __os->write(value);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::Ice::Int
IceDelegateM::QS1R::RadioCommander::getNrTaps(::Ice::Int channel, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getNrTaps_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::QS1R::RadioCommander::setNrDelay(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setNrDelay_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
        __os->write(value);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::Ice::Int
IceDelegateM::QS1R::RadioCommander::getNrDelay(::Ice::Int channel, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getNrDelay_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::QS1R::RadioCommander::setNrGain(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setNrGain_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
        __os->write(value);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::Ice::Float
IceDelegateM::QS1R::RadioCommander::getNrGain(::Ice::Int channel, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getNrGain_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Float __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::QS1R::RadioCommander::setNrLeak(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setNrLeak_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
        __os->write(value);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::Ice::Float
IceDelegateM::QS1R::RadioCommander::getNrLeak(::Ice::Int channel, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getNrLeak_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Float __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::QS1R::RadioCommander::setExit(bool on, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setExit_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(on);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::QS1R::RadioCommander::setFrequency(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setFrequency_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
        __os->write(value);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::Ice::Float
IceDelegateM::QS1R::RadioCommander::getFrequency(::Ice::Int channel, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getFrequency_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Float __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::QS1R::RadioCommander::setFilterLo(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setFilterLo_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
        __os->write(value);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::Ice::Float
IceDelegateM::QS1R::RadioCommander::getFilterLo(::Ice::Int channel, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getFilterLo_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Float __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::QS1R::RadioCommander::setFilterHi(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setFilterHi_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
        __os->write(value);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::Ice::Float
IceDelegateM::QS1R::RadioCommander::getFilterHi(::Ice::Int channel, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getFilterHi_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Float __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::QS1R::RadioCommander::setFilter(::Ice::Int channel, ::Ice::Float loval, ::Ice::Float hival, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setFilter_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
        __os->write(loval);
        __os->write(hival);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::QS1R::RadioCommander::setMute(::Ice::Int channel, bool on, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setMute_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
        __os->write(on);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

bool
IceDelegateM::QS1R::RadioCommander::getMute(::Ice::Int channel, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getMute_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    bool __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::QS1R::RadioCommander::setNb1Switch(::Ice::Int channel, bool on, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setNb1Switch_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
        __os->write(on);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::QS1R::RadioCommander::setNb1Thresh(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setNb1Thresh_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
        __os->write(value);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

bool
IceDelegateM::QS1R::RadioCommander::getNb1Switch(::Ice::Int channel, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getNb1Switch_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    bool __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::QS1R::RadioCommander::getNb1Thresh(::Ice::Int channel, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getNb1Thresh_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::QS1R::RadioCommander::setNb2Switch(::Ice::Int channel, bool on, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setNb2Switch_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
        __os->write(on);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::QS1R::RadioCommander::setNb2Thresh(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setNb2Thresh_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
        __os->write(value);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

bool
IceDelegateM::QS1R::RadioCommander::getNb2Switch(::Ice::Int channel, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getNb2Switch_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    bool __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::QS1R::RadioCommander::getNb2Thresh(::Ice::Int channel, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getNb2Thresh_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::QS1R::RadioCommander::setPga(bool on, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setPga_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(on);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

bool
IceDelegateM::QS1R::RadioCommander::getPga(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getPga_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    bool __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::QS1R::RadioCommander::setInbandPsSwitch(::Ice::Int channel, bool on, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setInbandPsSwitch_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
        __os->write(on);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

bool
IceDelegateM::QS1R::RadioCommander::getInbandPsSwitch(::Ice::Int channel, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getInbandPsSwitch_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    bool __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::QS1R::RadioCommander::getInbandPsSize(::Ice::Int channel, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getInbandPsSize_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::QS1R::RadioCommander::setOutbandPsSwitch(::Ice::Int channel, bool on, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setOutbandPsSwitch_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
        __os->write(on);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

bool
IceDelegateM::QS1R::RadioCommander::getOutbandPsSwitch(::Ice::Int channel, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getOutbandPsSwitch_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    bool __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::QS1R::RadioCommander::getOutbandPsSize(::Ice::Int channel, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getOutbandPsSize_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::QS1R::RadioCommander::getSpectrumBandwidth(::Ice::Int channel, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getSpectrumBandwidth_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::std::string __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::QS1R::RadioCommander::setSpectrumBandwidth(::Ice::Int channel, const ::std::string& value, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setSpectrumBandwidth_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
        __os->write(value);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::std::string
IceDelegateM::QS1R::RadioCommander::getSpectrumBandwidths(::Ice::Int channel, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getSpectrumBandwidths_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::std::string __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::QS1R::RadioCommander::setRand(bool on, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setRand_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(on);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

bool
IceDelegateM::QS1R::RadioCommander::getRand(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getRand_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    bool __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::QS1R::RadioCommander::getVersion(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getVersion_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    ::std::string __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::QS1R::RadioCommander::setSamplerate(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setSamplerate_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
        __os->write(value);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::Ice::Float
IceDelegateM::QS1R::RadioCommander::getSamplerate(::Ice::Int channel, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getSamplerate_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Float __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::QS1R::RadioCommander::setSMeterCorrection(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setSMeterCorrection_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
        __os->write(value);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::Ice::Float
IceDelegateM::QS1R::RadioCommander::getSMeterCorrection(::Ice::Int channel, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getSMeterCorrection_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Float __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Float
IceDelegateM::QS1R::RadioCommander::getSMeterInstantaneous(::Ice::Int channel, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getSMeterInstantaneous_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Float __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Float
IceDelegateM::QS1R::RadioCommander::getSMeterAverage(::Ice::Int channel, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getSMeterAverage_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Float __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::QS1R::RadioCommander::setSquelchSwitch(::Ice::Int channel, bool on, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setSquelchSwitch_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
        __os->write(on);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

bool
IceDelegateM::QS1R::RadioCommander::getSquelchSwitch(::Ice::Int channel, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getSquelchSwitch_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    bool __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::QS1R::RadioCommander::setSquelchThresh(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setSquelchThresh_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
        __os->write(value);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::Ice::Float
IceDelegateM::QS1R::RadioCommander::getSquelchThresh(::Ice::Int channel, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getSquelchThresh_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Float __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::QS1R::RadioCommander::setStart(bool on, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setStart_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(on);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

bool
IceDelegateM::QS1R::RadioCommander::getStart(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getStart_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    bool __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::QS1R::RadioCommander::setStop(bool on, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setStop_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(on);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

bool
IceDelegateM::QS1R::RadioCommander::getStop(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getStop_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    bool __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::QS1R::RadioCommander::setVolume(::Ice::Int channel, ::Ice::Float valleft, ::Ice::Float valright, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setVolume_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
        __os->write(valleft);
        __os->write(valright);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::QS1R::RadioCommander::setVolumeLeft(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setVolumeLeft_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
        __os->write(value);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::Ice::Float
IceDelegateM::QS1R::RadioCommander::getVolumeLeft(::Ice::Int channel, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getVolumeLeft_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Float __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::QS1R::RadioCommander::setVolumeRight(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setVolumeRight_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
        __os->write(value);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::Ice::Float
IceDelegateM::QS1R::RadioCommander::getVolumeRight(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getVolumeRight_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
        __os->write(value);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Float __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::QS1R::RadioCommander::setLoadFirmware(bool go, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setLoadFirmware_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(go);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::QS1R::RadioCommander::setLoadFpga(bool go, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__setLoadFpga_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(go);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::std::string
IceDelegateM::QS1R::RadioCommander::getFpgaFileId(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getFpgaFileId_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    ::std::string __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::QS1R::RadioCommander::getFirmwareFileName(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getFirmwareFileName_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    ::std::string __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::QS1R::RadioCommander::getFpgaRbfName(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getFpgaRbfName_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    ::std::string __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::QS1R::RadioCommander::getDateTime(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__RadioCommander__getDateTime_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    ::std::string __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::QS1R::SpecBuffer
IceDelegateM::QS1R::PowerSpectrumData::getSpecData(::Ice::Int channel, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__PowerSpectrumData__getSpecData_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::QS1R::SpecBuffer __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::QS1R::PowerSpectrumData::getSpecDataSize(::Ice::Int channel, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__PowerSpectrumData__getSpecDataSize_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::QS1R::MeterDataStruct
IceDelegateM::QS1R::MeterData::getMeterData(::Ice::Int channel, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __QS1R__MeterData__getMeterData_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(channel);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::QS1R::MeterDataStruct __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __ret.__read(__is);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateD::QS1R::RadioCommander::setAgcMode(::Ice::Int channel, ::QS1R::AGCMODE value, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int channel, ::QS1R::AGCMODE value, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_channel(channel),
            _m_value(value)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setAgcMode(_m_channel, _m_value, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_channel;
        ::QS1R::AGCMODE _m_value;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setAgcMode_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(channel, value, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::QS1R::AGCMODE
IceDelegateD::QS1R::RadioCommander::getAgcMode(::Ice::Int channel, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::QS1R::AGCMODE& __result, ::Ice::Int channel, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_channel(channel)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getAgcMode(_m_channel, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::QS1R::AGCMODE& _result;
        ::Ice::Int _m_channel;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getAgcMode_name, ::Ice::Normal, __context);
    ::QS1R::AGCMODE __result;
    try
    {
        _DirectI __direct(__result, channel, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::QS1R::RadioCommander::setAgcMaxGain(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int channel, ::Ice::Float value, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_channel(channel),
            _m_value(value)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setAgcMaxGain(_m_channel, _m_value, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_channel;
        ::Ice::Float _m_value;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setAgcMaxGain_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(channel, value, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::Ice::Float
IceDelegateD::QS1R::RadioCommander::getAgcMaxGain(::Ice::Int channel, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Float& __result, ::Ice::Int channel, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_channel(channel)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getAgcMaxGain(_m_channel, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Float& _result;
        ::Ice::Int _m_channel;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getAgcMaxGain_name, ::Ice::Normal, __context);
    ::Ice::Float __result;
    try
    {
        _DirectI __direct(__result, channel, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::QS1R::RadioCommander::setAgcFixedGain(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int channel, ::Ice::Float value, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_channel(channel),
            _m_value(value)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setAgcFixedGain(_m_channel, _m_value, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_channel;
        ::Ice::Float _m_value;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setAgcFixedGain_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(channel, value, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::Ice::Float
IceDelegateD::QS1R::RadioCommander::getAgcFixedGain(::Ice::Int channel, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Float& __result, ::Ice::Int channel, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_channel(channel)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getAgcFixedGain(_m_channel, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Float& _result;
        ::Ice::Int _m_channel;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getAgcFixedGain_name, ::Ice::Normal, __context);
    ::Ice::Float __result;
    try
    {
        _DirectI __direct(__result, channel, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::QS1R::RadioCommander::setAgcAttack(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int channel, ::Ice::Float value, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_channel(channel),
            _m_value(value)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setAgcAttack(_m_channel, _m_value, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_channel;
        ::Ice::Float _m_value;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setAgcAttack_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(channel, value, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::Ice::Float
IceDelegateD::QS1R::RadioCommander::getAgcAttack(::Ice::Int channel, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Float& __result, ::Ice::Int channel, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_channel(channel)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getAgcAttack(_m_channel, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Float& _result;
        ::Ice::Int _m_channel;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getAgcAttack_name, ::Ice::Normal, __context);
    ::Ice::Float __result;
    try
    {
        _DirectI __direct(__result, channel, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::QS1R::RadioCommander::setAgcDecay(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int channel, ::Ice::Float value, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_channel(channel),
            _m_value(value)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setAgcDecay(_m_channel, _m_value, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_channel;
        ::Ice::Float _m_value;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setAgcDecay_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(channel, value, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::Ice::Float
IceDelegateD::QS1R::RadioCommander::getAgcDecay(::Ice::Int channel, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Float& __result, ::Ice::Int channel, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_channel(channel)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getAgcDecay(_m_channel, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Float& _result;
        ::Ice::Int _m_channel;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getAgcDecay_name, ::Ice::Normal, __context);
    ::Ice::Float __result;
    try
    {
        _DirectI __direct(__result, channel, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::QS1R::RadioCommander::setAgcHangTime(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int channel, ::Ice::Float value, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_channel(channel),
            _m_value(value)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setAgcHangTime(_m_channel, _m_value, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_channel;
        ::Ice::Float _m_value;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setAgcHangTime_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(channel, value, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::Ice::Float
IceDelegateD::QS1R::RadioCommander::getAgcHangTime(::Ice::Int channel, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Float& __result, ::Ice::Int channel, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_channel(channel)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getAgcHangTime(_m_channel, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Float& _result;
        ::Ice::Int _m_channel;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getAgcHangTime_name, ::Ice::Normal, __context);
    ::Ice::Float __result;
    try
    {
        _DirectI __direct(__result, channel, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::QS1R::RadioCommander::setAgcHangThresh(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int channel, ::Ice::Float value, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_channel(channel),
            _m_value(value)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setAgcHangThresh(_m_channel, _m_value, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_channel;
        ::Ice::Float _m_value;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setAgcHangThresh_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(channel, value, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::Ice::Float
IceDelegateD::QS1R::RadioCommander::getAgcHangThresh(::Ice::Int channel, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Float& __result, ::Ice::Int channel, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_channel(channel)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getAgcHangThresh(_m_channel, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Float& _result;
        ::Ice::Int _m_channel;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getAgcHangThresh_name, ::Ice::Normal, __context);
    ::Ice::Float __result;
    try
    {
        _DirectI __direct(__result, channel, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::QS1R::RadioCommander::setAgcSlope(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int channel, ::Ice::Float value, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_channel(channel),
            _m_value(value)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setAgcSlope(_m_channel, _m_value, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_channel;
        ::Ice::Float _m_value;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setAgcSlope_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(channel, value, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::Ice::Float
IceDelegateD::QS1R::RadioCommander::getAgcSlope(::Ice::Int channel, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Float& __result, ::Ice::Int channel, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_channel(channel)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getAgcSlope(_m_channel, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Float& _result;
        ::Ice::Int _m_channel;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getAgcSlope_name, ::Ice::Normal, __context);
    ::Ice::Float __result;
    try
    {
        _DirectI __direct(__result, channel, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Float
IceDelegateD::QS1R::RadioCommander::getAgcFastGain(::Ice::Int channel, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Float& __result, ::Ice::Int channel, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_channel(channel)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getAgcFastGain(_m_channel, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Float& _result;
        ::Ice::Int _m_channel;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getAgcFastGain_name, ::Ice::Normal, __context);
    ::Ice::Float __result;
    try
    {
        _DirectI __direct(__result, channel, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Float
IceDelegateD::QS1R::RadioCommander::getAgcCurrentGain(::Ice::Int channel, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Float& __result, ::Ice::Int channel, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_channel(channel)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getAgcCurrentGain(_m_channel, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Float& _result;
        ::Ice::Int _m_channel;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getAgcCurrentGain_name, ::Ice::Normal, __context);
    ::Ice::Float __result;
    try
    {
        _DirectI __direct(__result, channel, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::QS1R::RadioCommander::setAnfSwitch(::Ice::Int channel, bool on, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int channel, bool on, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_channel(channel),
            _m_on(on)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setAnfSwitch(_m_channel, _m_on, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_channel;
        bool _m_on;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setAnfSwitch_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(channel, on, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

bool
IceDelegateD::QS1R::RadioCommander::getAnfSwitch(::Ice::Int channel, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(bool& __result, ::Ice::Int channel, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_channel(channel)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getAnfSwitch(_m_channel, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        bool& _result;
        ::Ice::Int _m_channel;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getAnfSwitch_name, ::Ice::Normal, __context);
    bool __result;
    try
    {
        _DirectI __direct(__result, channel, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::QS1R::RadioCommander::setAnfDelay(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int channel, ::Ice::Int value, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_channel(channel),
            _m_value(value)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setAnfDelay(_m_channel, _m_value, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_channel;
        ::Ice::Int _m_value;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setAnfDelay_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(channel, value, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::Ice::Int
IceDelegateD::QS1R::RadioCommander::getAnfDelay(::Ice::Int channel, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, ::Ice::Int channel, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_channel(channel)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getAnfDelay(_m_channel, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
        ::Ice::Int _m_channel;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getAnfDelay_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, channel, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::QS1R::RadioCommander::setAnfTaps(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int channel, ::Ice::Int value, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_channel(channel),
            _m_value(value)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setAnfTaps(_m_channel, _m_value, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_channel;
        ::Ice::Int _m_value;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setAnfTaps_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(channel, value, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::Ice::Int
IceDelegateD::QS1R::RadioCommander::getAnfTaps(::Ice::Int channel, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, ::Ice::Int channel, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_channel(channel)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getAnfTaps(_m_channel, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
        ::Ice::Int _m_channel;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getAnfTaps_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, channel, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::QS1R::RadioCommander::setAnfGain(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int channel, ::Ice::Float value, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_channel(channel),
            _m_value(value)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setAnfGain(_m_channel, _m_value, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_channel;
        ::Ice::Float _m_value;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setAnfGain_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(channel, value, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::Ice::Float
IceDelegateD::QS1R::RadioCommander::getAnfGain(::Ice::Int channel, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Float& __result, ::Ice::Int channel, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_channel(channel)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getAnfGain(_m_channel, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Float& _result;
        ::Ice::Int _m_channel;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getAnfGain_name, ::Ice::Normal, __context);
    ::Ice::Float __result;
    try
    {
        _DirectI __direct(__result, channel, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::QS1R::RadioCommander::setAnfLeak(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int channel, ::Ice::Float value, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_channel(channel),
            _m_value(value)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setAnfLeak(_m_channel, _m_value, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_channel;
        ::Ice::Float _m_value;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setAnfLeak_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(channel, value, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::Ice::Float
IceDelegateD::QS1R::RadioCommander::getAnfLeak(::Ice::Int channel, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Float& __result, ::Ice::Int channel, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_channel(channel)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getAnfLeak(_m_channel, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Float& _result;
        ::Ice::Int _m_channel;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getAnfLeak_name, ::Ice::Normal, __context);
    ::Ice::Float __result;
    try
    {
        _DirectI __direct(__result, channel, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::QS1R::RadioCommander::setBinaural(bool on, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(bool on, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_on(on)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setBinaural(_m_on, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        bool _m_on;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setBinaural_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(on, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

bool
IceDelegateD::QS1R::RadioCommander::getBinaural(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(bool& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getBinaural(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        bool& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getBinaural_name, ::Ice::Normal, __context);
    bool __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::QS1R::RadioCommander::setBlockSize(::Ice::Int value, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int value, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_value(value)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setBlockSize(_m_value, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_value;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setBlockSize_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(value, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::Ice::Int
IceDelegateD::QS1R::RadioCommander::getBlockSize(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getBlockSize(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getBlockSize_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::QS1R::RadioCommander::setDemodMode(::Ice::Int channel, ::QS1R::DEMODMODE mode, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int channel, ::QS1R::DEMODMODE mode, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_channel(channel),
            _m_mode(mode)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setDemodMode(_m_channel, _m_mode, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_channel;
        ::QS1R::DEMODMODE _m_mode;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setDemodMode_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(channel, mode, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::QS1R::DEMODMODE
IceDelegateD::QS1R::RadioCommander::getDemodMode(::Ice::Int channel, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::QS1R::DEMODMODE& __result, ::Ice::Int channel, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_channel(channel)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getDemodMode(_m_channel, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::QS1R::DEMODMODE& _result;
        ::Ice::Int _m_channel;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getDemodMode_name, ::Ice::Normal, __context);
    ::QS1R::DEMODMODE __result;
    try
    {
        _DirectI __direct(__result, channel, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::QS1R::RadioCommander::setControlRegister(::Ice::Int value, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int value, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_value(value)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setControlRegister(_m_value, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_value;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setControlRegister_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(value, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::Ice::Int
IceDelegateD::QS1R::RadioCommander::getControlRegister(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getControlRegister(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getControlRegister_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::QS1R::RadioCommander::setDecimationRegister(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int channel, ::Ice::Int value, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_channel(channel),
            _m_value(value)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setDecimationRegister(_m_channel, _m_value, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_channel;
        ::Ice::Int _m_value;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setDecimationRegister_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(channel, value, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::Ice::Int
IceDelegateD::QS1R::RadioCommander::getDecimationRegister(::Ice::Int channel, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, ::Ice::Int channel, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_channel(channel)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getDecimationRegister(_m_channel, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
        ::Ice::Int _m_channel;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getDecimationRegister_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, channel, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::QS1R::RadioCommander::setScalingRegister(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int channel, ::Ice::Int value, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_channel(channel),
            _m_value(value)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setScalingRegister(_m_channel, _m_value, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_channel;
        ::Ice::Int _m_value;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setScalingRegister_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(channel, value, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::Ice::Int
IceDelegateD::QS1R::RadioCommander::getScalingRegister(::Ice::Int channel, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, ::Ice::Int channel, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_channel(channel)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getScalingRegister(_m_channel, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
        ::Ice::Int _m_channel;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getScalingRegister_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, channel, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::std::string
IceDelegateD::QS1R::RadioCommander::getEepromEncFreqRegister(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::std::string& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getEepromEncFreqRegister(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::std::string& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getEepromEncFreqRegister_name, ::Ice::Normal, __context);
    ::std::string __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::QS1R::RadioCommander::setDither(bool on, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(bool on, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_on(on)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setDither(_m_on, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        bool _m_on;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setDither_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(on, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

bool
IceDelegateD::QS1R::RadioCommander::getDither(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(bool& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getDither(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        bool& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getDither_name, ::Ice::Normal, __context);
    bool __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::QS1R::RadioCommander::setEncodeFreq(::Ice::Float value, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Float value, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_value(value)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setEncodeFreq(_m_value, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Float _m_value;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setEncodeFreq_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(value, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::Ice::Float
IceDelegateD::QS1R::RadioCommander::getEncodeFreq(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Float& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getEncodeFreq(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Float& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getEncodeFreq_name, ::Ice::Normal, __context);
    ::Ice::Float __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::QS1R::RadioCommander::setMeterCalibrationOffset(::Ice::Float value, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Float value, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_value(value)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setMeterCalibrationOffset(_m_value, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Float _m_value;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setMeterCalibrationOffset_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(value, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::Ice::Float
IceDelegateD::QS1R::RadioCommander::getMeterCalibrationOffset(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Float& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getMeterCalibrationOffset(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Float& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getMeterCalibrationOffset_name, ::Ice::Normal, __context);
    ::Ice::Float __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::QS1R::RadioCommander::setSpectrumCalibrationOffset(::Ice::Float value, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Float value, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_value(value)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setSpectrumCalibrationOffset(_m_value, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Float _m_value;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setSpectrumCalibrationOffset_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(value, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::Ice::Float
IceDelegateD::QS1R::RadioCommander::getSpectrumCalibrationOffset(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Float& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getSpectrumCalibrationOffset(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Float& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getSpectrumCalibrationOffset_name, ::Ice::Normal, __context);
    ::Ice::Float __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::QS1R::RadioCommander::setNrSwitch(::Ice::Int channel, bool on, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int channel, bool on, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_channel(channel),
            _m_on(on)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setNrSwitch(_m_channel, _m_on, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_channel;
        bool _m_on;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setNrSwitch_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(channel, on, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

bool
IceDelegateD::QS1R::RadioCommander::getNrSwitch(::Ice::Int channel, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(bool& __result, ::Ice::Int channel, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_channel(channel)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getNrSwitch(_m_channel, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        bool& _result;
        ::Ice::Int _m_channel;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getNrSwitch_name, ::Ice::Normal, __context);
    bool __result;
    try
    {
        _DirectI __direct(__result, channel, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::QS1R::RadioCommander::setNrTaps(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int channel, ::Ice::Int value, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_channel(channel),
            _m_value(value)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setNrTaps(_m_channel, _m_value, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_channel;
        ::Ice::Int _m_value;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setNrTaps_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(channel, value, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::Ice::Int
IceDelegateD::QS1R::RadioCommander::getNrTaps(::Ice::Int channel, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, ::Ice::Int channel, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_channel(channel)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getNrTaps(_m_channel, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
        ::Ice::Int _m_channel;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getNrTaps_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, channel, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::QS1R::RadioCommander::setNrDelay(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int channel, ::Ice::Int value, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_channel(channel),
            _m_value(value)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setNrDelay(_m_channel, _m_value, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_channel;
        ::Ice::Int _m_value;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setNrDelay_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(channel, value, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::Ice::Int
IceDelegateD::QS1R::RadioCommander::getNrDelay(::Ice::Int channel, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, ::Ice::Int channel, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_channel(channel)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getNrDelay(_m_channel, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
        ::Ice::Int _m_channel;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getNrDelay_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, channel, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::QS1R::RadioCommander::setNrGain(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int channel, ::Ice::Float value, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_channel(channel),
            _m_value(value)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setNrGain(_m_channel, _m_value, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_channel;
        ::Ice::Float _m_value;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setNrGain_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(channel, value, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::Ice::Float
IceDelegateD::QS1R::RadioCommander::getNrGain(::Ice::Int channel, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Float& __result, ::Ice::Int channel, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_channel(channel)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getNrGain(_m_channel, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Float& _result;
        ::Ice::Int _m_channel;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getNrGain_name, ::Ice::Normal, __context);
    ::Ice::Float __result;
    try
    {
        _DirectI __direct(__result, channel, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::QS1R::RadioCommander::setNrLeak(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int channel, ::Ice::Float value, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_channel(channel),
            _m_value(value)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setNrLeak(_m_channel, _m_value, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_channel;
        ::Ice::Float _m_value;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setNrLeak_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(channel, value, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::Ice::Float
IceDelegateD::QS1R::RadioCommander::getNrLeak(::Ice::Int channel, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Float& __result, ::Ice::Int channel, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_channel(channel)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getNrLeak(_m_channel, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Float& _result;
        ::Ice::Int _m_channel;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getNrLeak_name, ::Ice::Normal, __context);
    ::Ice::Float __result;
    try
    {
        _DirectI __direct(__result, channel, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::QS1R::RadioCommander::setExit(bool on, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(bool on, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_on(on)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setExit(_m_on, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        bool _m_on;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setExit_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(on, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::QS1R::RadioCommander::setFrequency(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int channel, ::Ice::Float value, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_channel(channel),
            _m_value(value)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setFrequency(_m_channel, _m_value, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_channel;
        ::Ice::Float _m_value;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setFrequency_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(channel, value, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::Ice::Float
IceDelegateD::QS1R::RadioCommander::getFrequency(::Ice::Int channel, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Float& __result, ::Ice::Int channel, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_channel(channel)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getFrequency(_m_channel, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Float& _result;
        ::Ice::Int _m_channel;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getFrequency_name, ::Ice::Normal, __context);
    ::Ice::Float __result;
    try
    {
        _DirectI __direct(__result, channel, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::QS1R::RadioCommander::setFilterLo(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int channel, ::Ice::Float value, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_channel(channel),
            _m_value(value)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setFilterLo(_m_channel, _m_value, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_channel;
        ::Ice::Float _m_value;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setFilterLo_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(channel, value, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::Ice::Float
IceDelegateD::QS1R::RadioCommander::getFilterLo(::Ice::Int channel, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Float& __result, ::Ice::Int channel, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_channel(channel)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getFilterLo(_m_channel, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Float& _result;
        ::Ice::Int _m_channel;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getFilterLo_name, ::Ice::Normal, __context);
    ::Ice::Float __result;
    try
    {
        _DirectI __direct(__result, channel, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::QS1R::RadioCommander::setFilterHi(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int channel, ::Ice::Float value, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_channel(channel),
            _m_value(value)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setFilterHi(_m_channel, _m_value, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_channel;
        ::Ice::Float _m_value;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setFilterHi_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(channel, value, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::Ice::Float
IceDelegateD::QS1R::RadioCommander::getFilterHi(::Ice::Int channel, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Float& __result, ::Ice::Int channel, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_channel(channel)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getFilterHi(_m_channel, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Float& _result;
        ::Ice::Int _m_channel;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getFilterHi_name, ::Ice::Normal, __context);
    ::Ice::Float __result;
    try
    {
        _DirectI __direct(__result, channel, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::QS1R::RadioCommander::setFilter(::Ice::Int channel, ::Ice::Float loval, ::Ice::Float hival, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int channel, ::Ice::Float loval, ::Ice::Float hival, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_channel(channel),
            _m_loval(loval),
            _m_hival(hival)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setFilter(_m_channel, _m_loval, _m_hival, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_channel;
        ::Ice::Float _m_loval;
        ::Ice::Float _m_hival;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setFilter_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(channel, loval, hival, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::QS1R::RadioCommander::setMute(::Ice::Int channel, bool on, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int channel, bool on, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_channel(channel),
            _m_on(on)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setMute(_m_channel, _m_on, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_channel;
        bool _m_on;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setMute_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(channel, on, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

bool
IceDelegateD::QS1R::RadioCommander::getMute(::Ice::Int channel, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(bool& __result, ::Ice::Int channel, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_channel(channel)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getMute(_m_channel, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        bool& _result;
        ::Ice::Int _m_channel;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getMute_name, ::Ice::Normal, __context);
    bool __result;
    try
    {
        _DirectI __direct(__result, channel, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::QS1R::RadioCommander::setNb1Switch(::Ice::Int channel, bool on, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int channel, bool on, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_channel(channel),
            _m_on(on)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setNb1Switch(_m_channel, _m_on, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_channel;
        bool _m_on;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setNb1Switch_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(channel, on, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::QS1R::RadioCommander::setNb1Thresh(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int channel, ::Ice::Int value, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_channel(channel),
            _m_value(value)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setNb1Thresh(_m_channel, _m_value, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_channel;
        ::Ice::Int _m_value;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setNb1Thresh_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(channel, value, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

bool
IceDelegateD::QS1R::RadioCommander::getNb1Switch(::Ice::Int channel, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(bool& __result, ::Ice::Int channel, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_channel(channel)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getNb1Switch(_m_channel, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        bool& _result;
        ::Ice::Int _m_channel;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getNb1Switch_name, ::Ice::Normal, __context);
    bool __result;
    try
    {
        _DirectI __direct(__result, channel, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::QS1R::RadioCommander::getNb1Thresh(::Ice::Int channel, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, ::Ice::Int channel, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_channel(channel)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getNb1Thresh(_m_channel, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
        ::Ice::Int _m_channel;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getNb1Thresh_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, channel, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::QS1R::RadioCommander::setNb2Switch(::Ice::Int channel, bool on, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int channel, bool on, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_channel(channel),
            _m_on(on)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setNb2Switch(_m_channel, _m_on, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_channel;
        bool _m_on;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setNb2Switch_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(channel, on, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::QS1R::RadioCommander::setNb2Thresh(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int channel, ::Ice::Int value, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_channel(channel),
            _m_value(value)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setNb2Thresh(_m_channel, _m_value, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_channel;
        ::Ice::Int _m_value;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setNb2Thresh_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(channel, value, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

bool
IceDelegateD::QS1R::RadioCommander::getNb2Switch(::Ice::Int channel, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(bool& __result, ::Ice::Int channel, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_channel(channel)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getNb2Switch(_m_channel, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        bool& _result;
        ::Ice::Int _m_channel;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getNb2Switch_name, ::Ice::Normal, __context);
    bool __result;
    try
    {
        _DirectI __direct(__result, channel, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::QS1R::RadioCommander::getNb2Thresh(::Ice::Int channel, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, ::Ice::Int channel, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_channel(channel)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getNb2Thresh(_m_channel, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
        ::Ice::Int _m_channel;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getNb2Thresh_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, channel, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::QS1R::RadioCommander::setPga(bool on, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(bool on, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_on(on)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setPga(_m_on, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        bool _m_on;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setPga_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(on, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

bool
IceDelegateD::QS1R::RadioCommander::getPga(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(bool& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getPga(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        bool& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getPga_name, ::Ice::Normal, __context);
    bool __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::QS1R::RadioCommander::setInbandPsSwitch(::Ice::Int channel, bool on, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int channel, bool on, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_channel(channel),
            _m_on(on)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setInbandPsSwitch(_m_channel, _m_on, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_channel;
        bool _m_on;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setInbandPsSwitch_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(channel, on, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

bool
IceDelegateD::QS1R::RadioCommander::getInbandPsSwitch(::Ice::Int channel, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(bool& __result, ::Ice::Int channel, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_channel(channel)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getInbandPsSwitch(_m_channel, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        bool& _result;
        ::Ice::Int _m_channel;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getInbandPsSwitch_name, ::Ice::Normal, __context);
    bool __result;
    try
    {
        _DirectI __direct(__result, channel, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::QS1R::RadioCommander::getInbandPsSize(::Ice::Int channel, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, ::Ice::Int channel, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_channel(channel)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getInbandPsSize(_m_channel, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
        ::Ice::Int _m_channel;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getInbandPsSize_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, channel, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::QS1R::RadioCommander::setOutbandPsSwitch(::Ice::Int channel, bool on, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int channel, bool on, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_channel(channel),
            _m_on(on)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setOutbandPsSwitch(_m_channel, _m_on, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_channel;
        bool _m_on;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setOutbandPsSwitch_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(channel, on, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

bool
IceDelegateD::QS1R::RadioCommander::getOutbandPsSwitch(::Ice::Int channel, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(bool& __result, ::Ice::Int channel, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_channel(channel)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getOutbandPsSwitch(_m_channel, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        bool& _result;
        ::Ice::Int _m_channel;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getOutbandPsSwitch_name, ::Ice::Normal, __context);
    bool __result;
    try
    {
        _DirectI __direct(__result, channel, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::QS1R::RadioCommander::getOutbandPsSize(::Ice::Int channel, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, ::Ice::Int channel, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_channel(channel)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getOutbandPsSize(_m_channel, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
        ::Ice::Int _m_channel;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getOutbandPsSize_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, channel, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::std::string
IceDelegateD::QS1R::RadioCommander::getSpectrumBandwidth(::Ice::Int channel, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::std::string& __result, ::Ice::Int channel, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_channel(channel)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getSpectrumBandwidth(_m_channel, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::std::string& _result;
        ::Ice::Int _m_channel;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getSpectrumBandwidth_name, ::Ice::Normal, __context);
    ::std::string __result;
    try
    {
        _DirectI __direct(__result, channel, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::QS1R::RadioCommander::setSpectrumBandwidth(::Ice::Int channel, const ::std::string& value, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int channel, const ::std::string& value, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_channel(channel),
            _m_value(value)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setSpectrumBandwidth(_m_channel, _m_value, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_channel;
        const ::std::string& _m_value;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setSpectrumBandwidth_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(channel, value, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::std::string
IceDelegateD::QS1R::RadioCommander::getSpectrumBandwidths(::Ice::Int channel, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::std::string& __result, ::Ice::Int channel, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_channel(channel)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getSpectrumBandwidths(_m_channel, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::std::string& _result;
        ::Ice::Int _m_channel;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getSpectrumBandwidths_name, ::Ice::Normal, __context);
    ::std::string __result;
    try
    {
        _DirectI __direct(__result, channel, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::QS1R::RadioCommander::setRand(bool on, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(bool on, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_on(on)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setRand(_m_on, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        bool _m_on;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setRand_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(on, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

bool
IceDelegateD::QS1R::RadioCommander::getRand(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(bool& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getRand(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        bool& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getRand_name, ::Ice::Normal, __context);
    bool __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::std::string
IceDelegateD::QS1R::RadioCommander::getVersion(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::std::string& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getVersion(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::std::string& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getVersion_name, ::Ice::Normal, __context);
    ::std::string __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::QS1R::RadioCommander::setSamplerate(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int channel, ::Ice::Float value, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_channel(channel),
            _m_value(value)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setSamplerate(_m_channel, _m_value, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_channel;
        ::Ice::Float _m_value;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setSamplerate_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(channel, value, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::Ice::Float
IceDelegateD::QS1R::RadioCommander::getSamplerate(::Ice::Int channel, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Float& __result, ::Ice::Int channel, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_channel(channel)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getSamplerate(_m_channel, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Float& _result;
        ::Ice::Int _m_channel;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getSamplerate_name, ::Ice::Normal, __context);
    ::Ice::Float __result;
    try
    {
        _DirectI __direct(__result, channel, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::QS1R::RadioCommander::setSMeterCorrection(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int channel, ::Ice::Float value, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_channel(channel),
            _m_value(value)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setSMeterCorrection(_m_channel, _m_value, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_channel;
        ::Ice::Float _m_value;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setSMeterCorrection_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(channel, value, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::Ice::Float
IceDelegateD::QS1R::RadioCommander::getSMeterCorrection(::Ice::Int channel, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Float& __result, ::Ice::Int channel, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_channel(channel)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getSMeterCorrection(_m_channel, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Float& _result;
        ::Ice::Int _m_channel;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getSMeterCorrection_name, ::Ice::Normal, __context);
    ::Ice::Float __result;
    try
    {
        _DirectI __direct(__result, channel, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Float
IceDelegateD::QS1R::RadioCommander::getSMeterInstantaneous(::Ice::Int channel, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Float& __result, ::Ice::Int channel, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_channel(channel)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getSMeterInstantaneous(_m_channel, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Float& _result;
        ::Ice::Int _m_channel;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getSMeterInstantaneous_name, ::Ice::Normal, __context);
    ::Ice::Float __result;
    try
    {
        _DirectI __direct(__result, channel, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Float
IceDelegateD::QS1R::RadioCommander::getSMeterAverage(::Ice::Int channel, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Float& __result, ::Ice::Int channel, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_channel(channel)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getSMeterAverage(_m_channel, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Float& _result;
        ::Ice::Int _m_channel;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getSMeterAverage_name, ::Ice::Normal, __context);
    ::Ice::Float __result;
    try
    {
        _DirectI __direct(__result, channel, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::QS1R::RadioCommander::setSquelchSwitch(::Ice::Int channel, bool on, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int channel, bool on, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_channel(channel),
            _m_on(on)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setSquelchSwitch(_m_channel, _m_on, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_channel;
        bool _m_on;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setSquelchSwitch_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(channel, on, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

bool
IceDelegateD::QS1R::RadioCommander::getSquelchSwitch(::Ice::Int channel, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(bool& __result, ::Ice::Int channel, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_channel(channel)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getSquelchSwitch(_m_channel, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        bool& _result;
        ::Ice::Int _m_channel;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getSquelchSwitch_name, ::Ice::Normal, __context);
    bool __result;
    try
    {
        _DirectI __direct(__result, channel, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::QS1R::RadioCommander::setSquelchThresh(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int channel, ::Ice::Float value, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_channel(channel),
            _m_value(value)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setSquelchThresh(_m_channel, _m_value, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_channel;
        ::Ice::Float _m_value;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setSquelchThresh_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(channel, value, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::Ice::Float
IceDelegateD::QS1R::RadioCommander::getSquelchThresh(::Ice::Int channel, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Float& __result, ::Ice::Int channel, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_channel(channel)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getSquelchThresh(_m_channel, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Float& _result;
        ::Ice::Int _m_channel;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getSquelchThresh_name, ::Ice::Normal, __context);
    ::Ice::Float __result;
    try
    {
        _DirectI __direct(__result, channel, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::QS1R::RadioCommander::setStart(bool on, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(bool on, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_on(on)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setStart(_m_on, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        bool _m_on;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setStart_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(on, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

bool
IceDelegateD::QS1R::RadioCommander::getStart(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(bool& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getStart(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        bool& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getStart_name, ::Ice::Normal, __context);
    bool __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::QS1R::RadioCommander::setStop(bool on, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(bool on, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_on(on)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setStop(_m_on, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        bool _m_on;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setStop_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(on, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

bool
IceDelegateD::QS1R::RadioCommander::getStop(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(bool& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getStop(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        bool& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getStop_name, ::Ice::Normal, __context);
    bool __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::QS1R::RadioCommander::setVolume(::Ice::Int channel, ::Ice::Float valleft, ::Ice::Float valright, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int channel, ::Ice::Float valleft, ::Ice::Float valright, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_channel(channel),
            _m_valleft(valleft),
            _m_valright(valright)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setVolume(_m_channel, _m_valleft, _m_valright, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_channel;
        ::Ice::Float _m_valleft;
        ::Ice::Float _m_valright;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setVolume_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(channel, valleft, valright, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::QS1R::RadioCommander::setVolumeLeft(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int channel, ::Ice::Float value, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_channel(channel),
            _m_value(value)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setVolumeLeft(_m_channel, _m_value, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_channel;
        ::Ice::Float _m_value;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setVolumeLeft_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(channel, value, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::Ice::Float
IceDelegateD::QS1R::RadioCommander::getVolumeLeft(::Ice::Int channel, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Float& __result, ::Ice::Int channel, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_channel(channel)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getVolumeLeft(_m_channel, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Float& _result;
        ::Ice::Int _m_channel;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getVolumeLeft_name, ::Ice::Normal, __context);
    ::Ice::Float __result;
    try
    {
        _DirectI __direct(__result, channel, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::QS1R::RadioCommander::setVolumeRight(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int channel, ::Ice::Float value, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_channel(channel),
            _m_value(value)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setVolumeRight(_m_channel, _m_value, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_channel;
        ::Ice::Float _m_value;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setVolumeRight_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(channel, value, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::Ice::Float
IceDelegateD::QS1R::RadioCommander::getVolumeRight(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Float& __result, ::Ice::Int channel, ::Ice::Float value, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_channel(channel),
            _m_value(value)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getVolumeRight(_m_channel, _m_value, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Float& _result;
        ::Ice::Int _m_channel;
        ::Ice::Float _m_value;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getVolumeRight_name, ::Ice::Normal, __context);
    ::Ice::Float __result;
    try
    {
        _DirectI __direct(__result, channel, value, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::QS1R::RadioCommander::setLoadFirmware(bool go, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(bool go, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_go(go)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setLoadFirmware(_m_go, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        bool _m_go;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setLoadFirmware_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(go, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::QS1R::RadioCommander::setLoadFpga(bool go, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(bool go, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_go(go)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setLoadFpga(_m_go, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        bool _m_go;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__setLoadFpga_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(go, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::std::string
IceDelegateD::QS1R::RadioCommander::getFpgaFileId(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::std::string& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getFpgaFileId(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::std::string& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getFpgaFileId_name, ::Ice::Normal, __context);
    ::std::string __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::std::string
IceDelegateD::QS1R::RadioCommander::getFirmwareFileName(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::std::string& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getFirmwareFileName(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::std::string& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getFirmwareFileName_name, ::Ice::Normal, __context);
    ::std::string __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::std::string
IceDelegateD::QS1R::RadioCommander::getFpgaRbfName(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::std::string& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getFpgaRbfName(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::std::string& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getFpgaRbfName_name, ::Ice::Normal, __context);
    ::std::string __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::std::string
IceDelegateD::QS1R::RadioCommander::getDateTime(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::std::string& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::RadioCommander* servant = dynamic_cast< ::QS1R::RadioCommander*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getDateTime(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::std::string& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__RadioCommander__getDateTime_name, ::Ice::Normal, __context);
    ::std::string __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::QS1R::SpecBuffer
IceDelegateD::QS1R::PowerSpectrumData::getSpecData(::Ice::Int channel, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::QS1R::SpecBuffer& __result, ::Ice::Int channel, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_channel(channel)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::PowerSpectrumData* servant = dynamic_cast< ::QS1R::PowerSpectrumData*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getSpecData(_m_channel, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::QS1R::SpecBuffer& _result;
        ::Ice::Int _m_channel;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__PowerSpectrumData__getSpecData_name, ::Ice::Normal, __context);
    ::QS1R::SpecBuffer __result;
    try
    {
        _DirectI __direct(__result, channel, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::QS1R::PowerSpectrumData::getSpecDataSize(::Ice::Int channel, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, ::Ice::Int channel, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_channel(channel)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::PowerSpectrumData* servant = dynamic_cast< ::QS1R::PowerSpectrumData*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getSpecDataSize(_m_channel, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
        ::Ice::Int _m_channel;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__PowerSpectrumData__getSpecDataSize_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, channel, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::QS1R::MeterDataStruct
IceDelegateD::QS1R::MeterData::getMeterData(::Ice::Int channel, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::QS1R::MeterDataStruct& __result, ::Ice::Int channel, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_channel(channel)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::QS1R::MeterData* servant = dynamic_cast< ::QS1R::MeterData*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getMeterData(_m_channel, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::QS1R::MeterDataStruct& _result;
        ::Ice::Int _m_channel;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __QS1R__MeterData__getMeterData_name, ::Ice::Normal, __context);
    ::QS1R::MeterDataStruct __result;
    try
    {
        _DirectI __direct(__result, channel, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::ObjectPtr
QS1R::RadioCommander::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

static const ::std::string __QS1R__RadioCommander_ids[2] =
{
    "::Ice::Object",
    "::QS1R::RadioCommander"
};

bool
QS1R::RadioCommander::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__QS1R__RadioCommander_ids, __QS1R__RadioCommander_ids + 2, _s);
}

::std::vector< ::std::string>
QS1R::RadioCommander::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__QS1R__RadioCommander_ids[0], &__QS1R__RadioCommander_ids[2]);
}

const ::std::string&
QS1R::RadioCommander::ice_id(const ::Ice::Current&) const
{
    return __QS1R__RadioCommander_ids[1];
}

const ::std::string&
QS1R::RadioCommander::ice_staticId()
{
    return __QS1R__RadioCommander_ids[1];
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setAgcMode(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    ::QS1R::AGCMODE value;
    __is->read(channel);
    ::QS1R::__read(__is, value);
    __is->endReadEncaps();
    setAgcMode(channel, value, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getAgcMode(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    __is->read(channel);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::QS1R::AGCMODE __ret = getAgcMode(channel, __current);
    ::QS1R::__write(__os, __ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setAgcMaxGain(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    ::Ice::Float value;
    __is->read(channel);
    __is->read(value);
    __is->endReadEncaps();
    setAgcMaxGain(channel, value, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getAgcMaxGain(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    __is->read(channel);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Float __ret = getAgcMaxGain(channel, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setAgcFixedGain(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    ::Ice::Float value;
    __is->read(channel);
    __is->read(value);
    __is->endReadEncaps();
    setAgcFixedGain(channel, value, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getAgcFixedGain(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    __is->read(channel);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Float __ret = getAgcFixedGain(channel, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setAgcAttack(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    ::Ice::Float value;
    __is->read(channel);
    __is->read(value);
    __is->endReadEncaps();
    setAgcAttack(channel, value, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getAgcAttack(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    __is->read(channel);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Float __ret = getAgcAttack(channel, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setAgcDecay(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    ::Ice::Float value;
    __is->read(channel);
    __is->read(value);
    __is->endReadEncaps();
    setAgcDecay(channel, value, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getAgcDecay(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    __is->read(channel);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Float __ret = getAgcDecay(channel, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setAgcHangTime(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    ::Ice::Float value;
    __is->read(channel);
    __is->read(value);
    __is->endReadEncaps();
    setAgcHangTime(channel, value, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getAgcHangTime(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    __is->read(channel);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Float __ret = getAgcHangTime(channel, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setAgcHangThresh(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    ::Ice::Float value;
    __is->read(channel);
    __is->read(value);
    __is->endReadEncaps();
    setAgcHangThresh(channel, value, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getAgcHangThresh(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    __is->read(channel);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Float __ret = getAgcHangThresh(channel, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setAgcSlope(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    ::Ice::Float value;
    __is->read(channel);
    __is->read(value);
    __is->endReadEncaps();
    setAgcSlope(channel, value, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getAgcSlope(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    __is->read(channel);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Float __ret = getAgcSlope(channel, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getAgcFastGain(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    __is->read(channel);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Float __ret = getAgcFastGain(channel, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getAgcCurrentGain(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    __is->read(channel);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Float __ret = getAgcCurrentGain(channel, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setAnfSwitch(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    bool on;
    __is->read(channel);
    __is->read(on);
    __is->endReadEncaps();
    setAnfSwitch(channel, on, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getAnfSwitch(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    __is->read(channel);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = getAnfSwitch(channel, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setAnfDelay(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    ::Ice::Int value;
    __is->read(channel);
    __is->read(value);
    __is->endReadEncaps();
    setAnfDelay(channel, value, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getAnfDelay(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    __is->read(channel);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = getAnfDelay(channel, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setAnfTaps(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    ::Ice::Int value;
    __is->read(channel);
    __is->read(value);
    __is->endReadEncaps();
    setAnfTaps(channel, value, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getAnfTaps(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    __is->read(channel);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = getAnfTaps(channel, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setAnfGain(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    ::Ice::Float value;
    __is->read(channel);
    __is->read(value);
    __is->endReadEncaps();
    setAnfGain(channel, value, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getAnfGain(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    __is->read(channel);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Float __ret = getAnfGain(channel, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setAnfLeak(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    ::Ice::Float value;
    __is->read(channel);
    __is->read(value);
    __is->endReadEncaps();
    setAnfLeak(channel, value, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getAnfLeak(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    __is->read(channel);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Float __ret = getAnfLeak(channel, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setBinaural(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    bool on;
    __is->read(on);
    __is->endReadEncaps();
    setBinaural(on, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getBinaural(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = getBinaural(__current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setBlockSize(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int value;
    __is->read(value);
    __is->endReadEncaps();
    setBlockSize(value, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getBlockSize(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = getBlockSize(__current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setDemodMode(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    ::QS1R::DEMODMODE mode;
    __is->read(channel);
    ::QS1R::__read(__is, mode);
    __is->endReadEncaps();
    setDemodMode(channel, mode, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getDemodMode(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    __is->read(channel);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::QS1R::DEMODMODE __ret = getDemodMode(channel, __current);
    ::QS1R::__write(__os, __ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setControlRegister(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int value;
    __is->read(value);
    __is->endReadEncaps();
    setControlRegister(value, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getControlRegister(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = getControlRegister(__current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setDecimationRegister(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    ::Ice::Int value;
    __is->read(channel);
    __is->read(value);
    __is->endReadEncaps();
    setDecimationRegister(channel, value, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getDecimationRegister(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    __is->read(channel);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = getDecimationRegister(channel, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setScalingRegister(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    ::Ice::Int value;
    __is->read(channel);
    __is->read(value);
    __is->endReadEncaps();
    setScalingRegister(channel, value, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getScalingRegister(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    __is->read(channel);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = getScalingRegister(channel, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getEepromEncFreqRegister(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string __ret = getEepromEncFreqRegister(__current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setDither(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    bool on;
    __is->read(on);
    __is->endReadEncaps();
    setDither(on, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getDither(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = getDither(__current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setEncodeFreq(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Float value;
    __is->read(value);
    __is->endReadEncaps();
    setEncodeFreq(value, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getEncodeFreq(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Float __ret = getEncodeFreq(__current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setMeterCalibrationOffset(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Float value;
    __is->read(value);
    __is->endReadEncaps();
    setMeterCalibrationOffset(value, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getMeterCalibrationOffset(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Float __ret = getMeterCalibrationOffset(__current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setSpectrumCalibrationOffset(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Float value;
    __is->read(value);
    __is->endReadEncaps();
    setSpectrumCalibrationOffset(value, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getSpectrumCalibrationOffset(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Float __ret = getSpectrumCalibrationOffset(__current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setNrSwitch(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    bool on;
    __is->read(channel);
    __is->read(on);
    __is->endReadEncaps();
    setNrSwitch(channel, on, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getNrSwitch(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    __is->read(channel);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = getNrSwitch(channel, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setNrTaps(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    ::Ice::Int value;
    __is->read(channel);
    __is->read(value);
    __is->endReadEncaps();
    setNrTaps(channel, value, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getNrTaps(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    __is->read(channel);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = getNrTaps(channel, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setNrDelay(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    ::Ice::Int value;
    __is->read(channel);
    __is->read(value);
    __is->endReadEncaps();
    setNrDelay(channel, value, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getNrDelay(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    __is->read(channel);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = getNrDelay(channel, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setNrGain(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    ::Ice::Float value;
    __is->read(channel);
    __is->read(value);
    __is->endReadEncaps();
    setNrGain(channel, value, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getNrGain(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    __is->read(channel);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Float __ret = getNrGain(channel, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setNrLeak(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    ::Ice::Float value;
    __is->read(channel);
    __is->read(value);
    __is->endReadEncaps();
    setNrLeak(channel, value, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getNrLeak(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    __is->read(channel);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Float __ret = getNrLeak(channel, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setExit(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    bool on;
    __is->read(on);
    __is->endReadEncaps();
    setExit(on, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setFrequency(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    ::Ice::Float value;
    __is->read(channel);
    __is->read(value);
    __is->endReadEncaps();
    setFrequency(channel, value, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getFrequency(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    __is->read(channel);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Float __ret = getFrequency(channel, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setFilterLo(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    ::Ice::Float value;
    __is->read(channel);
    __is->read(value);
    __is->endReadEncaps();
    setFilterLo(channel, value, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getFilterLo(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    __is->read(channel);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Float __ret = getFilterLo(channel, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setFilterHi(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    ::Ice::Float value;
    __is->read(channel);
    __is->read(value);
    __is->endReadEncaps();
    setFilterHi(channel, value, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getFilterHi(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    __is->read(channel);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Float __ret = getFilterHi(channel, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setFilter(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    ::Ice::Float loval;
    ::Ice::Float hival;
    __is->read(channel);
    __is->read(loval);
    __is->read(hival);
    __is->endReadEncaps();
    setFilter(channel, loval, hival, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setMute(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    bool on;
    __is->read(channel);
    __is->read(on);
    __is->endReadEncaps();
    setMute(channel, on, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getMute(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    __is->read(channel);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = getMute(channel, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setNb1Switch(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    bool on;
    __is->read(channel);
    __is->read(on);
    __is->endReadEncaps();
    setNb1Switch(channel, on, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setNb1Thresh(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    ::Ice::Int value;
    __is->read(channel);
    __is->read(value);
    __is->endReadEncaps();
    setNb1Thresh(channel, value, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getNb1Switch(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    __is->read(channel);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = getNb1Switch(channel, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getNb1Thresh(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    __is->read(channel);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = getNb1Thresh(channel, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setNb2Switch(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    bool on;
    __is->read(channel);
    __is->read(on);
    __is->endReadEncaps();
    setNb2Switch(channel, on, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setNb2Thresh(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    ::Ice::Int value;
    __is->read(channel);
    __is->read(value);
    __is->endReadEncaps();
    setNb2Thresh(channel, value, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getNb2Switch(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    __is->read(channel);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = getNb2Switch(channel, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getNb2Thresh(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    __is->read(channel);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = getNb2Thresh(channel, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setPga(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    bool on;
    __is->read(on);
    __is->endReadEncaps();
    setPga(on, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getPga(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = getPga(__current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setInbandPsSwitch(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    bool on;
    __is->read(channel);
    __is->read(on);
    __is->endReadEncaps();
    setInbandPsSwitch(channel, on, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getInbandPsSwitch(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    __is->read(channel);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = getInbandPsSwitch(channel, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getInbandPsSize(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    __is->read(channel);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = getInbandPsSize(channel, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setOutbandPsSwitch(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    bool on;
    __is->read(channel);
    __is->read(on);
    __is->endReadEncaps();
    setOutbandPsSwitch(channel, on, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getOutbandPsSwitch(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    __is->read(channel);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = getOutbandPsSwitch(channel, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getOutbandPsSize(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    __is->read(channel);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = getOutbandPsSize(channel, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getSpectrumBandwidth(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    __is->read(channel);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string __ret = getSpectrumBandwidth(channel, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setSpectrumBandwidth(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    ::std::string value;
    __is->read(channel);
    __is->read(value);
    __is->endReadEncaps();
    setSpectrumBandwidth(channel, value, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getSpectrumBandwidths(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    __is->read(channel);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string __ret = getSpectrumBandwidths(channel, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setRand(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    bool on;
    __is->read(on);
    __is->endReadEncaps();
    setRand(on, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getRand(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = getRand(__current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getVersion(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string __ret = getVersion(__current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setSamplerate(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    ::Ice::Float value;
    __is->read(channel);
    __is->read(value);
    __is->endReadEncaps();
    setSamplerate(channel, value, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getSamplerate(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    __is->read(channel);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Float __ret = getSamplerate(channel, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setSMeterCorrection(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    ::Ice::Float value;
    __is->read(channel);
    __is->read(value);
    __is->endReadEncaps();
    setSMeterCorrection(channel, value, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getSMeterCorrection(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    __is->read(channel);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Float __ret = getSMeterCorrection(channel, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getSMeterInstantaneous(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    __is->read(channel);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Float __ret = getSMeterInstantaneous(channel, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getSMeterAverage(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    __is->read(channel);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Float __ret = getSMeterAverage(channel, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setSquelchSwitch(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    bool on;
    __is->read(channel);
    __is->read(on);
    __is->endReadEncaps();
    setSquelchSwitch(channel, on, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getSquelchSwitch(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    __is->read(channel);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = getSquelchSwitch(channel, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setSquelchThresh(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    ::Ice::Float value;
    __is->read(channel);
    __is->read(value);
    __is->endReadEncaps();
    setSquelchThresh(channel, value, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getSquelchThresh(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    __is->read(channel);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Float __ret = getSquelchThresh(channel, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setStart(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    bool on;
    __is->read(on);
    __is->endReadEncaps();
    setStart(on, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getStart(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = getStart(__current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setStop(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    bool on;
    __is->read(on);
    __is->endReadEncaps();
    setStop(on, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getStop(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = getStop(__current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setVolume(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    ::Ice::Float valleft;
    ::Ice::Float valright;
    __is->read(channel);
    __is->read(valleft);
    __is->read(valright);
    __is->endReadEncaps();
    setVolume(channel, valleft, valright, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setVolumeLeft(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    ::Ice::Float value;
    __is->read(channel);
    __is->read(value);
    __is->endReadEncaps();
    setVolumeLeft(channel, value, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getVolumeLeft(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    __is->read(channel);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Float __ret = getVolumeLeft(channel, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setVolumeRight(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    ::Ice::Float value;
    __is->read(channel);
    __is->read(value);
    __is->endReadEncaps();
    setVolumeRight(channel, value, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getVolumeRight(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    ::Ice::Float value;
    __is->read(channel);
    __is->read(value);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Float __ret = getVolumeRight(channel, value, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setLoadFirmware(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    bool go;
    __is->read(go);
    __is->endReadEncaps();
    setLoadFirmware(go, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___setLoadFpga(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    bool go;
    __is->read(go);
    __is->endReadEncaps();
    setLoadFpga(go, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getFpgaFileId(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string __ret = getFpgaFileId(__current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getFirmwareFileName(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string __ret = getFirmwareFileName(__current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getFpgaRbfName(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string __ret = getFpgaRbfName(__current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::RadioCommander::___getDateTime(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string __ret = getDateTime(__current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

static ::std::string __QS1R__RadioCommander_all[] =
{
    "getAgcAttack",
    "getAgcCurrentGain",
    "getAgcDecay",
    "getAgcFastGain",
    "getAgcFixedGain",
    "getAgcHangThresh",
    "getAgcHangTime",
    "getAgcMaxGain",
    "getAgcMode",
    "getAgcSlope",
    "getAnfDelay",
    "getAnfGain",
    "getAnfLeak",
    "getAnfSwitch",
    "getAnfTaps",
    "getBinaural",
    "getBlockSize",
    "getControlRegister",
    "getDateTime",
    "getDecimationRegister",
    "getDemodMode",
    "getDither",
    "getEepromEncFreqRegister",
    "getEncodeFreq",
    "getFilterHi",
    "getFilterLo",
    "getFirmwareFileName",
    "getFpgaFileId",
    "getFpgaRbfName",
    "getFrequency",
    "getInbandPsSize",
    "getInbandPsSwitch",
    "getMeterCalibrationOffset",
    "getMute",
    "getNb1Switch",
    "getNb1Thresh",
    "getNb2Switch",
    "getNb2Thresh",
    "getNrDelay",
    "getNrGain",
    "getNrLeak",
    "getNrSwitch",
    "getNrTaps",
    "getOutbandPsSize",
    "getOutbandPsSwitch",
    "getPga",
    "getRand",
    "getSMeterAverage",
    "getSMeterCorrection",
    "getSMeterInstantaneous",
    "getSamplerate",
    "getScalingRegister",
    "getSpectrumBandwidth",
    "getSpectrumBandwidths",
    "getSpectrumCalibrationOffset",
    "getSquelchSwitch",
    "getSquelchThresh",
    "getStart",
    "getStop",
    "getVersion",
    "getVolumeLeft",
    "getVolumeRight",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "setAgcAttack",
    "setAgcDecay",
    "setAgcFixedGain",
    "setAgcHangThresh",
    "setAgcHangTime",
    "setAgcMaxGain",
    "setAgcMode",
    "setAgcSlope",
    "setAnfDelay",
    "setAnfGain",
    "setAnfLeak",
    "setAnfSwitch",
    "setAnfTaps",
    "setBinaural",
    "setBlockSize",
    "setControlRegister",
    "setDecimationRegister",
    "setDemodMode",
    "setDither",
    "setEncodeFreq",
    "setExit",
    "setFilter",
    "setFilterHi",
    "setFilterLo",
    "setFrequency",
    "setInbandPsSwitch",
    "setLoadFirmware",
    "setLoadFpga",
    "setMeterCalibrationOffset",
    "setMute",
    "setNb1Switch",
    "setNb1Thresh",
    "setNb2Switch",
    "setNb2Thresh",
    "setNrDelay",
    "setNrGain",
    "setNrLeak",
    "setNrSwitch",
    "setNrTaps",
    "setOutbandPsSwitch",
    "setPga",
    "setRand",
    "setSMeterCorrection",
    "setSamplerate",
    "setScalingRegister",
    "setSpectrumBandwidth",
    "setSpectrumCalibrationOffset",
    "setSquelchSwitch",
    "setSquelchThresh",
    "setStart",
    "setStop",
    "setVolume",
    "setVolumeLeft",
    "setVolumeRight"
};

::Ice::DispatchStatus
QS1R::RadioCommander::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< ::std::string*, ::std::string*> r = ::std::equal_range(__QS1R__RadioCommander_all, __QS1R__RadioCommander_all + 120, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __QS1R__RadioCommander_all)
    {
        case 0:
        {
            return ___getAgcAttack(in, current);
        }
        case 1:
        {
            return ___getAgcCurrentGain(in, current);
        }
        case 2:
        {
            return ___getAgcDecay(in, current);
        }
        case 3:
        {
            return ___getAgcFastGain(in, current);
        }
        case 4:
        {
            return ___getAgcFixedGain(in, current);
        }
        case 5:
        {
            return ___getAgcHangThresh(in, current);
        }
        case 6:
        {
            return ___getAgcHangTime(in, current);
        }
        case 7:
        {
            return ___getAgcMaxGain(in, current);
        }
        case 8:
        {
            return ___getAgcMode(in, current);
        }
        case 9:
        {
            return ___getAgcSlope(in, current);
        }
        case 10:
        {
            return ___getAnfDelay(in, current);
        }
        case 11:
        {
            return ___getAnfGain(in, current);
        }
        case 12:
        {
            return ___getAnfLeak(in, current);
        }
        case 13:
        {
            return ___getAnfSwitch(in, current);
        }
        case 14:
        {
            return ___getAnfTaps(in, current);
        }
        case 15:
        {
            return ___getBinaural(in, current);
        }
        case 16:
        {
            return ___getBlockSize(in, current);
        }
        case 17:
        {
            return ___getControlRegister(in, current);
        }
        case 18:
        {
            return ___getDateTime(in, current);
        }
        case 19:
        {
            return ___getDecimationRegister(in, current);
        }
        case 20:
        {
            return ___getDemodMode(in, current);
        }
        case 21:
        {
            return ___getDither(in, current);
        }
        case 22:
        {
            return ___getEepromEncFreqRegister(in, current);
        }
        case 23:
        {
            return ___getEncodeFreq(in, current);
        }
        case 24:
        {
            return ___getFilterHi(in, current);
        }
        case 25:
        {
            return ___getFilterLo(in, current);
        }
        case 26:
        {
            return ___getFirmwareFileName(in, current);
        }
        case 27:
        {
            return ___getFpgaFileId(in, current);
        }
        case 28:
        {
            return ___getFpgaRbfName(in, current);
        }
        case 29:
        {
            return ___getFrequency(in, current);
        }
        case 30:
        {
            return ___getInbandPsSize(in, current);
        }
        case 31:
        {
            return ___getInbandPsSwitch(in, current);
        }
        case 32:
        {
            return ___getMeterCalibrationOffset(in, current);
        }
        case 33:
        {
            return ___getMute(in, current);
        }
        case 34:
        {
            return ___getNb1Switch(in, current);
        }
        case 35:
        {
            return ___getNb1Thresh(in, current);
        }
        case 36:
        {
            return ___getNb2Switch(in, current);
        }
        case 37:
        {
            return ___getNb2Thresh(in, current);
        }
        case 38:
        {
            return ___getNrDelay(in, current);
        }
        case 39:
        {
            return ___getNrGain(in, current);
        }
        case 40:
        {
            return ___getNrLeak(in, current);
        }
        case 41:
        {
            return ___getNrSwitch(in, current);
        }
        case 42:
        {
            return ___getNrTaps(in, current);
        }
        case 43:
        {
            return ___getOutbandPsSize(in, current);
        }
        case 44:
        {
            return ___getOutbandPsSwitch(in, current);
        }
        case 45:
        {
            return ___getPga(in, current);
        }
        case 46:
        {
            return ___getRand(in, current);
        }
        case 47:
        {
            return ___getSMeterAverage(in, current);
        }
        case 48:
        {
            return ___getSMeterCorrection(in, current);
        }
        case 49:
        {
            return ___getSMeterInstantaneous(in, current);
        }
        case 50:
        {
            return ___getSamplerate(in, current);
        }
        case 51:
        {
            return ___getScalingRegister(in, current);
        }
        case 52:
        {
            return ___getSpectrumBandwidth(in, current);
        }
        case 53:
        {
            return ___getSpectrumBandwidths(in, current);
        }
        case 54:
        {
            return ___getSpectrumCalibrationOffset(in, current);
        }
        case 55:
        {
            return ___getSquelchSwitch(in, current);
        }
        case 56:
        {
            return ___getSquelchThresh(in, current);
        }
        case 57:
        {
            return ___getStart(in, current);
        }
        case 58:
        {
            return ___getStop(in, current);
        }
        case 59:
        {
            return ___getVersion(in, current);
        }
        case 60:
        {
            return ___getVolumeLeft(in, current);
        }
        case 61:
        {
            return ___getVolumeRight(in, current);
        }
        case 62:
        {
            return ___ice_id(in, current);
        }
        case 63:
        {
            return ___ice_ids(in, current);
        }
        case 64:
        {
            return ___ice_isA(in, current);
        }
        case 65:
        {
            return ___ice_ping(in, current);
        }
        case 66:
        {
            return ___setAgcAttack(in, current);
        }
        case 67:
        {
            return ___setAgcDecay(in, current);
        }
        case 68:
        {
            return ___setAgcFixedGain(in, current);
        }
        case 69:
        {
            return ___setAgcHangThresh(in, current);
        }
        case 70:
        {
            return ___setAgcHangTime(in, current);
        }
        case 71:
        {
            return ___setAgcMaxGain(in, current);
        }
        case 72:
        {
            return ___setAgcMode(in, current);
        }
        case 73:
        {
            return ___setAgcSlope(in, current);
        }
        case 74:
        {
            return ___setAnfDelay(in, current);
        }
        case 75:
        {
            return ___setAnfGain(in, current);
        }
        case 76:
        {
            return ___setAnfLeak(in, current);
        }
        case 77:
        {
            return ___setAnfSwitch(in, current);
        }
        case 78:
        {
            return ___setAnfTaps(in, current);
        }
        case 79:
        {
            return ___setBinaural(in, current);
        }
        case 80:
        {
            return ___setBlockSize(in, current);
        }
        case 81:
        {
            return ___setControlRegister(in, current);
        }
        case 82:
        {
            return ___setDecimationRegister(in, current);
        }
        case 83:
        {
            return ___setDemodMode(in, current);
        }
        case 84:
        {
            return ___setDither(in, current);
        }
        case 85:
        {
            return ___setEncodeFreq(in, current);
        }
        case 86:
        {
            return ___setExit(in, current);
        }
        case 87:
        {
            return ___setFilter(in, current);
        }
        case 88:
        {
            return ___setFilterHi(in, current);
        }
        case 89:
        {
            return ___setFilterLo(in, current);
        }
        case 90:
        {
            return ___setFrequency(in, current);
        }
        case 91:
        {
            return ___setInbandPsSwitch(in, current);
        }
        case 92:
        {
            return ___setLoadFirmware(in, current);
        }
        case 93:
        {
            return ___setLoadFpga(in, current);
        }
        case 94:
        {
            return ___setMeterCalibrationOffset(in, current);
        }
        case 95:
        {
            return ___setMute(in, current);
        }
        case 96:
        {
            return ___setNb1Switch(in, current);
        }
        case 97:
        {
            return ___setNb1Thresh(in, current);
        }
        case 98:
        {
            return ___setNb2Switch(in, current);
        }
        case 99:
        {
            return ___setNb2Thresh(in, current);
        }
        case 100:
        {
            return ___setNrDelay(in, current);
        }
        case 101:
        {
            return ___setNrGain(in, current);
        }
        case 102:
        {
            return ___setNrLeak(in, current);
        }
        case 103:
        {
            return ___setNrSwitch(in, current);
        }
        case 104:
        {
            return ___setNrTaps(in, current);
        }
        case 105:
        {
            return ___setOutbandPsSwitch(in, current);
        }
        case 106:
        {
            return ___setPga(in, current);
        }
        case 107:
        {
            return ___setRand(in, current);
        }
        case 108:
        {
            return ___setSMeterCorrection(in, current);
        }
        case 109:
        {
            return ___setSamplerate(in, current);
        }
        case 110:
        {
            return ___setScalingRegister(in, current);
        }
        case 111:
        {
            return ___setSpectrumBandwidth(in, current);
        }
        case 112:
        {
            return ___setSpectrumCalibrationOffset(in, current);
        }
        case 113:
        {
            return ___setSquelchSwitch(in, current);
        }
        case 114:
        {
            return ___setSquelchThresh(in, current);
        }
        case 115:
        {
            return ___setStart(in, current);
        }
        case 116:
        {
            return ___setStop(in, current);
        }
        case 117:
        {
            return ___setVolume(in, current);
        }
        case 118:
        {
            return ___setVolumeLeft(in, current);
        }
        case 119:
        {
            return ___setVolumeRight(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
QS1R::RadioCommander::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__write(__os);
#else
    ::Ice::Object::__write(__os);
#endif
}

void
QS1R::RadioCommander::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__read(__is, true);
#else
    ::Ice::Object::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
QS1R::RadioCommander::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type QS1R::RadioCommander was not generated with stream support";
    throw ex;
}

void
QS1R::RadioCommander::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type QS1R::RadioCommander was not generated with stream support";
    throw ex;
}
#endif

void 
QS1R::__patch__RadioCommanderPtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::QS1R::RadioCommanderPtr* p = static_cast< ::QS1R::RadioCommanderPtr*>(__addr);
    assert(p);
    *p = ::QS1R::RadioCommanderPtr::dynamicCast(v);
    if(v && !*p)
    {
        IceInternal::Ex::throwUOE(::QS1R::RadioCommander::ice_staticId(), v->ice_id());
    }
}

::Ice::ObjectPtr
QS1R::PowerSpectrumData::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

static const ::std::string __QS1R__PowerSpectrumData_ids[2] =
{
    "::Ice::Object",
    "::QS1R::PowerSpectrumData"
};

bool
QS1R::PowerSpectrumData::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__QS1R__PowerSpectrumData_ids, __QS1R__PowerSpectrumData_ids + 2, _s);
}

::std::vector< ::std::string>
QS1R::PowerSpectrumData::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__QS1R__PowerSpectrumData_ids[0], &__QS1R__PowerSpectrumData_ids[2]);
}

const ::std::string&
QS1R::PowerSpectrumData::ice_id(const ::Ice::Current&) const
{
    return __QS1R__PowerSpectrumData_ids[1];
}

const ::std::string&
QS1R::PowerSpectrumData::ice_staticId()
{
    return __QS1R__PowerSpectrumData_ids[1];
}

::Ice::DispatchStatus
QS1R::PowerSpectrumData::___getSpecData(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    __is->read(channel);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::QS1R::SpecBuffer __ret = getSpecData(channel, __current);
    if(__ret.size() == 0)
    {
        __os->writeSize(0);
    }
    else
    {
        __os->write(&__ret[0], &__ret[0] + __ret.size());
    }
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
QS1R::PowerSpectrumData::___getSpecDataSize(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    __is->read(channel);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = getSpecDataSize(channel, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

static ::std::string __QS1R__PowerSpectrumData_all[] =
{
    "getSpecData",
    "getSpecDataSize",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

::Ice::DispatchStatus
QS1R::PowerSpectrumData::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< ::std::string*, ::std::string*> r = ::std::equal_range(__QS1R__PowerSpectrumData_all, __QS1R__PowerSpectrumData_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __QS1R__PowerSpectrumData_all)
    {
        case 0:
        {
            return ___getSpecData(in, current);
        }
        case 1:
        {
            return ___getSpecDataSize(in, current);
        }
        case 2:
        {
            return ___ice_id(in, current);
        }
        case 3:
        {
            return ___ice_ids(in, current);
        }
        case 4:
        {
            return ___ice_isA(in, current);
        }
        case 5:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
QS1R::PowerSpectrumData::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__write(__os);
#else
    ::Ice::Object::__write(__os);
#endif
}

void
QS1R::PowerSpectrumData::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__read(__is, true);
#else
    ::Ice::Object::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
QS1R::PowerSpectrumData::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type QS1R::PowerSpectrumData was not generated with stream support";
    throw ex;
}

void
QS1R::PowerSpectrumData::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type QS1R::PowerSpectrumData was not generated with stream support";
    throw ex;
}
#endif

void 
QS1R::__patch__PowerSpectrumDataPtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::QS1R::PowerSpectrumDataPtr* p = static_cast< ::QS1R::PowerSpectrumDataPtr*>(__addr);
    assert(p);
    *p = ::QS1R::PowerSpectrumDataPtr::dynamicCast(v);
    if(v && !*p)
    {
        IceInternal::Ex::throwUOE(::QS1R::PowerSpectrumData::ice_staticId(), v->ice_id());
    }
}

::Ice::ObjectPtr
QS1R::MeterData::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

static const ::std::string __QS1R__MeterData_ids[2] =
{
    "::Ice::Object",
    "::QS1R::MeterData"
};

bool
QS1R::MeterData::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__QS1R__MeterData_ids, __QS1R__MeterData_ids + 2, _s);
}

::std::vector< ::std::string>
QS1R::MeterData::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__QS1R__MeterData_ids[0], &__QS1R__MeterData_ids[2]);
}

const ::std::string&
QS1R::MeterData::ice_id(const ::Ice::Current&) const
{
    return __QS1R__MeterData_ids[1];
}

const ::std::string&
QS1R::MeterData::ice_staticId()
{
    return __QS1R__MeterData_ids[1];
}

::Ice::DispatchStatus
QS1R::MeterData::___getMeterData(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int channel;
    __is->read(channel);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::QS1R::MeterDataStruct __ret = getMeterData(channel, __current);
    __ret.__write(__os);
    return ::Ice::DispatchOK;
}

static ::std::string __QS1R__MeterData_all[] =
{
    "getMeterData",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

::Ice::DispatchStatus
QS1R::MeterData::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< ::std::string*, ::std::string*> r = ::std::equal_range(__QS1R__MeterData_all, __QS1R__MeterData_all + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __QS1R__MeterData_all)
    {
        case 0:
        {
            return ___getMeterData(in, current);
        }
        case 1:
        {
            return ___ice_id(in, current);
        }
        case 2:
        {
            return ___ice_ids(in, current);
        }
        case 3:
        {
            return ___ice_isA(in, current);
        }
        case 4:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
QS1R::MeterData::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__write(__os);
#else
    ::Ice::Object::__write(__os);
#endif
}

void
QS1R::MeterData::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__read(__is, true);
#else
    ::Ice::Object::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
QS1R::MeterData::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type QS1R::MeterData was not generated with stream support";
    throw ex;
}

void
QS1R::MeterData::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type QS1R::MeterData was not generated with stream support";
    throw ex;
}
#endif

void 
QS1R::__patch__MeterDataPtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::QS1R::MeterDataPtr* p = static_cast< ::QS1R::MeterDataPtr*>(__addr);
    assert(p);
    *p = ::QS1R::MeterDataPtr::dynamicCast(v);
    if(v && !*p)
    {
        IceInternal::Ex::throwUOE(::QS1R::MeterData::ice_staticId(), v->ice_id());
    }
}
