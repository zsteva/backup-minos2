// **********************************************************************
//
// Copyright (c) 2003-2010 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************

// Ice version 3.4.0

// <auto-generated>
//
// Generated from file `radiointerface.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>

#ifndef __radiointerface_h__
#define __radiointerface_h__

#include <Ice/LocalObjectF.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/Outgoing.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/Incoming.h>
#include <Ice/Direct.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 304
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 0
#       error Ice patch level mismatch!
#   endif
#endif

namespace IceProxy
{

namespace QS1R
{

class RadioCommander;

class PowerSpectrumData;

class MeterData;

}

}

namespace QS1R
{

class RadioCommander;
bool operator==(const RadioCommander&, const RadioCommander&);
bool operator<(const RadioCommander&, const RadioCommander&);

class PowerSpectrumData;
bool operator==(const PowerSpectrumData&, const PowerSpectrumData&);
bool operator<(const PowerSpectrumData&, const PowerSpectrumData&);

class MeterData;
bool operator==(const MeterData&, const MeterData&);
bool operator<(const MeterData&, const MeterData&);

}

namespace IceInternal
{

::Ice::Object* upCast(::QS1R::RadioCommander*);
::IceProxy::Ice::Object* upCast(::IceProxy::QS1R::RadioCommander*);

::Ice::Object* upCast(::QS1R::PowerSpectrumData*);
::IceProxy::Ice::Object* upCast(::IceProxy::QS1R::PowerSpectrumData*);

::Ice::Object* upCast(::QS1R::MeterData*);
::IceProxy::Ice::Object* upCast(::IceProxy::QS1R::MeterData*);

}

namespace QS1R
{

typedef ::IceInternal::Handle< ::QS1R::RadioCommander> RadioCommanderPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::QS1R::RadioCommander> RadioCommanderPrx;

void __read(::IceInternal::BasicStream*, RadioCommanderPrx&);
void __patch__RadioCommanderPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::QS1R::PowerSpectrumData> PowerSpectrumDataPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::QS1R::PowerSpectrumData> PowerSpectrumDataPrx;

void __read(::IceInternal::BasicStream*, PowerSpectrumDataPrx&);
void __patch__PowerSpectrumDataPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::QS1R::MeterData> MeterDataPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::QS1R::MeterData> MeterDataPrx;

void __read(::IceInternal::BasicStream*, MeterDataPrx&);
void __patch__MeterDataPtr(void*, ::Ice::ObjectPtr&);

}

namespace QS1R
{

typedef ::std::vector< ::Ice::Float> SpecBuffer;

struct MeterDataStruct
{
    ::Ice::Float Instantaneous;
    ::Ice::Float Average;

    bool operator==(const MeterDataStruct& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(Instantaneous != __rhs.Instantaneous)
        {
            return false;
        }
        if(Average != __rhs.Average)
        {
            return false;
        }
        return true;
    }

    bool operator<(const MeterDataStruct& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(Instantaneous < __rhs.Instantaneous)
        {
            return true;
        }
        else if(__rhs.Instantaneous < Instantaneous)
        {
            return false;
        }
        if(Average < __rhs.Average)
        {
            return true;
        }
        else if(__rhs.Average < Average)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const MeterDataStruct& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const MeterDataStruct& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const MeterDataStruct& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const MeterDataStruct& __rhs) const
    {
        return !operator<(__rhs);
    }

    void __write(::IceInternal::BasicStream*) const;
    void __read(::IceInternal::BasicStream*);
};

enum AGCMODE
{
    AGCOFF,
    AGCLONG,
    AGCSLOW,
    AGCMED,
    AGCFAST
};

void __write(::IceInternal::BasicStream*, AGCMODE);
void __read(::IceInternal::BasicStream*, AGCMODE&);

enum DEMODMODE
{
    AM,
    SAM,
    LSB,
    DSB,
    USB,
    FMN,
    FMW,
    CWL,
    CWU,
    DIGL,
    DIGU
};

void __write(::IceInternal::BasicStream*, DEMODMODE);
void __read(::IceInternal::BasicStream*, DEMODMODE&);

}

namespace QS1R
{

class Callback_RadioCommander_setAgcMode_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setAgcMode_Base> Callback_RadioCommander_setAgcModePtr;

class Callback_RadioCommander_getAgcMode_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getAgcMode_Base> Callback_RadioCommander_getAgcModePtr;

class Callback_RadioCommander_setAgcMaxGain_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setAgcMaxGain_Base> Callback_RadioCommander_setAgcMaxGainPtr;

class Callback_RadioCommander_getAgcMaxGain_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getAgcMaxGain_Base> Callback_RadioCommander_getAgcMaxGainPtr;

class Callback_RadioCommander_setAgcFixedGain_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setAgcFixedGain_Base> Callback_RadioCommander_setAgcFixedGainPtr;

class Callback_RadioCommander_getAgcFixedGain_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getAgcFixedGain_Base> Callback_RadioCommander_getAgcFixedGainPtr;

class Callback_RadioCommander_setAgcAttack_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setAgcAttack_Base> Callback_RadioCommander_setAgcAttackPtr;

class Callback_RadioCommander_getAgcAttack_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getAgcAttack_Base> Callback_RadioCommander_getAgcAttackPtr;

class Callback_RadioCommander_setAgcDecay_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setAgcDecay_Base> Callback_RadioCommander_setAgcDecayPtr;

class Callback_RadioCommander_getAgcDecay_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getAgcDecay_Base> Callback_RadioCommander_getAgcDecayPtr;

class Callback_RadioCommander_setAgcHangTime_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setAgcHangTime_Base> Callback_RadioCommander_setAgcHangTimePtr;

class Callback_RadioCommander_getAgcHangTime_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getAgcHangTime_Base> Callback_RadioCommander_getAgcHangTimePtr;

class Callback_RadioCommander_setAgcHangThresh_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setAgcHangThresh_Base> Callback_RadioCommander_setAgcHangThreshPtr;

class Callback_RadioCommander_getAgcHangThresh_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getAgcHangThresh_Base> Callback_RadioCommander_getAgcHangThreshPtr;

class Callback_RadioCommander_setAgcSlope_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setAgcSlope_Base> Callback_RadioCommander_setAgcSlopePtr;

class Callback_RadioCommander_getAgcSlope_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getAgcSlope_Base> Callback_RadioCommander_getAgcSlopePtr;

class Callback_RadioCommander_getAgcFastGain_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getAgcFastGain_Base> Callback_RadioCommander_getAgcFastGainPtr;

class Callback_RadioCommander_getAgcCurrentGain_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getAgcCurrentGain_Base> Callback_RadioCommander_getAgcCurrentGainPtr;

class Callback_RadioCommander_setAnfSwitch_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setAnfSwitch_Base> Callback_RadioCommander_setAnfSwitchPtr;

class Callback_RadioCommander_getAnfSwitch_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getAnfSwitch_Base> Callback_RadioCommander_getAnfSwitchPtr;

class Callback_RadioCommander_setAnfDelay_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setAnfDelay_Base> Callback_RadioCommander_setAnfDelayPtr;

class Callback_RadioCommander_getAnfDelay_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getAnfDelay_Base> Callback_RadioCommander_getAnfDelayPtr;

class Callback_RadioCommander_setAnfTaps_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setAnfTaps_Base> Callback_RadioCommander_setAnfTapsPtr;

class Callback_RadioCommander_getAnfTaps_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getAnfTaps_Base> Callback_RadioCommander_getAnfTapsPtr;

class Callback_RadioCommander_setAnfGain_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setAnfGain_Base> Callback_RadioCommander_setAnfGainPtr;

class Callback_RadioCommander_getAnfGain_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getAnfGain_Base> Callback_RadioCommander_getAnfGainPtr;

class Callback_RadioCommander_setAnfLeak_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setAnfLeak_Base> Callback_RadioCommander_setAnfLeakPtr;

class Callback_RadioCommander_getAnfLeak_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getAnfLeak_Base> Callback_RadioCommander_getAnfLeakPtr;

class Callback_RadioCommander_setBinaural_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setBinaural_Base> Callback_RadioCommander_setBinauralPtr;

class Callback_RadioCommander_getBinaural_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getBinaural_Base> Callback_RadioCommander_getBinauralPtr;

class Callback_RadioCommander_setBlockSize_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setBlockSize_Base> Callback_RadioCommander_setBlockSizePtr;

class Callback_RadioCommander_getBlockSize_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getBlockSize_Base> Callback_RadioCommander_getBlockSizePtr;

class Callback_RadioCommander_setDemodMode_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setDemodMode_Base> Callback_RadioCommander_setDemodModePtr;

class Callback_RadioCommander_getDemodMode_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getDemodMode_Base> Callback_RadioCommander_getDemodModePtr;

class Callback_RadioCommander_setControlRegister_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setControlRegister_Base> Callback_RadioCommander_setControlRegisterPtr;

class Callback_RadioCommander_getControlRegister_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getControlRegister_Base> Callback_RadioCommander_getControlRegisterPtr;

class Callback_RadioCommander_setDecimationRegister_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setDecimationRegister_Base> Callback_RadioCommander_setDecimationRegisterPtr;

class Callback_RadioCommander_getDecimationRegister_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getDecimationRegister_Base> Callback_RadioCommander_getDecimationRegisterPtr;

class Callback_RadioCommander_setScalingRegister_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setScalingRegister_Base> Callback_RadioCommander_setScalingRegisterPtr;

class Callback_RadioCommander_getScalingRegister_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getScalingRegister_Base> Callback_RadioCommander_getScalingRegisterPtr;

class Callback_RadioCommander_getEepromEncFreqRegister_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getEepromEncFreqRegister_Base> Callback_RadioCommander_getEepromEncFreqRegisterPtr;

class Callback_RadioCommander_setDither_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setDither_Base> Callback_RadioCommander_setDitherPtr;

class Callback_RadioCommander_getDither_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getDither_Base> Callback_RadioCommander_getDitherPtr;

class Callback_RadioCommander_setEncodeFreq_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setEncodeFreq_Base> Callback_RadioCommander_setEncodeFreqPtr;

class Callback_RadioCommander_getEncodeFreq_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getEncodeFreq_Base> Callback_RadioCommander_getEncodeFreqPtr;

class Callback_RadioCommander_setMeterCalibrationOffset_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setMeterCalibrationOffset_Base> Callback_RadioCommander_setMeterCalibrationOffsetPtr;

class Callback_RadioCommander_getMeterCalibrationOffset_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getMeterCalibrationOffset_Base> Callback_RadioCommander_getMeterCalibrationOffsetPtr;

class Callback_RadioCommander_setSpectrumCalibrationOffset_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setSpectrumCalibrationOffset_Base> Callback_RadioCommander_setSpectrumCalibrationOffsetPtr;

class Callback_RadioCommander_getSpectrumCalibrationOffset_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getSpectrumCalibrationOffset_Base> Callback_RadioCommander_getSpectrumCalibrationOffsetPtr;

class Callback_RadioCommander_setNrSwitch_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setNrSwitch_Base> Callback_RadioCommander_setNrSwitchPtr;

class Callback_RadioCommander_getNrSwitch_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getNrSwitch_Base> Callback_RadioCommander_getNrSwitchPtr;

class Callback_RadioCommander_setNrTaps_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setNrTaps_Base> Callback_RadioCommander_setNrTapsPtr;

class Callback_RadioCommander_getNrTaps_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getNrTaps_Base> Callback_RadioCommander_getNrTapsPtr;

class Callback_RadioCommander_setNrDelay_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setNrDelay_Base> Callback_RadioCommander_setNrDelayPtr;

class Callback_RadioCommander_getNrDelay_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getNrDelay_Base> Callback_RadioCommander_getNrDelayPtr;

class Callback_RadioCommander_setNrGain_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setNrGain_Base> Callback_RadioCommander_setNrGainPtr;

class Callback_RadioCommander_getNrGain_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getNrGain_Base> Callback_RadioCommander_getNrGainPtr;

class Callback_RadioCommander_setNrLeak_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setNrLeak_Base> Callback_RadioCommander_setNrLeakPtr;

class Callback_RadioCommander_getNrLeak_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getNrLeak_Base> Callback_RadioCommander_getNrLeakPtr;

class Callback_RadioCommander_setExit_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setExit_Base> Callback_RadioCommander_setExitPtr;

class Callback_RadioCommander_setFrequency_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setFrequency_Base> Callback_RadioCommander_setFrequencyPtr;

class Callback_RadioCommander_getFrequency_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getFrequency_Base> Callback_RadioCommander_getFrequencyPtr;

class Callback_RadioCommander_setFilterLo_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setFilterLo_Base> Callback_RadioCommander_setFilterLoPtr;

class Callback_RadioCommander_getFilterLo_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getFilterLo_Base> Callback_RadioCommander_getFilterLoPtr;

class Callback_RadioCommander_setFilterHi_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setFilterHi_Base> Callback_RadioCommander_setFilterHiPtr;

class Callback_RadioCommander_getFilterHi_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getFilterHi_Base> Callback_RadioCommander_getFilterHiPtr;

class Callback_RadioCommander_setFilter_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setFilter_Base> Callback_RadioCommander_setFilterPtr;

class Callback_RadioCommander_setMute_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setMute_Base> Callback_RadioCommander_setMutePtr;

class Callback_RadioCommander_getMute_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getMute_Base> Callback_RadioCommander_getMutePtr;

class Callback_RadioCommander_setNb1Switch_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setNb1Switch_Base> Callback_RadioCommander_setNb1SwitchPtr;

class Callback_RadioCommander_setNb1Thresh_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setNb1Thresh_Base> Callback_RadioCommander_setNb1ThreshPtr;

class Callback_RadioCommander_getNb1Switch_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getNb1Switch_Base> Callback_RadioCommander_getNb1SwitchPtr;

class Callback_RadioCommander_getNb1Thresh_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getNb1Thresh_Base> Callback_RadioCommander_getNb1ThreshPtr;

class Callback_RadioCommander_setNb2Switch_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setNb2Switch_Base> Callback_RadioCommander_setNb2SwitchPtr;

class Callback_RadioCommander_setNb2Thresh_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setNb2Thresh_Base> Callback_RadioCommander_setNb2ThreshPtr;

class Callback_RadioCommander_getNb2Switch_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getNb2Switch_Base> Callback_RadioCommander_getNb2SwitchPtr;

class Callback_RadioCommander_getNb2Thresh_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getNb2Thresh_Base> Callback_RadioCommander_getNb2ThreshPtr;

class Callback_RadioCommander_setPga_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setPga_Base> Callback_RadioCommander_setPgaPtr;

class Callback_RadioCommander_getPga_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getPga_Base> Callback_RadioCommander_getPgaPtr;

class Callback_RadioCommander_setInbandPsSwitch_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setInbandPsSwitch_Base> Callback_RadioCommander_setInbandPsSwitchPtr;

class Callback_RadioCommander_getInbandPsSwitch_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getInbandPsSwitch_Base> Callback_RadioCommander_getInbandPsSwitchPtr;

class Callback_RadioCommander_getInbandPsSize_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getInbandPsSize_Base> Callback_RadioCommander_getInbandPsSizePtr;

class Callback_RadioCommander_setOutbandPsSwitch_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setOutbandPsSwitch_Base> Callback_RadioCommander_setOutbandPsSwitchPtr;

class Callback_RadioCommander_getOutbandPsSwitch_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getOutbandPsSwitch_Base> Callback_RadioCommander_getOutbandPsSwitchPtr;

class Callback_RadioCommander_getOutbandPsSize_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getOutbandPsSize_Base> Callback_RadioCommander_getOutbandPsSizePtr;

class Callback_RadioCommander_getSpectrumBandwidth_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getSpectrumBandwidth_Base> Callback_RadioCommander_getSpectrumBandwidthPtr;

class Callback_RadioCommander_setSpectrumBandwidth_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setSpectrumBandwidth_Base> Callback_RadioCommander_setSpectrumBandwidthPtr;

class Callback_RadioCommander_getSpectrumBandwidths_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getSpectrumBandwidths_Base> Callback_RadioCommander_getSpectrumBandwidthsPtr;

class Callback_RadioCommander_setRand_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setRand_Base> Callback_RadioCommander_setRandPtr;

class Callback_RadioCommander_getRand_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getRand_Base> Callback_RadioCommander_getRandPtr;

class Callback_RadioCommander_getVersion_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getVersion_Base> Callback_RadioCommander_getVersionPtr;

class Callback_RadioCommander_setSamplerate_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setSamplerate_Base> Callback_RadioCommander_setSampleratePtr;

class Callback_RadioCommander_getSamplerate_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getSamplerate_Base> Callback_RadioCommander_getSampleratePtr;

class Callback_RadioCommander_setSMeterCorrection_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setSMeterCorrection_Base> Callback_RadioCommander_setSMeterCorrectionPtr;

class Callback_RadioCommander_getSMeterCorrection_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getSMeterCorrection_Base> Callback_RadioCommander_getSMeterCorrectionPtr;

class Callback_RadioCommander_getSMeterInstantaneous_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getSMeterInstantaneous_Base> Callback_RadioCommander_getSMeterInstantaneousPtr;

class Callback_RadioCommander_getSMeterAverage_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getSMeterAverage_Base> Callback_RadioCommander_getSMeterAveragePtr;

class Callback_RadioCommander_setSquelchSwitch_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setSquelchSwitch_Base> Callback_RadioCommander_setSquelchSwitchPtr;

class Callback_RadioCommander_getSquelchSwitch_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getSquelchSwitch_Base> Callback_RadioCommander_getSquelchSwitchPtr;

class Callback_RadioCommander_setSquelchThresh_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setSquelchThresh_Base> Callback_RadioCommander_setSquelchThreshPtr;

class Callback_RadioCommander_getSquelchThresh_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getSquelchThresh_Base> Callback_RadioCommander_getSquelchThreshPtr;

class Callback_RadioCommander_setStart_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setStart_Base> Callback_RadioCommander_setStartPtr;

class Callback_RadioCommander_getStart_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getStart_Base> Callback_RadioCommander_getStartPtr;

class Callback_RadioCommander_setStop_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setStop_Base> Callback_RadioCommander_setStopPtr;

class Callback_RadioCommander_getStop_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getStop_Base> Callback_RadioCommander_getStopPtr;

class Callback_RadioCommander_setVolume_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setVolume_Base> Callback_RadioCommander_setVolumePtr;

class Callback_RadioCommander_setVolumeLeft_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setVolumeLeft_Base> Callback_RadioCommander_setVolumeLeftPtr;

class Callback_RadioCommander_getVolumeLeft_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getVolumeLeft_Base> Callback_RadioCommander_getVolumeLeftPtr;

class Callback_RadioCommander_setVolumeRight_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setVolumeRight_Base> Callback_RadioCommander_setVolumeRightPtr;

class Callback_RadioCommander_getVolumeRight_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getVolumeRight_Base> Callback_RadioCommander_getVolumeRightPtr;

class Callback_RadioCommander_setLoadFirmware_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setLoadFirmware_Base> Callback_RadioCommander_setLoadFirmwarePtr;

class Callback_RadioCommander_setLoadFpga_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_setLoadFpga_Base> Callback_RadioCommander_setLoadFpgaPtr;

class Callback_RadioCommander_getFpgaFileId_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getFpgaFileId_Base> Callback_RadioCommander_getFpgaFileIdPtr;

class Callback_RadioCommander_getFirmwareFileName_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getFirmwareFileName_Base> Callback_RadioCommander_getFirmwareFileNamePtr;

class Callback_RadioCommander_getFpgaRbfName_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getFpgaRbfName_Base> Callback_RadioCommander_getFpgaRbfNamePtr;

class Callback_RadioCommander_getDateTime_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_RadioCommander_getDateTime_Base> Callback_RadioCommander_getDateTimePtr;

class Callback_PowerSpectrumData_getSpecData_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_PowerSpectrumData_getSpecData_Base> Callback_PowerSpectrumData_getSpecDataPtr;

class Callback_PowerSpectrumData_getSpecDataSize_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_PowerSpectrumData_getSpecDataSize_Base> Callback_PowerSpectrumData_getSpecDataSizePtr;

class Callback_MeterData_getMeterData_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MeterData_getMeterData_Base> Callback_MeterData_getMeterDataPtr;

}

namespace IceProxy
{

namespace QS1R
{

class RadioCommander : virtual public ::IceProxy::Ice::Object
{
public:

    void setAgcMode(::Ice::Int channel, ::QS1R::AGCMODE value)
    {
        setAgcMode(channel, value, 0);
    }
    void setAgcMode(::Ice::Int channel, ::QS1R::AGCMODE value, const ::Ice::Context& __ctx)
    {
        setAgcMode(channel, value, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setAgcMode(::Ice::Int channel, ::QS1R::AGCMODE value)
    {
        return begin_setAgcMode(channel, value, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setAgcMode(::Ice::Int channel, ::QS1R::AGCMODE value, const ::Ice::Context& __ctx)
    {
        return begin_setAgcMode(channel, value, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setAgcMode(::Ice::Int channel, ::QS1R::AGCMODE value, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAgcMode(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setAgcMode(::Ice::Int channel, ::QS1R::AGCMODE value, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAgcMode(channel, value, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setAgcMode(::Ice::Int channel, ::QS1R::AGCMODE value, const ::QS1R::Callback_RadioCommander_setAgcModePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAgcMode(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setAgcMode(::Ice::Int channel, ::QS1R::AGCMODE value, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setAgcModePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAgcMode(channel, value, &__ctx, __del, __cookie);
    }

    void end_setAgcMode(const ::Ice::AsyncResultPtr&);
    
private:

    void setAgcMode(::Ice::Int, ::QS1R::AGCMODE, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setAgcMode(::Ice::Int, ::QS1R::AGCMODE, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::QS1R::AGCMODE getAgcMode(::Ice::Int channel)
    {
        return getAgcMode(channel, 0);
    }
    ::QS1R::AGCMODE getAgcMode(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return getAgcMode(channel, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getAgcMode(::Ice::Int channel)
    {
        return begin_getAgcMode(channel, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAgcMode(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return begin_getAgcMode(channel, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAgcMode(::Ice::Int channel, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAgcMode(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAgcMode(::Ice::Int channel, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAgcMode(channel, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAgcMode(::Ice::Int channel, const ::QS1R::Callback_RadioCommander_getAgcModePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAgcMode(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAgcMode(::Ice::Int channel, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getAgcModePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAgcMode(channel, &__ctx, __del, __cookie);
    }

    ::QS1R::AGCMODE end_getAgcMode(const ::Ice::AsyncResultPtr&);
    
private:

    ::QS1R::AGCMODE getAgcMode(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getAgcMode(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setAgcMaxGain(::Ice::Int channel, ::Ice::Float value)
    {
        setAgcMaxGain(channel, value, 0);
    }
    void setAgcMaxGain(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx)
    {
        setAgcMaxGain(channel, value, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setAgcMaxGain(::Ice::Int channel, ::Ice::Float value)
    {
        return begin_setAgcMaxGain(channel, value, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setAgcMaxGain(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx)
    {
        return begin_setAgcMaxGain(channel, value, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setAgcMaxGain(::Ice::Int channel, ::Ice::Float value, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAgcMaxGain(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setAgcMaxGain(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAgcMaxGain(channel, value, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setAgcMaxGain(::Ice::Int channel, ::Ice::Float value, const ::QS1R::Callback_RadioCommander_setAgcMaxGainPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAgcMaxGain(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setAgcMaxGain(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setAgcMaxGainPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAgcMaxGain(channel, value, &__ctx, __del, __cookie);
    }

    void end_setAgcMaxGain(const ::Ice::AsyncResultPtr&);
    
private:

    void setAgcMaxGain(::Ice::Int, ::Ice::Float, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setAgcMaxGain(::Ice::Int, ::Ice::Float, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Float getAgcMaxGain(::Ice::Int channel)
    {
        return getAgcMaxGain(channel, 0);
    }
    ::Ice::Float getAgcMaxGain(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return getAgcMaxGain(channel, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getAgcMaxGain(::Ice::Int channel)
    {
        return begin_getAgcMaxGain(channel, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAgcMaxGain(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return begin_getAgcMaxGain(channel, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAgcMaxGain(::Ice::Int channel, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAgcMaxGain(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAgcMaxGain(::Ice::Int channel, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAgcMaxGain(channel, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAgcMaxGain(::Ice::Int channel, const ::QS1R::Callback_RadioCommander_getAgcMaxGainPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAgcMaxGain(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAgcMaxGain(::Ice::Int channel, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getAgcMaxGainPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAgcMaxGain(channel, &__ctx, __del, __cookie);
    }

    ::Ice::Float end_getAgcMaxGain(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Float getAgcMaxGain(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getAgcMaxGain(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setAgcFixedGain(::Ice::Int channel, ::Ice::Float value)
    {
        setAgcFixedGain(channel, value, 0);
    }
    void setAgcFixedGain(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx)
    {
        setAgcFixedGain(channel, value, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setAgcFixedGain(::Ice::Int channel, ::Ice::Float value)
    {
        return begin_setAgcFixedGain(channel, value, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setAgcFixedGain(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx)
    {
        return begin_setAgcFixedGain(channel, value, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setAgcFixedGain(::Ice::Int channel, ::Ice::Float value, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAgcFixedGain(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setAgcFixedGain(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAgcFixedGain(channel, value, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setAgcFixedGain(::Ice::Int channel, ::Ice::Float value, const ::QS1R::Callback_RadioCommander_setAgcFixedGainPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAgcFixedGain(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setAgcFixedGain(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setAgcFixedGainPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAgcFixedGain(channel, value, &__ctx, __del, __cookie);
    }

    void end_setAgcFixedGain(const ::Ice::AsyncResultPtr&);
    
private:

    void setAgcFixedGain(::Ice::Int, ::Ice::Float, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setAgcFixedGain(::Ice::Int, ::Ice::Float, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Float getAgcFixedGain(::Ice::Int channel)
    {
        return getAgcFixedGain(channel, 0);
    }
    ::Ice::Float getAgcFixedGain(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return getAgcFixedGain(channel, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getAgcFixedGain(::Ice::Int channel)
    {
        return begin_getAgcFixedGain(channel, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAgcFixedGain(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return begin_getAgcFixedGain(channel, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAgcFixedGain(::Ice::Int channel, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAgcFixedGain(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAgcFixedGain(::Ice::Int channel, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAgcFixedGain(channel, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAgcFixedGain(::Ice::Int channel, const ::QS1R::Callback_RadioCommander_getAgcFixedGainPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAgcFixedGain(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAgcFixedGain(::Ice::Int channel, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getAgcFixedGainPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAgcFixedGain(channel, &__ctx, __del, __cookie);
    }

    ::Ice::Float end_getAgcFixedGain(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Float getAgcFixedGain(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getAgcFixedGain(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setAgcAttack(::Ice::Int channel, ::Ice::Float value)
    {
        setAgcAttack(channel, value, 0);
    }
    void setAgcAttack(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx)
    {
        setAgcAttack(channel, value, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setAgcAttack(::Ice::Int channel, ::Ice::Float value)
    {
        return begin_setAgcAttack(channel, value, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setAgcAttack(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx)
    {
        return begin_setAgcAttack(channel, value, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setAgcAttack(::Ice::Int channel, ::Ice::Float value, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAgcAttack(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setAgcAttack(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAgcAttack(channel, value, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setAgcAttack(::Ice::Int channel, ::Ice::Float value, const ::QS1R::Callback_RadioCommander_setAgcAttackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAgcAttack(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setAgcAttack(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setAgcAttackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAgcAttack(channel, value, &__ctx, __del, __cookie);
    }

    void end_setAgcAttack(const ::Ice::AsyncResultPtr&);
    
private:

    void setAgcAttack(::Ice::Int, ::Ice::Float, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setAgcAttack(::Ice::Int, ::Ice::Float, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Float getAgcAttack(::Ice::Int channel)
    {
        return getAgcAttack(channel, 0);
    }
    ::Ice::Float getAgcAttack(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return getAgcAttack(channel, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getAgcAttack(::Ice::Int channel)
    {
        return begin_getAgcAttack(channel, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAgcAttack(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return begin_getAgcAttack(channel, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAgcAttack(::Ice::Int channel, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAgcAttack(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAgcAttack(::Ice::Int channel, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAgcAttack(channel, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAgcAttack(::Ice::Int channel, const ::QS1R::Callback_RadioCommander_getAgcAttackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAgcAttack(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAgcAttack(::Ice::Int channel, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getAgcAttackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAgcAttack(channel, &__ctx, __del, __cookie);
    }

    ::Ice::Float end_getAgcAttack(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Float getAgcAttack(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getAgcAttack(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setAgcDecay(::Ice::Int channel, ::Ice::Float value)
    {
        setAgcDecay(channel, value, 0);
    }
    void setAgcDecay(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx)
    {
        setAgcDecay(channel, value, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setAgcDecay(::Ice::Int channel, ::Ice::Float value)
    {
        return begin_setAgcDecay(channel, value, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setAgcDecay(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx)
    {
        return begin_setAgcDecay(channel, value, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setAgcDecay(::Ice::Int channel, ::Ice::Float value, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAgcDecay(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setAgcDecay(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAgcDecay(channel, value, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setAgcDecay(::Ice::Int channel, ::Ice::Float value, const ::QS1R::Callback_RadioCommander_setAgcDecayPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAgcDecay(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setAgcDecay(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setAgcDecayPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAgcDecay(channel, value, &__ctx, __del, __cookie);
    }

    void end_setAgcDecay(const ::Ice::AsyncResultPtr&);
    
private:

    void setAgcDecay(::Ice::Int, ::Ice::Float, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setAgcDecay(::Ice::Int, ::Ice::Float, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Float getAgcDecay(::Ice::Int channel)
    {
        return getAgcDecay(channel, 0);
    }
    ::Ice::Float getAgcDecay(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return getAgcDecay(channel, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getAgcDecay(::Ice::Int channel)
    {
        return begin_getAgcDecay(channel, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAgcDecay(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return begin_getAgcDecay(channel, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAgcDecay(::Ice::Int channel, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAgcDecay(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAgcDecay(::Ice::Int channel, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAgcDecay(channel, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAgcDecay(::Ice::Int channel, const ::QS1R::Callback_RadioCommander_getAgcDecayPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAgcDecay(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAgcDecay(::Ice::Int channel, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getAgcDecayPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAgcDecay(channel, &__ctx, __del, __cookie);
    }

    ::Ice::Float end_getAgcDecay(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Float getAgcDecay(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getAgcDecay(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setAgcHangTime(::Ice::Int channel, ::Ice::Float value)
    {
        setAgcHangTime(channel, value, 0);
    }
    void setAgcHangTime(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx)
    {
        setAgcHangTime(channel, value, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setAgcHangTime(::Ice::Int channel, ::Ice::Float value)
    {
        return begin_setAgcHangTime(channel, value, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setAgcHangTime(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx)
    {
        return begin_setAgcHangTime(channel, value, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setAgcHangTime(::Ice::Int channel, ::Ice::Float value, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAgcHangTime(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setAgcHangTime(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAgcHangTime(channel, value, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setAgcHangTime(::Ice::Int channel, ::Ice::Float value, const ::QS1R::Callback_RadioCommander_setAgcHangTimePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAgcHangTime(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setAgcHangTime(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setAgcHangTimePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAgcHangTime(channel, value, &__ctx, __del, __cookie);
    }

    void end_setAgcHangTime(const ::Ice::AsyncResultPtr&);
    
private:

    void setAgcHangTime(::Ice::Int, ::Ice::Float, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setAgcHangTime(::Ice::Int, ::Ice::Float, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Float getAgcHangTime(::Ice::Int channel)
    {
        return getAgcHangTime(channel, 0);
    }
    ::Ice::Float getAgcHangTime(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return getAgcHangTime(channel, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getAgcHangTime(::Ice::Int channel)
    {
        return begin_getAgcHangTime(channel, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAgcHangTime(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return begin_getAgcHangTime(channel, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAgcHangTime(::Ice::Int channel, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAgcHangTime(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAgcHangTime(::Ice::Int channel, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAgcHangTime(channel, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAgcHangTime(::Ice::Int channel, const ::QS1R::Callback_RadioCommander_getAgcHangTimePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAgcHangTime(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAgcHangTime(::Ice::Int channel, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getAgcHangTimePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAgcHangTime(channel, &__ctx, __del, __cookie);
    }

    ::Ice::Float end_getAgcHangTime(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Float getAgcHangTime(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getAgcHangTime(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setAgcHangThresh(::Ice::Int channel, ::Ice::Float value)
    {
        setAgcHangThresh(channel, value, 0);
    }
    void setAgcHangThresh(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx)
    {
        setAgcHangThresh(channel, value, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setAgcHangThresh(::Ice::Int channel, ::Ice::Float value)
    {
        return begin_setAgcHangThresh(channel, value, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setAgcHangThresh(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx)
    {
        return begin_setAgcHangThresh(channel, value, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setAgcHangThresh(::Ice::Int channel, ::Ice::Float value, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAgcHangThresh(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setAgcHangThresh(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAgcHangThresh(channel, value, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setAgcHangThresh(::Ice::Int channel, ::Ice::Float value, const ::QS1R::Callback_RadioCommander_setAgcHangThreshPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAgcHangThresh(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setAgcHangThresh(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setAgcHangThreshPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAgcHangThresh(channel, value, &__ctx, __del, __cookie);
    }

    void end_setAgcHangThresh(const ::Ice::AsyncResultPtr&);
    
private:

    void setAgcHangThresh(::Ice::Int, ::Ice::Float, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setAgcHangThresh(::Ice::Int, ::Ice::Float, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Float getAgcHangThresh(::Ice::Int channel)
    {
        return getAgcHangThresh(channel, 0);
    }
    ::Ice::Float getAgcHangThresh(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return getAgcHangThresh(channel, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getAgcHangThresh(::Ice::Int channel)
    {
        return begin_getAgcHangThresh(channel, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAgcHangThresh(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return begin_getAgcHangThresh(channel, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAgcHangThresh(::Ice::Int channel, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAgcHangThresh(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAgcHangThresh(::Ice::Int channel, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAgcHangThresh(channel, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAgcHangThresh(::Ice::Int channel, const ::QS1R::Callback_RadioCommander_getAgcHangThreshPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAgcHangThresh(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAgcHangThresh(::Ice::Int channel, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getAgcHangThreshPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAgcHangThresh(channel, &__ctx, __del, __cookie);
    }

    ::Ice::Float end_getAgcHangThresh(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Float getAgcHangThresh(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getAgcHangThresh(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setAgcSlope(::Ice::Int channel, ::Ice::Float value)
    {
        setAgcSlope(channel, value, 0);
    }
    void setAgcSlope(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx)
    {
        setAgcSlope(channel, value, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setAgcSlope(::Ice::Int channel, ::Ice::Float value)
    {
        return begin_setAgcSlope(channel, value, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setAgcSlope(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx)
    {
        return begin_setAgcSlope(channel, value, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setAgcSlope(::Ice::Int channel, ::Ice::Float value, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAgcSlope(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setAgcSlope(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAgcSlope(channel, value, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setAgcSlope(::Ice::Int channel, ::Ice::Float value, const ::QS1R::Callback_RadioCommander_setAgcSlopePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAgcSlope(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setAgcSlope(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setAgcSlopePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAgcSlope(channel, value, &__ctx, __del, __cookie);
    }

    void end_setAgcSlope(const ::Ice::AsyncResultPtr&);
    
private:

    void setAgcSlope(::Ice::Int, ::Ice::Float, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setAgcSlope(::Ice::Int, ::Ice::Float, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Float getAgcSlope(::Ice::Int channel)
    {
        return getAgcSlope(channel, 0);
    }
    ::Ice::Float getAgcSlope(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return getAgcSlope(channel, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getAgcSlope(::Ice::Int channel)
    {
        return begin_getAgcSlope(channel, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAgcSlope(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return begin_getAgcSlope(channel, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAgcSlope(::Ice::Int channel, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAgcSlope(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAgcSlope(::Ice::Int channel, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAgcSlope(channel, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAgcSlope(::Ice::Int channel, const ::QS1R::Callback_RadioCommander_getAgcSlopePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAgcSlope(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAgcSlope(::Ice::Int channel, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getAgcSlopePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAgcSlope(channel, &__ctx, __del, __cookie);
    }

    ::Ice::Float end_getAgcSlope(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Float getAgcSlope(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getAgcSlope(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Float getAgcFastGain(::Ice::Int channel)
    {
        return getAgcFastGain(channel, 0);
    }
    ::Ice::Float getAgcFastGain(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return getAgcFastGain(channel, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getAgcFastGain(::Ice::Int channel)
    {
        return begin_getAgcFastGain(channel, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAgcFastGain(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return begin_getAgcFastGain(channel, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAgcFastGain(::Ice::Int channel, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAgcFastGain(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAgcFastGain(::Ice::Int channel, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAgcFastGain(channel, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAgcFastGain(::Ice::Int channel, const ::QS1R::Callback_RadioCommander_getAgcFastGainPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAgcFastGain(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAgcFastGain(::Ice::Int channel, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getAgcFastGainPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAgcFastGain(channel, &__ctx, __del, __cookie);
    }

    ::Ice::Float end_getAgcFastGain(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Float getAgcFastGain(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getAgcFastGain(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Float getAgcCurrentGain(::Ice::Int channel)
    {
        return getAgcCurrentGain(channel, 0);
    }
    ::Ice::Float getAgcCurrentGain(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return getAgcCurrentGain(channel, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getAgcCurrentGain(::Ice::Int channel)
    {
        return begin_getAgcCurrentGain(channel, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAgcCurrentGain(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return begin_getAgcCurrentGain(channel, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAgcCurrentGain(::Ice::Int channel, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAgcCurrentGain(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAgcCurrentGain(::Ice::Int channel, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAgcCurrentGain(channel, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAgcCurrentGain(::Ice::Int channel, const ::QS1R::Callback_RadioCommander_getAgcCurrentGainPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAgcCurrentGain(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAgcCurrentGain(::Ice::Int channel, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getAgcCurrentGainPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAgcCurrentGain(channel, &__ctx, __del, __cookie);
    }

    ::Ice::Float end_getAgcCurrentGain(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Float getAgcCurrentGain(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getAgcCurrentGain(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setAnfSwitch(::Ice::Int channel, bool on)
    {
        setAnfSwitch(channel, on, 0);
    }
    void setAnfSwitch(::Ice::Int channel, bool on, const ::Ice::Context& __ctx)
    {
        setAnfSwitch(channel, on, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setAnfSwitch(::Ice::Int channel, bool on)
    {
        return begin_setAnfSwitch(channel, on, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setAnfSwitch(::Ice::Int channel, bool on, const ::Ice::Context& __ctx)
    {
        return begin_setAnfSwitch(channel, on, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setAnfSwitch(::Ice::Int channel, bool on, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAnfSwitch(channel, on, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setAnfSwitch(::Ice::Int channel, bool on, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAnfSwitch(channel, on, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setAnfSwitch(::Ice::Int channel, bool on, const ::QS1R::Callback_RadioCommander_setAnfSwitchPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAnfSwitch(channel, on, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setAnfSwitch(::Ice::Int channel, bool on, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setAnfSwitchPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAnfSwitch(channel, on, &__ctx, __del, __cookie);
    }

    void end_setAnfSwitch(const ::Ice::AsyncResultPtr&);
    
private:

    void setAnfSwitch(::Ice::Int, bool, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setAnfSwitch(::Ice::Int, bool, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    bool getAnfSwitch(::Ice::Int channel)
    {
        return getAnfSwitch(channel, 0);
    }
    bool getAnfSwitch(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return getAnfSwitch(channel, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getAnfSwitch(::Ice::Int channel)
    {
        return begin_getAnfSwitch(channel, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAnfSwitch(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return begin_getAnfSwitch(channel, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAnfSwitch(::Ice::Int channel, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAnfSwitch(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAnfSwitch(::Ice::Int channel, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAnfSwitch(channel, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAnfSwitch(::Ice::Int channel, const ::QS1R::Callback_RadioCommander_getAnfSwitchPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAnfSwitch(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAnfSwitch(::Ice::Int channel, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getAnfSwitchPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAnfSwitch(channel, &__ctx, __del, __cookie);
    }

    bool end_getAnfSwitch(const ::Ice::AsyncResultPtr&);
    
private:

    bool getAnfSwitch(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getAnfSwitch(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setAnfDelay(::Ice::Int channel, ::Ice::Int value)
    {
        setAnfDelay(channel, value, 0);
    }
    void setAnfDelay(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context& __ctx)
    {
        setAnfDelay(channel, value, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setAnfDelay(::Ice::Int channel, ::Ice::Int value)
    {
        return begin_setAnfDelay(channel, value, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setAnfDelay(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context& __ctx)
    {
        return begin_setAnfDelay(channel, value, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setAnfDelay(::Ice::Int channel, ::Ice::Int value, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAnfDelay(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setAnfDelay(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAnfDelay(channel, value, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setAnfDelay(::Ice::Int channel, ::Ice::Int value, const ::QS1R::Callback_RadioCommander_setAnfDelayPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAnfDelay(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setAnfDelay(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setAnfDelayPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAnfDelay(channel, value, &__ctx, __del, __cookie);
    }

    void end_setAnfDelay(const ::Ice::AsyncResultPtr&);
    
private:

    void setAnfDelay(::Ice::Int, ::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setAnfDelay(::Ice::Int, ::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int getAnfDelay(::Ice::Int channel)
    {
        return getAnfDelay(channel, 0);
    }
    ::Ice::Int getAnfDelay(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return getAnfDelay(channel, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getAnfDelay(::Ice::Int channel)
    {
        return begin_getAnfDelay(channel, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAnfDelay(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return begin_getAnfDelay(channel, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAnfDelay(::Ice::Int channel, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAnfDelay(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAnfDelay(::Ice::Int channel, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAnfDelay(channel, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAnfDelay(::Ice::Int channel, const ::QS1R::Callback_RadioCommander_getAnfDelayPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAnfDelay(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAnfDelay(::Ice::Int channel, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getAnfDelayPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAnfDelay(channel, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_getAnfDelay(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int getAnfDelay(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getAnfDelay(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setAnfTaps(::Ice::Int channel, ::Ice::Int value)
    {
        setAnfTaps(channel, value, 0);
    }
    void setAnfTaps(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context& __ctx)
    {
        setAnfTaps(channel, value, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setAnfTaps(::Ice::Int channel, ::Ice::Int value)
    {
        return begin_setAnfTaps(channel, value, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setAnfTaps(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context& __ctx)
    {
        return begin_setAnfTaps(channel, value, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setAnfTaps(::Ice::Int channel, ::Ice::Int value, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAnfTaps(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setAnfTaps(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAnfTaps(channel, value, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setAnfTaps(::Ice::Int channel, ::Ice::Int value, const ::QS1R::Callback_RadioCommander_setAnfTapsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAnfTaps(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setAnfTaps(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setAnfTapsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAnfTaps(channel, value, &__ctx, __del, __cookie);
    }

    void end_setAnfTaps(const ::Ice::AsyncResultPtr&);
    
private:

    void setAnfTaps(::Ice::Int, ::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setAnfTaps(::Ice::Int, ::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int getAnfTaps(::Ice::Int channel)
    {
        return getAnfTaps(channel, 0);
    }
    ::Ice::Int getAnfTaps(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return getAnfTaps(channel, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getAnfTaps(::Ice::Int channel)
    {
        return begin_getAnfTaps(channel, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAnfTaps(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return begin_getAnfTaps(channel, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAnfTaps(::Ice::Int channel, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAnfTaps(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAnfTaps(::Ice::Int channel, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAnfTaps(channel, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAnfTaps(::Ice::Int channel, const ::QS1R::Callback_RadioCommander_getAnfTapsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAnfTaps(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAnfTaps(::Ice::Int channel, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getAnfTapsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAnfTaps(channel, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_getAnfTaps(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int getAnfTaps(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getAnfTaps(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setAnfGain(::Ice::Int channel, ::Ice::Float value)
    {
        setAnfGain(channel, value, 0);
    }
    void setAnfGain(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx)
    {
        setAnfGain(channel, value, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setAnfGain(::Ice::Int channel, ::Ice::Float value)
    {
        return begin_setAnfGain(channel, value, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setAnfGain(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx)
    {
        return begin_setAnfGain(channel, value, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setAnfGain(::Ice::Int channel, ::Ice::Float value, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAnfGain(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setAnfGain(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAnfGain(channel, value, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setAnfGain(::Ice::Int channel, ::Ice::Float value, const ::QS1R::Callback_RadioCommander_setAnfGainPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAnfGain(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setAnfGain(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setAnfGainPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAnfGain(channel, value, &__ctx, __del, __cookie);
    }

    void end_setAnfGain(const ::Ice::AsyncResultPtr&);
    
private:

    void setAnfGain(::Ice::Int, ::Ice::Float, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setAnfGain(::Ice::Int, ::Ice::Float, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Float getAnfGain(::Ice::Int channel)
    {
        return getAnfGain(channel, 0);
    }
    ::Ice::Float getAnfGain(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return getAnfGain(channel, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getAnfGain(::Ice::Int channel)
    {
        return begin_getAnfGain(channel, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAnfGain(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return begin_getAnfGain(channel, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAnfGain(::Ice::Int channel, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAnfGain(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAnfGain(::Ice::Int channel, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAnfGain(channel, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAnfGain(::Ice::Int channel, const ::QS1R::Callback_RadioCommander_getAnfGainPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAnfGain(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAnfGain(::Ice::Int channel, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getAnfGainPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAnfGain(channel, &__ctx, __del, __cookie);
    }

    ::Ice::Float end_getAnfGain(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Float getAnfGain(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getAnfGain(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setAnfLeak(::Ice::Int channel, ::Ice::Float value)
    {
        setAnfLeak(channel, value, 0);
    }
    void setAnfLeak(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx)
    {
        setAnfLeak(channel, value, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setAnfLeak(::Ice::Int channel, ::Ice::Float value)
    {
        return begin_setAnfLeak(channel, value, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setAnfLeak(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx)
    {
        return begin_setAnfLeak(channel, value, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setAnfLeak(::Ice::Int channel, ::Ice::Float value, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAnfLeak(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setAnfLeak(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAnfLeak(channel, value, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setAnfLeak(::Ice::Int channel, ::Ice::Float value, const ::QS1R::Callback_RadioCommander_setAnfLeakPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAnfLeak(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setAnfLeak(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setAnfLeakPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAnfLeak(channel, value, &__ctx, __del, __cookie);
    }

    void end_setAnfLeak(const ::Ice::AsyncResultPtr&);
    
private:

    void setAnfLeak(::Ice::Int, ::Ice::Float, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setAnfLeak(::Ice::Int, ::Ice::Float, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Float getAnfLeak(::Ice::Int channel)
    {
        return getAnfLeak(channel, 0);
    }
    ::Ice::Float getAnfLeak(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return getAnfLeak(channel, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getAnfLeak(::Ice::Int channel)
    {
        return begin_getAnfLeak(channel, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAnfLeak(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return begin_getAnfLeak(channel, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAnfLeak(::Ice::Int channel, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAnfLeak(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAnfLeak(::Ice::Int channel, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAnfLeak(channel, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAnfLeak(::Ice::Int channel, const ::QS1R::Callback_RadioCommander_getAnfLeakPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAnfLeak(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAnfLeak(::Ice::Int channel, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getAnfLeakPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAnfLeak(channel, &__ctx, __del, __cookie);
    }

    ::Ice::Float end_getAnfLeak(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Float getAnfLeak(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getAnfLeak(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setBinaural(bool on)
    {
        setBinaural(on, 0);
    }
    void setBinaural(bool on, const ::Ice::Context& __ctx)
    {
        setBinaural(on, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setBinaural(bool on)
    {
        return begin_setBinaural(on, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setBinaural(bool on, const ::Ice::Context& __ctx)
    {
        return begin_setBinaural(on, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setBinaural(bool on, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setBinaural(on, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setBinaural(bool on, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setBinaural(on, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setBinaural(bool on, const ::QS1R::Callback_RadioCommander_setBinauralPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setBinaural(on, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setBinaural(bool on, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setBinauralPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setBinaural(on, &__ctx, __del, __cookie);
    }

    void end_setBinaural(const ::Ice::AsyncResultPtr&);
    
private:

    void setBinaural(bool, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setBinaural(bool, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    bool getBinaural()
    {
        return getBinaural(0);
    }
    bool getBinaural(const ::Ice::Context& __ctx)
    {
        return getBinaural(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getBinaural()
    {
        return begin_getBinaural(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getBinaural(const ::Ice::Context& __ctx)
    {
        return begin_getBinaural(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getBinaural(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getBinaural(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getBinaural(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getBinaural(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getBinaural(const ::QS1R::Callback_RadioCommander_getBinauralPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getBinaural(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getBinaural(const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getBinauralPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getBinaural(&__ctx, __del, __cookie);
    }

    bool end_getBinaural(const ::Ice::AsyncResultPtr&);
    
private:

    bool getBinaural(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getBinaural(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setBlockSize(::Ice::Int value)
    {
        setBlockSize(value, 0);
    }
    void setBlockSize(::Ice::Int value, const ::Ice::Context& __ctx)
    {
        setBlockSize(value, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setBlockSize(::Ice::Int value)
    {
        return begin_setBlockSize(value, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setBlockSize(::Ice::Int value, const ::Ice::Context& __ctx)
    {
        return begin_setBlockSize(value, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setBlockSize(::Ice::Int value, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setBlockSize(value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setBlockSize(::Ice::Int value, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setBlockSize(value, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setBlockSize(::Ice::Int value, const ::QS1R::Callback_RadioCommander_setBlockSizePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setBlockSize(value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setBlockSize(::Ice::Int value, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setBlockSizePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setBlockSize(value, &__ctx, __del, __cookie);
    }

    void end_setBlockSize(const ::Ice::AsyncResultPtr&);
    
private:

    void setBlockSize(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setBlockSize(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int getBlockSize()
    {
        return getBlockSize(0);
    }
    ::Ice::Int getBlockSize(const ::Ice::Context& __ctx)
    {
        return getBlockSize(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getBlockSize()
    {
        return begin_getBlockSize(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getBlockSize(const ::Ice::Context& __ctx)
    {
        return begin_getBlockSize(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getBlockSize(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getBlockSize(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getBlockSize(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getBlockSize(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getBlockSize(const ::QS1R::Callback_RadioCommander_getBlockSizePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getBlockSize(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getBlockSize(const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getBlockSizePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getBlockSize(&__ctx, __del, __cookie);
    }

    ::Ice::Int end_getBlockSize(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int getBlockSize(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getBlockSize(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setDemodMode(::Ice::Int channel, ::QS1R::DEMODMODE mode)
    {
        setDemodMode(channel, mode, 0);
    }
    void setDemodMode(::Ice::Int channel, ::QS1R::DEMODMODE mode, const ::Ice::Context& __ctx)
    {
        setDemodMode(channel, mode, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setDemodMode(::Ice::Int channel, ::QS1R::DEMODMODE mode)
    {
        return begin_setDemodMode(channel, mode, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setDemodMode(::Ice::Int channel, ::QS1R::DEMODMODE mode, const ::Ice::Context& __ctx)
    {
        return begin_setDemodMode(channel, mode, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setDemodMode(::Ice::Int channel, ::QS1R::DEMODMODE mode, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setDemodMode(channel, mode, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setDemodMode(::Ice::Int channel, ::QS1R::DEMODMODE mode, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setDemodMode(channel, mode, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setDemodMode(::Ice::Int channel, ::QS1R::DEMODMODE mode, const ::QS1R::Callback_RadioCommander_setDemodModePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setDemodMode(channel, mode, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setDemodMode(::Ice::Int channel, ::QS1R::DEMODMODE mode, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setDemodModePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setDemodMode(channel, mode, &__ctx, __del, __cookie);
    }

    void end_setDemodMode(const ::Ice::AsyncResultPtr&);
    
private:

    void setDemodMode(::Ice::Int, ::QS1R::DEMODMODE, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setDemodMode(::Ice::Int, ::QS1R::DEMODMODE, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::QS1R::DEMODMODE getDemodMode(::Ice::Int channel)
    {
        return getDemodMode(channel, 0);
    }
    ::QS1R::DEMODMODE getDemodMode(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return getDemodMode(channel, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getDemodMode(::Ice::Int channel)
    {
        return begin_getDemodMode(channel, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getDemodMode(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return begin_getDemodMode(channel, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getDemodMode(::Ice::Int channel, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDemodMode(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getDemodMode(::Ice::Int channel, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDemodMode(channel, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getDemodMode(::Ice::Int channel, const ::QS1R::Callback_RadioCommander_getDemodModePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDemodMode(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getDemodMode(::Ice::Int channel, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getDemodModePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDemodMode(channel, &__ctx, __del, __cookie);
    }

    ::QS1R::DEMODMODE end_getDemodMode(const ::Ice::AsyncResultPtr&);
    
private:

    ::QS1R::DEMODMODE getDemodMode(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getDemodMode(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setControlRegister(::Ice::Int value)
    {
        setControlRegister(value, 0);
    }
    void setControlRegister(::Ice::Int value, const ::Ice::Context& __ctx)
    {
        setControlRegister(value, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setControlRegister(::Ice::Int value)
    {
        return begin_setControlRegister(value, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setControlRegister(::Ice::Int value, const ::Ice::Context& __ctx)
    {
        return begin_setControlRegister(value, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setControlRegister(::Ice::Int value, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setControlRegister(value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setControlRegister(::Ice::Int value, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setControlRegister(value, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setControlRegister(::Ice::Int value, const ::QS1R::Callback_RadioCommander_setControlRegisterPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setControlRegister(value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setControlRegister(::Ice::Int value, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setControlRegisterPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setControlRegister(value, &__ctx, __del, __cookie);
    }

    void end_setControlRegister(const ::Ice::AsyncResultPtr&);
    
private:

    void setControlRegister(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setControlRegister(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int getControlRegister()
    {
        return getControlRegister(0);
    }
    ::Ice::Int getControlRegister(const ::Ice::Context& __ctx)
    {
        return getControlRegister(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getControlRegister()
    {
        return begin_getControlRegister(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getControlRegister(const ::Ice::Context& __ctx)
    {
        return begin_getControlRegister(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getControlRegister(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getControlRegister(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getControlRegister(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getControlRegister(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getControlRegister(const ::QS1R::Callback_RadioCommander_getControlRegisterPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getControlRegister(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getControlRegister(const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getControlRegisterPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getControlRegister(&__ctx, __del, __cookie);
    }

    ::Ice::Int end_getControlRegister(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int getControlRegister(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getControlRegister(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setDecimationRegister(::Ice::Int channel, ::Ice::Int value)
    {
        setDecimationRegister(channel, value, 0);
    }
    void setDecimationRegister(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context& __ctx)
    {
        setDecimationRegister(channel, value, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setDecimationRegister(::Ice::Int channel, ::Ice::Int value)
    {
        return begin_setDecimationRegister(channel, value, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setDecimationRegister(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context& __ctx)
    {
        return begin_setDecimationRegister(channel, value, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setDecimationRegister(::Ice::Int channel, ::Ice::Int value, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setDecimationRegister(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setDecimationRegister(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setDecimationRegister(channel, value, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setDecimationRegister(::Ice::Int channel, ::Ice::Int value, const ::QS1R::Callback_RadioCommander_setDecimationRegisterPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setDecimationRegister(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setDecimationRegister(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setDecimationRegisterPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setDecimationRegister(channel, value, &__ctx, __del, __cookie);
    }

    void end_setDecimationRegister(const ::Ice::AsyncResultPtr&);
    
private:

    void setDecimationRegister(::Ice::Int, ::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setDecimationRegister(::Ice::Int, ::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int getDecimationRegister(::Ice::Int channel)
    {
        return getDecimationRegister(channel, 0);
    }
    ::Ice::Int getDecimationRegister(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return getDecimationRegister(channel, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getDecimationRegister(::Ice::Int channel)
    {
        return begin_getDecimationRegister(channel, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getDecimationRegister(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return begin_getDecimationRegister(channel, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getDecimationRegister(::Ice::Int channel, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDecimationRegister(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getDecimationRegister(::Ice::Int channel, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDecimationRegister(channel, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getDecimationRegister(::Ice::Int channel, const ::QS1R::Callback_RadioCommander_getDecimationRegisterPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDecimationRegister(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getDecimationRegister(::Ice::Int channel, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getDecimationRegisterPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDecimationRegister(channel, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_getDecimationRegister(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int getDecimationRegister(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getDecimationRegister(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setScalingRegister(::Ice::Int channel, ::Ice::Int value)
    {
        setScalingRegister(channel, value, 0);
    }
    void setScalingRegister(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context& __ctx)
    {
        setScalingRegister(channel, value, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setScalingRegister(::Ice::Int channel, ::Ice::Int value)
    {
        return begin_setScalingRegister(channel, value, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setScalingRegister(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context& __ctx)
    {
        return begin_setScalingRegister(channel, value, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setScalingRegister(::Ice::Int channel, ::Ice::Int value, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setScalingRegister(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setScalingRegister(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setScalingRegister(channel, value, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setScalingRegister(::Ice::Int channel, ::Ice::Int value, const ::QS1R::Callback_RadioCommander_setScalingRegisterPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setScalingRegister(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setScalingRegister(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setScalingRegisterPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setScalingRegister(channel, value, &__ctx, __del, __cookie);
    }

    void end_setScalingRegister(const ::Ice::AsyncResultPtr&);
    
private:

    void setScalingRegister(::Ice::Int, ::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setScalingRegister(::Ice::Int, ::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int getScalingRegister(::Ice::Int channel)
    {
        return getScalingRegister(channel, 0);
    }
    ::Ice::Int getScalingRegister(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return getScalingRegister(channel, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getScalingRegister(::Ice::Int channel)
    {
        return begin_getScalingRegister(channel, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getScalingRegister(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return begin_getScalingRegister(channel, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getScalingRegister(::Ice::Int channel, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getScalingRegister(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getScalingRegister(::Ice::Int channel, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getScalingRegister(channel, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getScalingRegister(::Ice::Int channel, const ::QS1R::Callback_RadioCommander_getScalingRegisterPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getScalingRegister(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getScalingRegister(::Ice::Int channel, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getScalingRegisterPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getScalingRegister(channel, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_getScalingRegister(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int getScalingRegister(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getScalingRegister(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string getEepromEncFreqRegister()
    {
        return getEepromEncFreqRegister(0);
    }
    ::std::string getEepromEncFreqRegister(const ::Ice::Context& __ctx)
    {
        return getEepromEncFreqRegister(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getEepromEncFreqRegister()
    {
        return begin_getEepromEncFreqRegister(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getEepromEncFreqRegister(const ::Ice::Context& __ctx)
    {
        return begin_getEepromEncFreqRegister(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getEepromEncFreqRegister(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getEepromEncFreqRegister(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getEepromEncFreqRegister(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getEepromEncFreqRegister(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getEepromEncFreqRegister(const ::QS1R::Callback_RadioCommander_getEepromEncFreqRegisterPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getEepromEncFreqRegister(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getEepromEncFreqRegister(const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getEepromEncFreqRegisterPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getEepromEncFreqRegister(&__ctx, __del, __cookie);
    }

    ::std::string end_getEepromEncFreqRegister(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string getEepromEncFreqRegister(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getEepromEncFreqRegister(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setDither(bool on)
    {
        setDither(on, 0);
    }
    void setDither(bool on, const ::Ice::Context& __ctx)
    {
        setDither(on, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setDither(bool on)
    {
        return begin_setDither(on, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setDither(bool on, const ::Ice::Context& __ctx)
    {
        return begin_setDither(on, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setDither(bool on, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setDither(on, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setDither(bool on, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setDither(on, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setDither(bool on, const ::QS1R::Callback_RadioCommander_setDitherPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setDither(on, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setDither(bool on, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setDitherPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setDither(on, &__ctx, __del, __cookie);
    }

    void end_setDither(const ::Ice::AsyncResultPtr&);
    
private:

    void setDither(bool, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setDither(bool, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    bool getDither()
    {
        return getDither(0);
    }
    bool getDither(const ::Ice::Context& __ctx)
    {
        return getDither(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getDither()
    {
        return begin_getDither(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getDither(const ::Ice::Context& __ctx)
    {
        return begin_getDither(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getDither(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDither(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getDither(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDither(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getDither(const ::QS1R::Callback_RadioCommander_getDitherPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDither(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getDither(const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getDitherPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDither(&__ctx, __del, __cookie);
    }

    bool end_getDither(const ::Ice::AsyncResultPtr&);
    
private:

    bool getDither(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getDither(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setEncodeFreq(::Ice::Float value)
    {
        setEncodeFreq(value, 0);
    }
    void setEncodeFreq(::Ice::Float value, const ::Ice::Context& __ctx)
    {
        setEncodeFreq(value, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setEncodeFreq(::Ice::Float value)
    {
        return begin_setEncodeFreq(value, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setEncodeFreq(::Ice::Float value, const ::Ice::Context& __ctx)
    {
        return begin_setEncodeFreq(value, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setEncodeFreq(::Ice::Float value, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setEncodeFreq(value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setEncodeFreq(::Ice::Float value, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setEncodeFreq(value, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setEncodeFreq(::Ice::Float value, const ::QS1R::Callback_RadioCommander_setEncodeFreqPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setEncodeFreq(value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setEncodeFreq(::Ice::Float value, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setEncodeFreqPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setEncodeFreq(value, &__ctx, __del, __cookie);
    }

    void end_setEncodeFreq(const ::Ice::AsyncResultPtr&);
    
private:

    void setEncodeFreq(::Ice::Float, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setEncodeFreq(::Ice::Float, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Float getEncodeFreq()
    {
        return getEncodeFreq(0);
    }
    ::Ice::Float getEncodeFreq(const ::Ice::Context& __ctx)
    {
        return getEncodeFreq(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getEncodeFreq()
    {
        return begin_getEncodeFreq(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getEncodeFreq(const ::Ice::Context& __ctx)
    {
        return begin_getEncodeFreq(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getEncodeFreq(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getEncodeFreq(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getEncodeFreq(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getEncodeFreq(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getEncodeFreq(const ::QS1R::Callback_RadioCommander_getEncodeFreqPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getEncodeFreq(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getEncodeFreq(const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getEncodeFreqPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getEncodeFreq(&__ctx, __del, __cookie);
    }

    ::Ice::Float end_getEncodeFreq(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Float getEncodeFreq(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getEncodeFreq(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setMeterCalibrationOffset(::Ice::Float value)
    {
        setMeterCalibrationOffset(value, 0);
    }
    void setMeterCalibrationOffset(::Ice::Float value, const ::Ice::Context& __ctx)
    {
        setMeterCalibrationOffset(value, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setMeterCalibrationOffset(::Ice::Float value)
    {
        return begin_setMeterCalibrationOffset(value, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setMeterCalibrationOffset(::Ice::Float value, const ::Ice::Context& __ctx)
    {
        return begin_setMeterCalibrationOffset(value, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setMeterCalibrationOffset(::Ice::Float value, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setMeterCalibrationOffset(value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setMeterCalibrationOffset(::Ice::Float value, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setMeterCalibrationOffset(value, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setMeterCalibrationOffset(::Ice::Float value, const ::QS1R::Callback_RadioCommander_setMeterCalibrationOffsetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setMeterCalibrationOffset(value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setMeterCalibrationOffset(::Ice::Float value, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setMeterCalibrationOffsetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setMeterCalibrationOffset(value, &__ctx, __del, __cookie);
    }

    void end_setMeterCalibrationOffset(const ::Ice::AsyncResultPtr&);
    
private:

    void setMeterCalibrationOffset(::Ice::Float, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setMeterCalibrationOffset(::Ice::Float, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Float getMeterCalibrationOffset()
    {
        return getMeterCalibrationOffset(0);
    }
    ::Ice::Float getMeterCalibrationOffset(const ::Ice::Context& __ctx)
    {
        return getMeterCalibrationOffset(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getMeterCalibrationOffset()
    {
        return begin_getMeterCalibrationOffset(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getMeterCalibrationOffset(const ::Ice::Context& __ctx)
    {
        return begin_getMeterCalibrationOffset(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getMeterCalibrationOffset(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getMeterCalibrationOffset(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getMeterCalibrationOffset(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getMeterCalibrationOffset(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getMeterCalibrationOffset(const ::QS1R::Callback_RadioCommander_getMeterCalibrationOffsetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getMeterCalibrationOffset(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getMeterCalibrationOffset(const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getMeterCalibrationOffsetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getMeterCalibrationOffset(&__ctx, __del, __cookie);
    }

    ::Ice::Float end_getMeterCalibrationOffset(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Float getMeterCalibrationOffset(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getMeterCalibrationOffset(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setSpectrumCalibrationOffset(::Ice::Float value)
    {
        setSpectrumCalibrationOffset(value, 0);
    }
    void setSpectrumCalibrationOffset(::Ice::Float value, const ::Ice::Context& __ctx)
    {
        setSpectrumCalibrationOffset(value, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setSpectrumCalibrationOffset(::Ice::Float value)
    {
        return begin_setSpectrumCalibrationOffset(value, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setSpectrumCalibrationOffset(::Ice::Float value, const ::Ice::Context& __ctx)
    {
        return begin_setSpectrumCalibrationOffset(value, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setSpectrumCalibrationOffset(::Ice::Float value, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setSpectrumCalibrationOffset(value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setSpectrumCalibrationOffset(::Ice::Float value, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setSpectrumCalibrationOffset(value, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setSpectrumCalibrationOffset(::Ice::Float value, const ::QS1R::Callback_RadioCommander_setSpectrumCalibrationOffsetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setSpectrumCalibrationOffset(value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setSpectrumCalibrationOffset(::Ice::Float value, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setSpectrumCalibrationOffsetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setSpectrumCalibrationOffset(value, &__ctx, __del, __cookie);
    }

    void end_setSpectrumCalibrationOffset(const ::Ice::AsyncResultPtr&);
    
private:

    void setSpectrumCalibrationOffset(::Ice::Float, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setSpectrumCalibrationOffset(::Ice::Float, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Float getSpectrumCalibrationOffset()
    {
        return getSpectrumCalibrationOffset(0);
    }
    ::Ice::Float getSpectrumCalibrationOffset(const ::Ice::Context& __ctx)
    {
        return getSpectrumCalibrationOffset(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getSpectrumCalibrationOffset()
    {
        return begin_getSpectrumCalibrationOffset(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getSpectrumCalibrationOffset(const ::Ice::Context& __ctx)
    {
        return begin_getSpectrumCalibrationOffset(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getSpectrumCalibrationOffset(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSpectrumCalibrationOffset(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getSpectrumCalibrationOffset(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSpectrumCalibrationOffset(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getSpectrumCalibrationOffset(const ::QS1R::Callback_RadioCommander_getSpectrumCalibrationOffsetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSpectrumCalibrationOffset(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getSpectrumCalibrationOffset(const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getSpectrumCalibrationOffsetPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSpectrumCalibrationOffset(&__ctx, __del, __cookie);
    }

    ::Ice::Float end_getSpectrumCalibrationOffset(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Float getSpectrumCalibrationOffset(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getSpectrumCalibrationOffset(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setNrSwitch(::Ice::Int channel, bool on)
    {
        setNrSwitch(channel, on, 0);
    }
    void setNrSwitch(::Ice::Int channel, bool on, const ::Ice::Context& __ctx)
    {
        setNrSwitch(channel, on, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setNrSwitch(::Ice::Int channel, bool on)
    {
        return begin_setNrSwitch(channel, on, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setNrSwitch(::Ice::Int channel, bool on, const ::Ice::Context& __ctx)
    {
        return begin_setNrSwitch(channel, on, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setNrSwitch(::Ice::Int channel, bool on, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setNrSwitch(channel, on, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setNrSwitch(::Ice::Int channel, bool on, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setNrSwitch(channel, on, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setNrSwitch(::Ice::Int channel, bool on, const ::QS1R::Callback_RadioCommander_setNrSwitchPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setNrSwitch(channel, on, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setNrSwitch(::Ice::Int channel, bool on, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setNrSwitchPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setNrSwitch(channel, on, &__ctx, __del, __cookie);
    }

    void end_setNrSwitch(const ::Ice::AsyncResultPtr&);
    
private:

    void setNrSwitch(::Ice::Int, bool, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setNrSwitch(::Ice::Int, bool, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    bool getNrSwitch(::Ice::Int channel)
    {
        return getNrSwitch(channel, 0);
    }
    bool getNrSwitch(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return getNrSwitch(channel, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getNrSwitch(::Ice::Int channel)
    {
        return begin_getNrSwitch(channel, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getNrSwitch(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return begin_getNrSwitch(channel, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getNrSwitch(::Ice::Int channel, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getNrSwitch(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getNrSwitch(::Ice::Int channel, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getNrSwitch(channel, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getNrSwitch(::Ice::Int channel, const ::QS1R::Callback_RadioCommander_getNrSwitchPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getNrSwitch(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getNrSwitch(::Ice::Int channel, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getNrSwitchPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getNrSwitch(channel, &__ctx, __del, __cookie);
    }

    bool end_getNrSwitch(const ::Ice::AsyncResultPtr&);
    
private:

    bool getNrSwitch(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getNrSwitch(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setNrTaps(::Ice::Int channel, ::Ice::Int value)
    {
        setNrTaps(channel, value, 0);
    }
    void setNrTaps(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context& __ctx)
    {
        setNrTaps(channel, value, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setNrTaps(::Ice::Int channel, ::Ice::Int value)
    {
        return begin_setNrTaps(channel, value, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setNrTaps(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context& __ctx)
    {
        return begin_setNrTaps(channel, value, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setNrTaps(::Ice::Int channel, ::Ice::Int value, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setNrTaps(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setNrTaps(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setNrTaps(channel, value, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setNrTaps(::Ice::Int channel, ::Ice::Int value, const ::QS1R::Callback_RadioCommander_setNrTapsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setNrTaps(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setNrTaps(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setNrTapsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setNrTaps(channel, value, &__ctx, __del, __cookie);
    }

    void end_setNrTaps(const ::Ice::AsyncResultPtr&);
    
private:

    void setNrTaps(::Ice::Int, ::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setNrTaps(::Ice::Int, ::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int getNrTaps(::Ice::Int channel)
    {
        return getNrTaps(channel, 0);
    }
    ::Ice::Int getNrTaps(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return getNrTaps(channel, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getNrTaps(::Ice::Int channel)
    {
        return begin_getNrTaps(channel, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getNrTaps(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return begin_getNrTaps(channel, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getNrTaps(::Ice::Int channel, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getNrTaps(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getNrTaps(::Ice::Int channel, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getNrTaps(channel, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getNrTaps(::Ice::Int channel, const ::QS1R::Callback_RadioCommander_getNrTapsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getNrTaps(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getNrTaps(::Ice::Int channel, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getNrTapsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getNrTaps(channel, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_getNrTaps(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int getNrTaps(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getNrTaps(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setNrDelay(::Ice::Int channel, ::Ice::Int value)
    {
        setNrDelay(channel, value, 0);
    }
    void setNrDelay(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context& __ctx)
    {
        setNrDelay(channel, value, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setNrDelay(::Ice::Int channel, ::Ice::Int value)
    {
        return begin_setNrDelay(channel, value, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setNrDelay(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context& __ctx)
    {
        return begin_setNrDelay(channel, value, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setNrDelay(::Ice::Int channel, ::Ice::Int value, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setNrDelay(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setNrDelay(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setNrDelay(channel, value, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setNrDelay(::Ice::Int channel, ::Ice::Int value, const ::QS1R::Callback_RadioCommander_setNrDelayPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setNrDelay(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setNrDelay(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setNrDelayPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setNrDelay(channel, value, &__ctx, __del, __cookie);
    }

    void end_setNrDelay(const ::Ice::AsyncResultPtr&);
    
private:

    void setNrDelay(::Ice::Int, ::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setNrDelay(::Ice::Int, ::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int getNrDelay(::Ice::Int channel)
    {
        return getNrDelay(channel, 0);
    }
    ::Ice::Int getNrDelay(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return getNrDelay(channel, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getNrDelay(::Ice::Int channel)
    {
        return begin_getNrDelay(channel, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getNrDelay(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return begin_getNrDelay(channel, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getNrDelay(::Ice::Int channel, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getNrDelay(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getNrDelay(::Ice::Int channel, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getNrDelay(channel, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getNrDelay(::Ice::Int channel, const ::QS1R::Callback_RadioCommander_getNrDelayPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getNrDelay(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getNrDelay(::Ice::Int channel, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getNrDelayPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getNrDelay(channel, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_getNrDelay(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int getNrDelay(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getNrDelay(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setNrGain(::Ice::Int channel, ::Ice::Float value)
    {
        setNrGain(channel, value, 0);
    }
    void setNrGain(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx)
    {
        setNrGain(channel, value, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setNrGain(::Ice::Int channel, ::Ice::Float value)
    {
        return begin_setNrGain(channel, value, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setNrGain(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx)
    {
        return begin_setNrGain(channel, value, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setNrGain(::Ice::Int channel, ::Ice::Float value, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setNrGain(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setNrGain(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setNrGain(channel, value, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setNrGain(::Ice::Int channel, ::Ice::Float value, const ::QS1R::Callback_RadioCommander_setNrGainPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setNrGain(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setNrGain(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setNrGainPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setNrGain(channel, value, &__ctx, __del, __cookie);
    }

    void end_setNrGain(const ::Ice::AsyncResultPtr&);
    
private:

    void setNrGain(::Ice::Int, ::Ice::Float, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setNrGain(::Ice::Int, ::Ice::Float, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Float getNrGain(::Ice::Int channel)
    {
        return getNrGain(channel, 0);
    }
    ::Ice::Float getNrGain(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return getNrGain(channel, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getNrGain(::Ice::Int channel)
    {
        return begin_getNrGain(channel, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getNrGain(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return begin_getNrGain(channel, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getNrGain(::Ice::Int channel, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getNrGain(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getNrGain(::Ice::Int channel, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getNrGain(channel, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getNrGain(::Ice::Int channel, const ::QS1R::Callback_RadioCommander_getNrGainPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getNrGain(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getNrGain(::Ice::Int channel, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getNrGainPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getNrGain(channel, &__ctx, __del, __cookie);
    }

    ::Ice::Float end_getNrGain(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Float getNrGain(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getNrGain(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setNrLeak(::Ice::Int channel, ::Ice::Float value)
    {
        setNrLeak(channel, value, 0);
    }
    void setNrLeak(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx)
    {
        setNrLeak(channel, value, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setNrLeak(::Ice::Int channel, ::Ice::Float value)
    {
        return begin_setNrLeak(channel, value, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setNrLeak(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx)
    {
        return begin_setNrLeak(channel, value, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setNrLeak(::Ice::Int channel, ::Ice::Float value, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setNrLeak(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setNrLeak(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setNrLeak(channel, value, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setNrLeak(::Ice::Int channel, ::Ice::Float value, const ::QS1R::Callback_RadioCommander_setNrLeakPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setNrLeak(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setNrLeak(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setNrLeakPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setNrLeak(channel, value, &__ctx, __del, __cookie);
    }

    void end_setNrLeak(const ::Ice::AsyncResultPtr&);
    
private:

    void setNrLeak(::Ice::Int, ::Ice::Float, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setNrLeak(::Ice::Int, ::Ice::Float, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Float getNrLeak(::Ice::Int channel)
    {
        return getNrLeak(channel, 0);
    }
    ::Ice::Float getNrLeak(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return getNrLeak(channel, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getNrLeak(::Ice::Int channel)
    {
        return begin_getNrLeak(channel, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getNrLeak(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return begin_getNrLeak(channel, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getNrLeak(::Ice::Int channel, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getNrLeak(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getNrLeak(::Ice::Int channel, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getNrLeak(channel, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getNrLeak(::Ice::Int channel, const ::QS1R::Callback_RadioCommander_getNrLeakPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getNrLeak(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getNrLeak(::Ice::Int channel, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getNrLeakPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getNrLeak(channel, &__ctx, __del, __cookie);
    }

    ::Ice::Float end_getNrLeak(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Float getNrLeak(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getNrLeak(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setExit(bool on)
    {
        setExit(on, 0);
    }
    void setExit(bool on, const ::Ice::Context& __ctx)
    {
        setExit(on, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setExit(bool on)
    {
        return begin_setExit(on, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setExit(bool on, const ::Ice::Context& __ctx)
    {
        return begin_setExit(on, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setExit(bool on, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setExit(on, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setExit(bool on, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setExit(on, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setExit(bool on, const ::QS1R::Callback_RadioCommander_setExitPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setExit(on, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setExit(bool on, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setExitPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setExit(on, &__ctx, __del, __cookie);
    }

    void end_setExit(const ::Ice::AsyncResultPtr&);
    
private:

    void setExit(bool, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setExit(bool, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setFrequency(::Ice::Int channel, ::Ice::Float value)
    {
        setFrequency(channel, value, 0);
    }
    void setFrequency(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx)
    {
        setFrequency(channel, value, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setFrequency(::Ice::Int channel, ::Ice::Float value)
    {
        return begin_setFrequency(channel, value, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setFrequency(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx)
    {
        return begin_setFrequency(channel, value, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setFrequency(::Ice::Int channel, ::Ice::Float value, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFrequency(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setFrequency(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFrequency(channel, value, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setFrequency(::Ice::Int channel, ::Ice::Float value, const ::QS1R::Callback_RadioCommander_setFrequencyPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFrequency(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setFrequency(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setFrequencyPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFrequency(channel, value, &__ctx, __del, __cookie);
    }

    void end_setFrequency(const ::Ice::AsyncResultPtr&);
    
private:

    void setFrequency(::Ice::Int, ::Ice::Float, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setFrequency(::Ice::Int, ::Ice::Float, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Float getFrequency(::Ice::Int channel)
    {
        return getFrequency(channel, 0);
    }
    ::Ice::Float getFrequency(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return getFrequency(channel, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getFrequency(::Ice::Int channel)
    {
        return begin_getFrequency(channel, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getFrequency(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return begin_getFrequency(channel, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getFrequency(::Ice::Int channel, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFrequency(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFrequency(::Ice::Int channel, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFrequency(channel, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFrequency(::Ice::Int channel, const ::QS1R::Callback_RadioCommander_getFrequencyPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFrequency(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFrequency(::Ice::Int channel, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getFrequencyPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFrequency(channel, &__ctx, __del, __cookie);
    }

    ::Ice::Float end_getFrequency(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Float getFrequency(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getFrequency(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setFilterLo(::Ice::Int channel, ::Ice::Float value)
    {
        setFilterLo(channel, value, 0);
    }
    void setFilterLo(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx)
    {
        setFilterLo(channel, value, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setFilterLo(::Ice::Int channel, ::Ice::Float value)
    {
        return begin_setFilterLo(channel, value, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setFilterLo(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx)
    {
        return begin_setFilterLo(channel, value, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setFilterLo(::Ice::Int channel, ::Ice::Float value, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFilterLo(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setFilterLo(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFilterLo(channel, value, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setFilterLo(::Ice::Int channel, ::Ice::Float value, const ::QS1R::Callback_RadioCommander_setFilterLoPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFilterLo(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setFilterLo(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setFilterLoPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFilterLo(channel, value, &__ctx, __del, __cookie);
    }

    void end_setFilterLo(const ::Ice::AsyncResultPtr&);
    
private:

    void setFilterLo(::Ice::Int, ::Ice::Float, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setFilterLo(::Ice::Int, ::Ice::Float, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Float getFilterLo(::Ice::Int channel)
    {
        return getFilterLo(channel, 0);
    }
    ::Ice::Float getFilterLo(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return getFilterLo(channel, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getFilterLo(::Ice::Int channel)
    {
        return begin_getFilterLo(channel, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getFilterLo(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return begin_getFilterLo(channel, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getFilterLo(::Ice::Int channel, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFilterLo(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFilterLo(::Ice::Int channel, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFilterLo(channel, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFilterLo(::Ice::Int channel, const ::QS1R::Callback_RadioCommander_getFilterLoPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFilterLo(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFilterLo(::Ice::Int channel, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getFilterLoPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFilterLo(channel, &__ctx, __del, __cookie);
    }

    ::Ice::Float end_getFilterLo(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Float getFilterLo(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getFilterLo(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setFilterHi(::Ice::Int channel, ::Ice::Float value)
    {
        setFilterHi(channel, value, 0);
    }
    void setFilterHi(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx)
    {
        setFilterHi(channel, value, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setFilterHi(::Ice::Int channel, ::Ice::Float value)
    {
        return begin_setFilterHi(channel, value, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setFilterHi(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx)
    {
        return begin_setFilterHi(channel, value, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setFilterHi(::Ice::Int channel, ::Ice::Float value, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFilterHi(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setFilterHi(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFilterHi(channel, value, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setFilterHi(::Ice::Int channel, ::Ice::Float value, const ::QS1R::Callback_RadioCommander_setFilterHiPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFilterHi(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setFilterHi(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setFilterHiPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFilterHi(channel, value, &__ctx, __del, __cookie);
    }

    void end_setFilterHi(const ::Ice::AsyncResultPtr&);
    
private:

    void setFilterHi(::Ice::Int, ::Ice::Float, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setFilterHi(::Ice::Int, ::Ice::Float, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Float getFilterHi(::Ice::Int channel)
    {
        return getFilterHi(channel, 0);
    }
    ::Ice::Float getFilterHi(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return getFilterHi(channel, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getFilterHi(::Ice::Int channel)
    {
        return begin_getFilterHi(channel, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getFilterHi(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return begin_getFilterHi(channel, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getFilterHi(::Ice::Int channel, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFilterHi(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFilterHi(::Ice::Int channel, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFilterHi(channel, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFilterHi(::Ice::Int channel, const ::QS1R::Callback_RadioCommander_getFilterHiPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFilterHi(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFilterHi(::Ice::Int channel, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getFilterHiPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFilterHi(channel, &__ctx, __del, __cookie);
    }

    ::Ice::Float end_getFilterHi(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Float getFilterHi(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getFilterHi(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setFilter(::Ice::Int channel, ::Ice::Float loval, ::Ice::Float hival)
    {
        setFilter(channel, loval, hival, 0);
    }
    void setFilter(::Ice::Int channel, ::Ice::Float loval, ::Ice::Float hival, const ::Ice::Context& __ctx)
    {
        setFilter(channel, loval, hival, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setFilter(::Ice::Int channel, ::Ice::Float loval, ::Ice::Float hival)
    {
        return begin_setFilter(channel, loval, hival, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setFilter(::Ice::Int channel, ::Ice::Float loval, ::Ice::Float hival, const ::Ice::Context& __ctx)
    {
        return begin_setFilter(channel, loval, hival, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setFilter(::Ice::Int channel, ::Ice::Float loval, ::Ice::Float hival, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFilter(channel, loval, hival, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setFilter(::Ice::Int channel, ::Ice::Float loval, ::Ice::Float hival, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFilter(channel, loval, hival, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setFilter(::Ice::Int channel, ::Ice::Float loval, ::Ice::Float hival, const ::QS1R::Callback_RadioCommander_setFilterPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFilter(channel, loval, hival, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setFilter(::Ice::Int channel, ::Ice::Float loval, ::Ice::Float hival, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setFilterPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setFilter(channel, loval, hival, &__ctx, __del, __cookie);
    }

    void end_setFilter(const ::Ice::AsyncResultPtr&);
    
private:

    void setFilter(::Ice::Int, ::Ice::Float, ::Ice::Float, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setFilter(::Ice::Int, ::Ice::Float, ::Ice::Float, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setMute(::Ice::Int channel, bool on)
    {
        setMute(channel, on, 0);
    }
    void setMute(::Ice::Int channel, bool on, const ::Ice::Context& __ctx)
    {
        setMute(channel, on, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setMute(::Ice::Int channel, bool on)
    {
        return begin_setMute(channel, on, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setMute(::Ice::Int channel, bool on, const ::Ice::Context& __ctx)
    {
        return begin_setMute(channel, on, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setMute(::Ice::Int channel, bool on, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setMute(channel, on, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setMute(::Ice::Int channel, bool on, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setMute(channel, on, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setMute(::Ice::Int channel, bool on, const ::QS1R::Callback_RadioCommander_setMutePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setMute(channel, on, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setMute(::Ice::Int channel, bool on, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setMutePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setMute(channel, on, &__ctx, __del, __cookie);
    }

    void end_setMute(const ::Ice::AsyncResultPtr&);
    
private:

    void setMute(::Ice::Int, bool, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setMute(::Ice::Int, bool, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    bool getMute(::Ice::Int channel)
    {
        return getMute(channel, 0);
    }
    bool getMute(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return getMute(channel, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getMute(::Ice::Int channel)
    {
        return begin_getMute(channel, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getMute(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return begin_getMute(channel, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getMute(::Ice::Int channel, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getMute(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getMute(::Ice::Int channel, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getMute(channel, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getMute(::Ice::Int channel, const ::QS1R::Callback_RadioCommander_getMutePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getMute(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getMute(::Ice::Int channel, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getMutePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getMute(channel, &__ctx, __del, __cookie);
    }

    bool end_getMute(const ::Ice::AsyncResultPtr&);
    
private:

    bool getMute(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getMute(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setNb1Switch(::Ice::Int channel, bool on)
    {
        setNb1Switch(channel, on, 0);
    }
    void setNb1Switch(::Ice::Int channel, bool on, const ::Ice::Context& __ctx)
    {
        setNb1Switch(channel, on, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setNb1Switch(::Ice::Int channel, bool on)
    {
        return begin_setNb1Switch(channel, on, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setNb1Switch(::Ice::Int channel, bool on, const ::Ice::Context& __ctx)
    {
        return begin_setNb1Switch(channel, on, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setNb1Switch(::Ice::Int channel, bool on, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setNb1Switch(channel, on, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setNb1Switch(::Ice::Int channel, bool on, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setNb1Switch(channel, on, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setNb1Switch(::Ice::Int channel, bool on, const ::QS1R::Callback_RadioCommander_setNb1SwitchPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setNb1Switch(channel, on, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setNb1Switch(::Ice::Int channel, bool on, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setNb1SwitchPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setNb1Switch(channel, on, &__ctx, __del, __cookie);
    }

    void end_setNb1Switch(const ::Ice::AsyncResultPtr&);
    
private:

    void setNb1Switch(::Ice::Int, bool, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setNb1Switch(::Ice::Int, bool, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setNb1Thresh(::Ice::Int channel, ::Ice::Int value)
    {
        setNb1Thresh(channel, value, 0);
    }
    void setNb1Thresh(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context& __ctx)
    {
        setNb1Thresh(channel, value, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setNb1Thresh(::Ice::Int channel, ::Ice::Int value)
    {
        return begin_setNb1Thresh(channel, value, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setNb1Thresh(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context& __ctx)
    {
        return begin_setNb1Thresh(channel, value, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setNb1Thresh(::Ice::Int channel, ::Ice::Int value, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setNb1Thresh(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setNb1Thresh(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setNb1Thresh(channel, value, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setNb1Thresh(::Ice::Int channel, ::Ice::Int value, const ::QS1R::Callback_RadioCommander_setNb1ThreshPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setNb1Thresh(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setNb1Thresh(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setNb1ThreshPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setNb1Thresh(channel, value, &__ctx, __del, __cookie);
    }

    void end_setNb1Thresh(const ::Ice::AsyncResultPtr&);
    
private:

    void setNb1Thresh(::Ice::Int, ::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setNb1Thresh(::Ice::Int, ::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    bool getNb1Switch(::Ice::Int channel)
    {
        return getNb1Switch(channel, 0);
    }
    bool getNb1Switch(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return getNb1Switch(channel, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getNb1Switch(::Ice::Int channel)
    {
        return begin_getNb1Switch(channel, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getNb1Switch(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return begin_getNb1Switch(channel, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getNb1Switch(::Ice::Int channel, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getNb1Switch(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getNb1Switch(::Ice::Int channel, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getNb1Switch(channel, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getNb1Switch(::Ice::Int channel, const ::QS1R::Callback_RadioCommander_getNb1SwitchPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getNb1Switch(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getNb1Switch(::Ice::Int channel, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getNb1SwitchPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getNb1Switch(channel, &__ctx, __del, __cookie);
    }

    bool end_getNb1Switch(const ::Ice::AsyncResultPtr&);
    
private:

    bool getNb1Switch(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getNb1Switch(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int getNb1Thresh(::Ice::Int channel)
    {
        return getNb1Thresh(channel, 0);
    }
    ::Ice::Int getNb1Thresh(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return getNb1Thresh(channel, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getNb1Thresh(::Ice::Int channel)
    {
        return begin_getNb1Thresh(channel, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getNb1Thresh(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return begin_getNb1Thresh(channel, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getNb1Thresh(::Ice::Int channel, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getNb1Thresh(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getNb1Thresh(::Ice::Int channel, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getNb1Thresh(channel, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getNb1Thresh(::Ice::Int channel, const ::QS1R::Callback_RadioCommander_getNb1ThreshPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getNb1Thresh(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getNb1Thresh(::Ice::Int channel, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getNb1ThreshPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getNb1Thresh(channel, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_getNb1Thresh(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int getNb1Thresh(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getNb1Thresh(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setNb2Switch(::Ice::Int channel, bool on)
    {
        setNb2Switch(channel, on, 0);
    }
    void setNb2Switch(::Ice::Int channel, bool on, const ::Ice::Context& __ctx)
    {
        setNb2Switch(channel, on, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setNb2Switch(::Ice::Int channel, bool on)
    {
        return begin_setNb2Switch(channel, on, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setNb2Switch(::Ice::Int channel, bool on, const ::Ice::Context& __ctx)
    {
        return begin_setNb2Switch(channel, on, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setNb2Switch(::Ice::Int channel, bool on, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setNb2Switch(channel, on, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setNb2Switch(::Ice::Int channel, bool on, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setNb2Switch(channel, on, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setNb2Switch(::Ice::Int channel, bool on, const ::QS1R::Callback_RadioCommander_setNb2SwitchPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setNb2Switch(channel, on, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setNb2Switch(::Ice::Int channel, bool on, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setNb2SwitchPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setNb2Switch(channel, on, &__ctx, __del, __cookie);
    }

    void end_setNb2Switch(const ::Ice::AsyncResultPtr&);
    
private:

    void setNb2Switch(::Ice::Int, bool, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setNb2Switch(::Ice::Int, bool, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setNb2Thresh(::Ice::Int channel, ::Ice::Int value)
    {
        setNb2Thresh(channel, value, 0);
    }
    void setNb2Thresh(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context& __ctx)
    {
        setNb2Thresh(channel, value, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setNb2Thresh(::Ice::Int channel, ::Ice::Int value)
    {
        return begin_setNb2Thresh(channel, value, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setNb2Thresh(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context& __ctx)
    {
        return begin_setNb2Thresh(channel, value, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setNb2Thresh(::Ice::Int channel, ::Ice::Int value, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setNb2Thresh(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setNb2Thresh(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setNb2Thresh(channel, value, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setNb2Thresh(::Ice::Int channel, ::Ice::Int value, const ::QS1R::Callback_RadioCommander_setNb2ThreshPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setNb2Thresh(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setNb2Thresh(::Ice::Int channel, ::Ice::Int value, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setNb2ThreshPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setNb2Thresh(channel, value, &__ctx, __del, __cookie);
    }

    void end_setNb2Thresh(const ::Ice::AsyncResultPtr&);
    
private:

    void setNb2Thresh(::Ice::Int, ::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setNb2Thresh(::Ice::Int, ::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    bool getNb2Switch(::Ice::Int channel)
    {
        return getNb2Switch(channel, 0);
    }
    bool getNb2Switch(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return getNb2Switch(channel, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getNb2Switch(::Ice::Int channel)
    {
        return begin_getNb2Switch(channel, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getNb2Switch(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return begin_getNb2Switch(channel, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getNb2Switch(::Ice::Int channel, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getNb2Switch(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getNb2Switch(::Ice::Int channel, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getNb2Switch(channel, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getNb2Switch(::Ice::Int channel, const ::QS1R::Callback_RadioCommander_getNb2SwitchPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getNb2Switch(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getNb2Switch(::Ice::Int channel, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getNb2SwitchPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getNb2Switch(channel, &__ctx, __del, __cookie);
    }

    bool end_getNb2Switch(const ::Ice::AsyncResultPtr&);
    
private:

    bool getNb2Switch(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getNb2Switch(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int getNb2Thresh(::Ice::Int channel)
    {
        return getNb2Thresh(channel, 0);
    }
    ::Ice::Int getNb2Thresh(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return getNb2Thresh(channel, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getNb2Thresh(::Ice::Int channel)
    {
        return begin_getNb2Thresh(channel, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getNb2Thresh(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return begin_getNb2Thresh(channel, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getNb2Thresh(::Ice::Int channel, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getNb2Thresh(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getNb2Thresh(::Ice::Int channel, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getNb2Thresh(channel, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getNb2Thresh(::Ice::Int channel, const ::QS1R::Callback_RadioCommander_getNb2ThreshPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getNb2Thresh(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getNb2Thresh(::Ice::Int channel, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getNb2ThreshPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getNb2Thresh(channel, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_getNb2Thresh(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int getNb2Thresh(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getNb2Thresh(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setPga(bool on)
    {
        setPga(on, 0);
    }
    void setPga(bool on, const ::Ice::Context& __ctx)
    {
        setPga(on, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setPga(bool on)
    {
        return begin_setPga(on, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setPga(bool on, const ::Ice::Context& __ctx)
    {
        return begin_setPga(on, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setPga(bool on, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setPga(on, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setPga(bool on, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setPga(on, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setPga(bool on, const ::QS1R::Callback_RadioCommander_setPgaPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setPga(on, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setPga(bool on, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setPgaPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setPga(on, &__ctx, __del, __cookie);
    }

    void end_setPga(const ::Ice::AsyncResultPtr&);
    
private:

    void setPga(bool, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setPga(bool, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    bool getPga()
    {
        return getPga(0);
    }
    bool getPga(const ::Ice::Context& __ctx)
    {
        return getPga(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getPga()
    {
        return begin_getPga(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPga(const ::Ice::Context& __ctx)
    {
        return begin_getPga(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPga(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPga(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPga(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPga(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPga(const ::QS1R::Callback_RadioCommander_getPgaPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPga(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPga(const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getPgaPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPga(&__ctx, __del, __cookie);
    }

    bool end_getPga(const ::Ice::AsyncResultPtr&);
    
private:

    bool getPga(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getPga(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setInbandPsSwitch(::Ice::Int channel, bool on)
    {
        setInbandPsSwitch(channel, on, 0);
    }
    void setInbandPsSwitch(::Ice::Int channel, bool on, const ::Ice::Context& __ctx)
    {
        setInbandPsSwitch(channel, on, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setInbandPsSwitch(::Ice::Int channel, bool on)
    {
        return begin_setInbandPsSwitch(channel, on, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setInbandPsSwitch(::Ice::Int channel, bool on, const ::Ice::Context& __ctx)
    {
        return begin_setInbandPsSwitch(channel, on, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setInbandPsSwitch(::Ice::Int channel, bool on, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setInbandPsSwitch(channel, on, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setInbandPsSwitch(::Ice::Int channel, bool on, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setInbandPsSwitch(channel, on, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setInbandPsSwitch(::Ice::Int channel, bool on, const ::QS1R::Callback_RadioCommander_setInbandPsSwitchPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setInbandPsSwitch(channel, on, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setInbandPsSwitch(::Ice::Int channel, bool on, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setInbandPsSwitchPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setInbandPsSwitch(channel, on, &__ctx, __del, __cookie);
    }

    void end_setInbandPsSwitch(const ::Ice::AsyncResultPtr&);
    
private:

    void setInbandPsSwitch(::Ice::Int, bool, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setInbandPsSwitch(::Ice::Int, bool, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    bool getInbandPsSwitch(::Ice::Int channel)
    {
        return getInbandPsSwitch(channel, 0);
    }
    bool getInbandPsSwitch(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return getInbandPsSwitch(channel, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getInbandPsSwitch(::Ice::Int channel)
    {
        return begin_getInbandPsSwitch(channel, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getInbandPsSwitch(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return begin_getInbandPsSwitch(channel, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getInbandPsSwitch(::Ice::Int channel, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getInbandPsSwitch(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getInbandPsSwitch(::Ice::Int channel, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getInbandPsSwitch(channel, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getInbandPsSwitch(::Ice::Int channel, const ::QS1R::Callback_RadioCommander_getInbandPsSwitchPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getInbandPsSwitch(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getInbandPsSwitch(::Ice::Int channel, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getInbandPsSwitchPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getInbandPsSwitch(channel, &__ctx, __del, __cookie);
    }

    bool end_getInbandPsSwitch(const ::Ice::AsyncResultPtr&);
    
private:

    bool getInbandPsSwitch(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getInbandPsSwitch(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int getInbandPsSize(::Ice::Int channel)
    {
        return getInbandPsSize(channel, 0);
    }
    ::Ice::Int getInbandPsSize(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return getInbandPsSize(channel, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getInbandPsSize(::Ice::Int channel)
    {
        return begin_getInbandPsSize(channel, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getInbandPsSize(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return begin_getInbandPsSize(channel, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getInbandPsSize(::Ice::Int channel, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getInbandPsSize(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getInbandPsSize(::Ice::Int channel, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getInbandPsSize(channel, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getInbandPsSize(::Ice::Int channel, const ::QS1R::Callback_RadioCommander_getInbandPsSizePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getInbandPsSize(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getInbandPsSize(::Ice::Int channel, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getInbandPsSizePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getInbandPsSize(channel, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_getInbandPsSize(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int getInbandPsSize(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getInbandPsSize(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setOutbandPsSwitch(::Ice::Int channel, bool on)
    {
        setOutbandPsSwitch(channel, on, 0);
    }
    void setOutbandPsSwitch(::Ice::Int channel, bool on, const ::Ice::Context& __ctx)
    {
        setOutbandPsSwitch(channel, on, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setOutbandPsSwitch(::Ice::Int channel, bool on)
    {
        return begin_setOutbandPsSwitch(channel, on, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setOutbandPsSwitch(::Ice::Int channel, bool on, const ::Ice::Context& __ctx)
    {
        return begin_setOutbandPsSwitch(channel, on, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setOutbandPsSwitch(::Ice::Int channel, bool on, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setOutbandPsSwitch(channel, on, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setOutbandPsSwitch(::Ice::Int channel, bool on, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setOutbandPsSwitch(channel, on, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setOutbandPsSwitch(::Ice::Int channel, bool on, const ::QS1R::Callback_RadioCommander_setOutbandPsSwitchPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setOutbandPsSwitch(channel, on, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setOutbandPsSwitch(::Ice::Int channel, bool on, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setOutbandPsSwitchPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setOutbandPsSwitch(channel, on, &__ctx, __del, __cookie);
    }

    void end_setOutbandPsSwitch(const ::Ice::AsyncResultPtr&);
    
private:

    void setOutbandPsSwitch(::Ice::Int, bool, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setOutbandPsSwitch(::Ice::Int, bool, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    bool getOutbandPsSwitch(::Ice::Int channel)
    {
        return getOutbandPsSwitch(channel, 0);
    }
    bool getOutbandPsSwitch(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return getOutbandPsSwitch(channel, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getOutbandPsSwitch(::Ice::Int channel)
    {
        return begin_getOutbandPsSwitch(channel, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getOutbandPsSwitch(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return begin_getOutbandPsSwitch(channel, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getOutbandPsSwitch(::Ice::Int channel, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getOutbandPsSwitch(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getOutbandPsSwitch(::Ice::Int channel, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getOutbandPsSwitch(channel, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getOutbandPsSwitch(::Ice::Int channel, const ::QS1R::Callback_RadioCommander_getOutbandPsSwitchPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getOutbandPsSwitch(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getOutbandPsSwitch(::Ice::Int channel, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getOutbandPsSwitchPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getOutbandPsSwitch(channel, &__ctx, __del, __cookie);
    }

    bool end_getOutbandPsSwitch(const ::Ice::AsyncResultPtr&);
    
private:

    bool getOutbandPsSwitch(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getOutbandPsSwitch(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int getOutbandPsSize(::Ice::Int channel)
    {
        return getOutbandPsSize(channel, 0);
    }
    ::Ice::Int getOutbandPsSize(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return getOutbandPsSize(channel, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getOutbandPsSize(::Ice::Int channel)
    {
        return begin_getOutbandPsSize(channel, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getOutbandPsSize(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return begin_getOutbandPsSize(channel, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getOutbandPsSize(::Ice::Int channel, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getOutbandPsSize(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getOutbandPsSize(::Ice::Int channel, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getOutbandPsSize(channel, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getOutbandPsSize(::Ice::Int channel, const ::QS1R::Callback_RadioCommander_getOutbandPsSizePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getOutbandPsSize(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getOutbandPsSize(::Ice::Int channel, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getOutbandPsSizePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getOutbandPsSize(channel, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_getOutbandPsSize(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int getOutbandPsSize(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getOutbandPsSize(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string getSpectrumBandwidth(::Ice::Int channel)
    {
        return getSpectrumBandwidth(channel, 0);
    }
    ::std::string getSpectrumBandwidth(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return getSpectrumBandwidth(channel, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getSpectrumBandwidth(::Ice::Int channel)
    {
        return begin_getSpectrumBandwidth(channel, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getSpectrumBandwidth(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return begin_getSpectrumBandwidth(channel, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getSpectrumBandwidth(::Ice::Int channel, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSpectrumBandwidth(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getSpectrumBandwidth(::Ice::Int channel, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSpectrumBandwidth(channel, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getSpectrumBandwidth(::Ice::Int channel, const ::QS1R::Callback_RadioCommander_getSpectrumBandwidthPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSpectrumBandwidth(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getSpectrumBandwidth(::Ice::Int channel, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getSpectrumBandwidthPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSpectrumBandwidth(channel, &__ctx, __del, __cookie);
    }

    ::std::string end_getSpectrumBandwidth(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string getSpectrumBandwidth(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getSpectrumBandwidth(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setSpectrumBandwidth(::Ice::Int channel, const ::std::string& value)
    {
        setSpectrumBandwidth(channel, value, 0);
    }
    void setSpectrumBandwidth(::Ice::Int channel, const ::std::string& value, const ::Ice::Context& __ctx)
    {
        setSpectrumBandwidth(channel, value, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setSpectrumBandwidth(::Ice::Int channel, const ::std::string& value)
    {
        return begin_setSpectrumBandwidth(channel, value, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setSpectrumBandwidth(::Ice::Int channel, const ::std::string& value, const ::Ice::Context& __ctx)
    {
        return begin_setSpectrumBandwidth(channel, value, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setSpectrumBandwidth(::Ice::Int channel, const ::std::string& value, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setSpectrumBandwidth(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setSpectrumBandwidth(::Ice::Int channel, const ::std::string& value, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setSpectrumBandwidth(channel, value, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setSpectrumBandwidth(::Ice::Int channel, const ::std::string& value, const ::QS1R::Callback_RadioCommander_setSpectrumBandwidthPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setSpectrumBandwidth(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setSpectrumBandwidth(::Ice::Int channel, const ::std::string& value, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setSpectrumBandwidthPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setSpectrumBandwidth(channel, value, &__ctx, __del, __cookie);
    }

    void end_setSpectrumBandwidth(const ::Ice::AsyncResultPtr&);
    
private:

    void setSpectrumBandwidth(::Ice::Int, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setSpectrumBandwidth(::Ice::Int, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string getSpectrumBandwidths(::Ice::Int channel)
    {
        return getSpectrumBandwidths(channel, 0);
    }
    ::std::string getSpectrumBandwidths(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return getSpectrumBandwidths(channel, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getSpectrumBandwidths(::Ice::Int channel)
    {
        return begin_getSpectrumBandwidths(channel, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getSpectrumBandwidths(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return begin_getSpectrumBandwidths(channel, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getSpectrumBandwidths(::Ice::Int channel, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSpectrumBandwidths(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getSpectrumBandwidths(::Ice::Int channel, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSpectrumBandwidths(channel, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getSpectrumBandwidths(::Ice::Int channel, const ::QS1R::Callback_RadioCommander_getSpectrumBandwidthsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSpectrumBandwidths(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getSpectrumBandwidths(::Ice::Int channel, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getSpectrumBandwidthsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSpectrumBandwidths(channel, &__ctx, __del, __cookie);
    }

    ::std::string end_getSpectrumBandwidths(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string getSpectrumBandwidths(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getSpectrumBandwidths(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setRand(bool on)
    {
        setRand(on, 0);
    }
    void setRand(bool on, const ::Ice::Context& __ctx)
    {
        setRand(on, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setRand(bool on)
    {
        return begin_setRand(on, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setRand(bool on, const ::Ice::Context& __ctx)
    {
        return begin_setRand(on, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setRand(bool on, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setRand(on, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setRand(bool on, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setRand(on, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setRand(bool on, const ::QS1R::Callback_RadioCommander_setRandPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setRand(on, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setRand(bool on, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setRandPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setRand(on, &__ctx, __del, __cookie);
    }

    void end_setRand(const ::Ice::AsyncResultPtr&);
    
private:

    void setRand(bool, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setRand(bool, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    bool getRand()
    {
        return getRand(0);
    }
    bool getRand(const ::Ice::Context& __ctx)
    {
        return getRand(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getRand()
    {
        return begin_getRand(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getRand(const ::Ice::Context& __ctx)
    {
        return begin_getRand(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getRand(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRand(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRand(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRand(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRand(const ::QS1R::Callback_RadioCommander_getRandPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRand(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRand(const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getRandPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRand(&__ctx, __del, __cookie);
    }

    bool end_getRand(const ::Ice::AsyncResultPtr&);
    
private:

    bool getRand(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getRand(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string getVersion()
    {
        return getVersion(0);
    }
    ::std::string getVersion(const ::Ice::Context& __ctx)
    {
        return getVersion(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getVersion()
    {
        return begin_getVersion(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getVersion(const ::Ice::Context& __ctx)
    {
        return begin_getVersion(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getVersion(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getVersion(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getVersion(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getVersion(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getVersion(const ::QS1R::Callback_RadioCommander_getVersionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getVersion(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getVersion(const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getVersionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getVersion(&__ctx, __del, __cookie);
    }

    ::std::string end_getVersion(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string getVersion(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getVersion(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setSamplerate(::Ice::Int channel, ::Ice::Float value)
    {
        setSamplerate(channel, value, 0);
    }
    void setSamplerate(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx)
    {
        setSamplerate(channel, value, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setSamplerate(::Ice::Int channel, ::Ice::Float value)
    {
        return begin_setSamplerate(channel, value, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setSamplerate(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx)
    {
        return begin_setSamplerate(channel, value, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setSamplerate(::Ice::Int channel, ::Ice::Float value, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setSamplerate(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setSamplerate(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setSamplerate(channel, value, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setSamplerate(::Ice::Int channel, ::Ice::Float value, const ::QS1R::Callback_RadioCommander_setSampleratePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setSamplerate(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setSamplerate(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setSampleratePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setSamplerate(channel, value, &__ctx, __del, __cookie);
    }

    void end_setSamplerate(const ::Ice::AsyncResultPtr&);
    
private:

    void setSamplerate(::Ice::Int, ::Ice::Float, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setSamplerate(::Ice::Int, ::Ice::Float, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Float getSamplerate(::Ice::Int channel)
    {
        return getSamplerate(channel, 0);
    }
    ::Ice::Float getSamplerate(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return getSamplerate(channel, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getSamplerate(::Ice::Int channel)
    {
        return begin_getSamplerate(channel, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getSamplerate(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return begin_getSamplerate(channel, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getSamplerate(::Ice::Int channel, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSamplerate(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getSamplerate(::Ice::Int channel, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSamplerate(channel, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getSamplerate(::Ice::Int channel, const ::QS1R::Callback_RadioCommander_getSampleratePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSamplerate(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getSamplerate(::Ice::Int channel, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getSampleratePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSamplerate(channel, &__ctx, __del, __cookie);
    }

    ::Ice::Float end_getSamplerate(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Float getSamplerate(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getSamplerate(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setSMeterCorrection(::Ice::Int channel, ::Ice::Float value)
    {
        setSMeterCorrection(channel, value, 0);
    }
    void setSMeterCorrection(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx)
    {
        setSMeterCorrection(channel, value, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setSMeterCorrection(::Ice::Int channel, ::Ice::Float value)
    {
        return begin_setSMeterCorrection(channel, value, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setSMeterCorrection(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx)
    {
        return begin_setSMeterCorrection(channel, value, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setSMeterCorrection(::Ice::Int channel, ::Ice::Float value, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setSMeterCorrection(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setSMeterCorrection(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setSMeterCorrection(channel, value, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setSMeterCorrection(::Ice::Int channel, ::Ice::Float value, const ::QS1R::Callback_RadioCommander_setSMeterCorrectionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setSMeterCorrection(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setSMeterCorrection(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setSMeterCorrectionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setSMeterCorrection(channel, value, &__ctx, __del, __cookie);
    }

    void end_setSMeterCorrection(const ::Ice::AsyncResultPtr&);
    
private:

    void setSMeterCorrection(::Ice::Int, ::Ice::Float, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setSMeterCorrection(::Ice::Int, ::Ice::Float, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Float getSMeterCorrection(::Ice::Int channel)
    {
        return getSMeterCorrection(channel, 0);
    }
    ::Ice::Float getSMeterCorrection(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return getSMeterCorrection(channel, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getSMeterCorrection(::Ice::Int channel)
    {
        return begin_getSMeterCorrection(channel, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getSMeterCorrection(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return begin_getSMeterCorrection(channel, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getSMeterCorrection(::Ice::Int channel, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSMeterCorrection(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getSMeterCorrection(::Ice::Int channel, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSMeterCorrection(channel, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getSMeterCorrection(::Ice::Int channel, const ::QS1R::Callback_RadioCommander_getSMeterCorrectionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSMeterCorrection(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getSMeterCorrection(::Ice::Int channel, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getSMeterCorrectionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSMeterCorrection(channel, &__ctx, __del, __cookie);
    }

    ::Ice::Float end_getSMeterCorrection(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Float getSMeterCorrection(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getSMeterCorrection(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Float getSMeterInstantaneous(::Ice::Int channel)
    {
        return getSMeterInstantaneous(channel, 0);
    }
    ::Ice::Float getSMeterInstantaneous(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return getSMeterInstantaneous(channel, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getSMeterInstantaneous(::Ice::Int channel)
    {
        return begin_getSMeterInstantaneous(channel, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getSMeterInstantaneous(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return begin_getSMeterInstantaneous(channel, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getSMeterInstantaneous(::Ice::Int channel, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSMeterInstantaneous(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getSMeterInstantaneous(::Ice::Int channel, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSMeterInstantaneous(channel, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getSMeterInstantaneous(::Ice::Int channel, const ::QS1R::Callback_RadioCommander_getSMeterInstantaneousPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSMeterInstantaneous(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getSMeterInstantaneous(::Ice::Int channel, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getSMeterInstantaneousPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSMeterInstantaneous(channel, &__ctx, __del, __cookie);
    }

    ::Ice::Float end_getSMeterInstantaneous(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Float getSMeterInstantaneous(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getSMeterInstantaneous(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Float getSMeterAverage(::Ice::Int channel)
    {
        return getSMeterAverage(channel, 0);
    }
    ::Ice::Float getSMeterAverage(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return getSMeterAverage(channel, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getSMeterAverage(::Ice::Int channel)
    {
        return begin_getSMeterAverage(channel, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getSMeterAverage(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return begin_getSMeterAverage(channel, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getSMeterAverage(::Ice::Int channel, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSMeterAverage(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getSMeterAverage(::Ice::Int channel, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSMeterAverage(channel, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getSMeterAverage(::Ice::Int channel, const ::QS1R::Callback_RadioCommander_getSMeterAveragePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSMeterAverage(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getSMeterAverage(::Ice::Int channel, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getSMeterAveragePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSMeterAverage(channel, &__ctx, __del, __cookie);
    }

    ::Ice::Float end_getSMeterAverage(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Float getSMeterAverage(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getSMeterAverage(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setSquelchSwitch(::Ice::Int channel, bool on)
    {
        setSquelchSwitch(channel, on, 0);
    }
    void setSquelchSwitch(::Ice::Int channel, bool on, const ::Ice::Context& __ctx)
    {
        setSquelchSwitch(channel, on, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setSquelchSwitch(::Ice::Int channel, bool on)
    {
        return begin_setSquelchSwitch(channel, on, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setSquelchSwitch(::Ice::Int channel, bool on, const ::Ice::Context& __ctx)
    {
        return begin_setSquelchSwitch(channel, on, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setSquelchSwitch(::Ice::Int channel, bool on, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setSquelchSwitch(channel, on, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setSquelchSwitch(::Ice::Int channel, bool on, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setSquelchSwitch(channel, on, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setSquelchSwitch(::Ice::Int channel, bool on, const ::QS1R::Callback_RadioCommander_setSquelchSwitchPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setSquelchSwitch(channel, on, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setSquelchSwitch(::Ice::Int channel, bool on, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setSquelchSwitchPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setSquelchSwitch(channel, on, &__ctx, __del, __cookie);
    }

    void end_setSquelchSwitch(const ::Ice::AsyncResultPtr&);
    
private:

    void setSquelchSwitch(::Ice::Int, bool, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setSquelchSwitch(::Ice::Int, bool, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    bool getSquelchSwitch(::Ice::Int channel)
    {
        return getSquelchSwitch(channel, 0);
    }
    bool getSquelchSwitch(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return getSquelchSwitch(channel, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getSquelchSwitch(::Ice::Int channel)
    {
        return begin_getSquelchSwitch(channel, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getSquelchSwitch(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return begin_getSquelchSwitch(channel, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getSquelchSwitch(::Ice::Int channel, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSquelchSwitch(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getSquelchSwitch(::Ice::Int channel, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSquelchSwitch(channel, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getSquelchSwitch(::Ice::Int channel, const ::QS1R::Callback_RadioCommander_getSquelchSwitchPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSquelchSwitch(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getSquelchSwitch(::Ice::Int channel, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getSquelchSwitchPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSquelchSwitch(channel, &__ctx, __del, __cookie);
    }

    bool end_getSquelchSwitch(const ::Ice::AsyncResultPtr&);
    
private:

    bool getSquelchSwitch(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getSquelchSwitch(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setSquelchThresh(::Ice::Int channel, ::Ice::Float value)
    {
        setSquelchThresh(channel, value, 0);
    }
    void setSquelchThresh(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx)
    {
        setSquelchThresh(channel, value, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setSquelchThresh(::Ice::Int channel, ::Ice::Float value)
    {
        return begin_setSquelchThresh(channel, value, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setSquelchThresh(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx)
    {
        return begin_setSquelchThresh(channel, value, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setSquelchThresh(::Ice::Int channel, ::Ice::Float value, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setSquelchThresh(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setSquelchThresh(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setSquelchThresh(channel, value, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setSquelchThresh(::Ice::Int channel, ::Ice::Float value, const ::QS1R::Callback_RadioCommander_setSquelchThreshPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setSquelchThresh(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setSquelchThresh(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setSquelchThreshPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setSquelchThresh(channel, value, &__ctx, __del, __cookie);
    }

    void end_setSquelchThresh(const ::Ice::AsyncResultPtr&);
    
private:

    void setSquelchThresh(::Ice::Int, ::Ice::Float, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setSquelchThresh(::Ice::Int, ::Ice::Float, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Float getSquelchThresh(::Ice::Int channel)
    {
        return getSquelchThresh(channel, 0);
    }
    ::Ice::Float getSquelchThresh(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return getSquelchThresh(channel, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getSquelchThresh(::Ice::Int channel)
    {
        return begin_getSquelchThresh(channel, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getSquelchThresh(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return begin_getSquelchThresh(channel, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getSquelchThresh(::Ice::Int channel, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSquelchThresh(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getSquelchThresh(::Ice::Int channel, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSquelchThresh(channel, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getSquelchThresh(::Ice::Int channel, const ::QS1R::Callback_RadioCommander_getSquelchThreshPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSquelchThresh(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getSquelchThresh(::Ice::Int channel, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getSquelchThreshPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSquelchThresh(channel, &__ctx, __del, __cookie);
    }

    ::Ice::Float end_getSquelchThresh(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Float getSquelchThresh(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getSquelchThresh(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setStart(bool on)
    {
        setStart(on, 0);
    }
    void setStart(bool on, const ::Ice::Context& __ctx)
    {
        setStart(on, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setStart(bool on)
    {
        return begin_setStart(on, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setStart(bool on, const ::Ice::Context& __ctx)
    {
        return begin_setStart(on, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setStart(bool on, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setStart(on, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setStart(bool on, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setStart(on, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setStart(bool on, const ::QS1R::Callback_RadioCommander_setStartPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setStart(on, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setStart(bool on, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setStartPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setStart(on, &__ctx, __del, __cookie);
    }

    void end_setStart(const ::Ice::AsyncResultPtr&);
    
private:

    void setStart(bool, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setStart(bool, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    bool getStart()
    {
        return getStart(0);
    }
    bool getStart(const ::Ice::Context& __ctx)
    {
        return getStart(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getStart()
    {
        return begin_getStart(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getStart(const ::Ice::Context& __ctx)
    {
        return begin_getStart(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getStart(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getStart(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getStart(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getStart(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getStart(const ::QS1R::Callback_RadioCommander_getStartPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getStart(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getStart(const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getStartPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getStart(&__ctx, __del, __cookie);
    }

    bool end_getStart(const ::Ice::AsyncResultPtr&);
    
private:

    bool getStart(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getStart(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setStop(bool on)
    {
        setStop(on, 0);
    }
    void setStop(bool on, const ::Ice::Context& __ctx)
    {
        setStop(on, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setStop(bool on)
    {
        return begin_setStop(on, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setStop(bool on, const ::Ice::Context& __ctx)
    {
        return begin_setStop(on, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setStop(bool on, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setStop(on, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setStop(bool on, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setStop(on, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setStop(bool on, const ::QS1R::Callback_RadioCommander_setStopPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setStop(on, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setStop(bool on, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setStopPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setStop(on, &__ctx, __del, __cookie);
    }

    void end_setStop(const ::Ice::AsyncResultPtr&);
    
private:

    void setStop(bool, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setStop(bool, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    bool getStop()
    {
        return getStop(0);
    }
    bool getStop(const ::Ice::Context& __ctx)
    {
        return getStop(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getStop()
    {
        return begin_getStop(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getStop(const ::Ice::Context& __ctx)
    {
        return begin_getStop(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getStop(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getStop(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getStop(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getStop(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getStop(const ::QS1R::Callback_RadioCommander_getStopPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getStop(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getStop(const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getStopPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getStop(&__ctx, __del, __cookie);
    }

    bool end_getStop(const ::Ice::AsyncResultPtr&);
    
private:

    bool getStop(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getStop(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setVolume(::Ice::Int channel, ::Ice::Float valleft, ::Ice::Float valright)
    {
        setVolume(channel, valleft, valright, 0);
    }
    void setVolume(::Ice::Int channel, ::Ice::Float valleft, ::Ice::Float valright, const ::Ice::Context& __ctx)
    {
        setVolume(channel, valleft, valright, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setVolume(::Ice::Int channel, ::Ice::Float valleft, ::Ice::Float valright)
    {
        return begin_setVolume(channel, valleft, valright, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setVolume(::Ice::Int channel, ::Ice::Float valleft, ::Ice::Float valright, const ::Ice::Context& __ctx)
    {
        return begin_setVolume(channel, valleft, valright, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setVolume(::Ice::Int channel, ::Ice::Float valleft, ::Ice::Float valright, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setVolume(channel, valleft, valright, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setVolume(::Ice::Int channel, ::Ice::Float valleft, ::Ice::Float valright, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setVolume(channel, valleft, valright, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setVolume(::Ice::Int channel, ::Ice::Float valleft, ::Ice::Float valright, const ::QS1R::Callback_RadioCommander_setVolumePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setVolume(channel, valleft, valright, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setVolume(::Ice::Int channel, ::Ice::Float valleft, ::Ice::Float valright, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setVolumePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setVolume(channel, valleft, valright, &__ctx, __del, __cookie);
    }

    void end_setVolume(const ::Ice::AsyncResultPtr&);
    
private:

    void setVolume(::Ice::Int, ::Ice::Float, ::Ice::Float, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setVolume(::Ice::Int, ::Ice::Float, ::Ice::Float, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setVolumeLeft(::Ice::Int channel, ::Ice::Float value)
    {
        setVolumeLeft(channel, value, 0);
    }
    void setVolumeLeft(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx)
    {
        setVolumeLeft(channel, value, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setVolumeLeft(::Ice::Int channel, ::Ice::Float value)
    {
        return begin_setVolumeLeft(channel, value, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setVolumeLeft(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx)
    {
        return begin_setVolumeLeft(channel, value, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setVolumeLeft(::Ice::Int channel, ::Ice::Float value, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setVolumeLeft(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setVolumeLeft(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setVolumeLeft(channel, value, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setVolumeLeft(::Ice::Int channel, ::Ice::Float value, const ::QS1R::Callback_RadioCommander_setVolumeLeftPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setVolumeLeft(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setVolumeLeft(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setVolumeLeftPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setVolumeLeft(channel, value, &__ctx, __del, __cookie);
    }

    void end_setVolumeLeft(const ::Ice::AsyncResultPtr&);
    
private:

    void setVolumeLeft(::Ice::Int, ::Ice::Float, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setVolumeLeft(::Ice::Int, ::Ice::Float, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Float getVolumeLeft(::Ice::Int channel)
    {
        return getVolumeLeft(channel, 0);
    }
    ::Ice::Float getVolumeLeft(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return getVolumeLeft(channel, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getVolumeLeft(::Ice::Int channel)
    {
        return begin_getVolumeLeft(channel, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getVolumeLeft(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return begin_getVolumeLeft(channel, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getVolumeLeft(::Ice::Int channel, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getVolumeLeft(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getVolumeLeft(::Ice::Int channel, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getVolumeLeft(channel, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getVolumeLeft(::Ice::Int channel, const ::QS1R::Callback_RadioCommander_getVolumeLeftPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getVolumeLeft(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getVolumeLeft(::Ice::Int channel, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getVolumeLeftPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getVolumeLeft(channel, &__ctx, __del, __cookie);
    }

    ::Ice::Float end_getVolumeLeft(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Float getVolumeLeft(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getVolumeLeft(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setVolumeRight(::Ice::Int channel, ::Ice::Float value)
    {
        setVolumeRight(channel, value, 0);
    }
    void setVolumeRight(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx)
    {
        setVolumeRight(channel, value, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setVolumeRight(::Ice::Int channel, ::Ice::Float value)
    {
        return begin_setVolumeRight(channel, value, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setVolumeRight(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx)
    {
        return begin_setVolumeRight(channel, value, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setVolumeRight(::Ice::Int channel, ::Ice::Float value, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setVolumeRight(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setVolumeRight(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setVolumeRight(channel, value, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setVolumeRight(::Ice::Int channel, ::Ice::Float value, const ::QS1R::Callback_RadioCommander_setVolumeRightPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setVolumeRight(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setVolumeRight(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setVolumeRightPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setVolumeRight(channel, value, &__ctx, __del, __cookie);
    }

    void end_setVolumeRight(const ::Ice::AsyncResultPtr&);
    
private:

    void setVolumeRight(::Ice::Int, ::Ice::Float, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setVolumeRight(::Ice::Int, ::Ice::Float, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Float getVolumeRight(::Ice::Int channel, ::Ice::Float value)
    {
        return getVolumeRight(channel, value, 0);
    }
    ::Ice::Float getVolumeRight(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx)
    {
        return getVolumeRight(channel, value, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getVolumeRight(::Ice::Int channel, ::Ice::Float value)
    {
        return begin_getVolumeRight(channel, value, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getVolumeRight(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx)
    {
        return begin_getVolumeRight(channel, value, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getVolumeRight(::Ice::Int channel, ::Ice::Float value, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getVolumeRight(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getVolumeRight(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getVolumeRight(channel, value, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getVolumeRight(::Ice::Int channel, ::Ice::Float value, const ::QS1R::Callback_RadioCommander_getVolumeRightPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getVolumeRight(channel, value, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getVolumeRight(::Ice::Int channel, ::Ice::Float value, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getVolumeRightPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getVolumeRight(channel, value, &__ctx, __del, __cookie);
    }

    ::Ice::Float end_getVolumeRight(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Float getVolumeRight(::Ice::Int, ::Ice::Float, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getVolumeRight(::Ice::Int, ::Ice::Float, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setLoadFirmware(bool go)
    {
        setLoadFirmware(go, 0);
    }
    void setLoadFirmware(bool go, const ::Ice::Context& __ctx)
    {
        setLoadFirmware(go, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setLoadFirmware(bool go)
    {
        return begin_setLoadFirmware(go, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setLoadFirmware(bool go, const ::Ice::Context& __ctx)
    {
        return begin_setLoadFirmware(go, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setLoadFirmware(bool go, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setLoadFirmware(go, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setLoadFirmware(bool go, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setLoadFirmware(go, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setLoadFirmware(bool go, const ::QS1R::Callback_RadioCommander_setLoadFirmwarePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setLoadFirmware(go, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setLoadFirmware(bool go, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setLoadFirmwarePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setLoadFirmware(go, &__ctx, __del, __cookie);
    }

    void end_setLoadFirmware(const ::Ice::AsyncResultPtr&);
    
private:

    void setLoadFirmware(bool, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setLoadFirmware(bool, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setLoadFpga(bool go)
    {
        setLoadFpga(go, 0);
    }
    void setLoadFpga(bool go, const ::Ice::Context& __ctx)
    {
        setLoadFpga(go, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setLoadFpga(bool go)
    {
        return begin_setLoadFpga(go, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setLoadFpga(bool go, const ::Ice::Context& __ctx)
    {
        return begin_setLoadFpga(go, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setLoadFpga(bool go, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setLoadFpga(go, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setLoadFpga(bool go, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setLoadFpga(go, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setLoadFpga(bool go, const ::QS1R::Callback_RadioCommander_setLoadFpgaPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setLoadFpga(go, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setLoadFpga(bool go, const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_setLoadFpgaPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setLoadFpga(go, &__ctx, __del, __cookie);
    }

    void end_setLoadFpga(const ::Ice::AsyncResultPtr&);
    
private:

    void setLoadFpga(bool, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setLoadFpga(bool, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string getFpgaFileId()
    {
        return getFpgaFileId(0);
    }
    ::std::string getFpgaFileId(const ::Ice::Context& __ctx)
    {
        return getFpgaFileId(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getFpgaFileId()
    {
        return begin_getFpgaFileId(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getFpgaFileId(const ::Ice::Context& __ctx)
    {
        return begin_getFpgaFileId(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getFpgaFileId(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFpgaFileId(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFpgaFileId(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFpgaFileId(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFpgaFileId(const ::QS1R::Callback_RadioCommander_getFpgaFileIdPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFpgaFileId(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFpgaFileId(const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getFpgaFileIdPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFpgaFileId(&__ctx, __del, __cookie);
    }

    ::std::string end_getFpgaFileId(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string getFpgaFileId(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getFpgaFileId(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string getFirmwareFileName()
    {
        return getFirmwareFileName(0);
    }
    ::std::string getFirmwareFileName(const ::Ice::Context& __ctx)
    {
        return getFirmwareFileName(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getFirmwareFileName()
    {
        return begin_getFirmwareFileName(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getFirmwareFileName(const ::Ice::Context& __ctx)
    {
        return begin_getFirmwareFileName(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getFirmwareFileName(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFirmwareFileName(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFirmwareFileName(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFirmwareFileName(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFirmwareFileName(const ::QS1R::Callback_RadioCommander_getFirmwareFileNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFirmwareFileName(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFirmwareFileName(const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getFirmwareFileNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFirmwareFileName(&__ctx, __del, __cookie);
    }

    ::std::string end_getFirmwareFileName(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string getFirmwareFileName(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getFirmwareFileName(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string getFpgaRbfName()
    {
        return getFpgaRbfName(0);
    }
    ::std::string getFpgaRbfName(const ::Ice::Context& __ctx)
    {
        return getFpgaRbfName(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getFpgaRbfName()
    {
        return begin_getFpgaRbfName(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getFpgaRbfName(const ::Ice::Context& __ctx)
    {
        return begin_getFpgaRbfName(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getFpgaRbfName(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFpgaRbfName(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFpgaRbfName(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFpgaRbfName(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFpgaRbfName(const ::QS1R::Callback_RadioCommander_getFpgaRbfNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFpgaRbfName(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getFpgaRbfName(const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getFpgaRbfNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getFpgaRbfName(&__ctx, __del, __cookie);
    }

    ::std::string end_getFpgaRbfName(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string getFpgaRbfName(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getFpgaRbfName(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string getDateTime()
    {
        return getDateTime(0);
    }
    ::std::string getDateTime(const ::Ice::Context& __ctx)
    {
        return getDateTime(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getDateTime()
    {
        return begin_getDateTime(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getDateTime(const ::Ice::Context& __ctx)
    {
        return begin_getDateTime(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getDateTime(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDateTime(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getDateTime(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDateTime(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getDateTime(const ::QS1R::Callback_RadioCommander_getDateTimePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDateTime(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getDateTime(const ::Ice::Context& __ctx, const ::QS1R::Callback_RadioCommander_getDateTimePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDateTime(&__ctx, __del, __cookie);
    }

    ::std::string end_getDateTime(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string getDateTime(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getDateTime(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<RadioCommander> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RadioCommander*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<RadioCommander*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RadioCommander> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RadioCommander*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<RadioCommander*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RadioCommander> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RadioCommander*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<RadioCommander*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RadioCommander> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RadioCommander*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<RadioCommander*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RadioCommander> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RadioCommander*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<RadioCommander*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RadioCommander> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RadioCommander*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<RadioCommander*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RadioCommander> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RadioCommander*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<RadioCommander*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RadioCommander> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RadioCommander*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<RadioCommander*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RadioCommander> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RadioCommander*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<RadioCommander*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RadioCommander> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RadioCommander*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<RadioCommander*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RadioCommander> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RadioCommander*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<RadioCommander*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RadioCommander> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RadioCommander*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<RadioCommander*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RadioCommander> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RadioCommander*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<RadioCommander*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RadioCommander> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RadioCommander*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<RadioCommander*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RadioCommander> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RadioCommander*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<RadioCommander*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RadioCommander> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RadioCommander*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<RadioCommander*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RadioCommander> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RadioCommander*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<RadioCommander*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RadioCommander> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RadioCommander*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<RadioCommander*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<RadioCommander> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<RadioCommander*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<RadioCommander*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class PowerSpectrumData : virtual public ::IceProxy::Ice::Object
{
public:

    ::QS1R::SpecBuffer getSpecData(::Ice::Int channel)
    {
        return getSpecData(channel, 0);
    }
    ::QS1R::SpecBuffer getSpecData(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return getSpecData(channel, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getSpecData(::Ice::Int channel)
    {
        return begin_getSpecData(channel, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getSpecData(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return begin_getSpecData(channel, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getSpecData(::Ice::Int channel, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSpecData(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getSpecData(::Ice::Int channel, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSpecData(channel, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getSpecData(::Ice::Int channel, const ::QS1R::Callback_PowerSpectrumData_getSpecDataPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSpecData(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getSpecData(::Ice::Int channel, const ::Ice::Context& __ctx, const ::QS1R::Callback_PowerSpectrumData_getSpecDataPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSpecData(channel, &__ctx, __del, __cookie);
    }

    ::QS1R::SpecBuffer end_getSpecData(const ::Ice::AsyncResultPtr&);
    
private:

    ::QS1R::SpecBuffer getSpecData(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getSpecData(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int getSpecDataSize(::Ice::Int channel)
    {
        return getSpecDataSize(channel, 0);
    }
    ::Ice::Int getSpecDataSize(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return getSpecDataSize(channel, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getSpecDataSize(::Ice::Int channel)
    {
        return begin_getSpecDataSize(channel, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getSpecDataSize(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return begin_getSpecDataSize(channel, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getSpecDataSize(::Ice::Int channel, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSpecDataSize(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getSpecDataSize(::Ice::Int channel, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSpecDataSize(channel, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getSpecDataSize(::Ice::Int channel, const ::QS1R::Callback_PowerSpectrumData_getSpecDataSizePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSpecDataSize(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getSpecDataSize(::Ice::Int channel, const ::Ice::Context& __ctx, const ::QS1R::Callback_PowerSpectrumData_getSpecDataSizePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getSpecDataSize(channel, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_getSpecDataSize(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int getSpecDataSize(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getSpecDataSize(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<PowerSpectrumData> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PowerSpectrumData*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<PowerSpectrumData*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PowerSpectrumData> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PowerSpectrumData*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<PowerSpectrumData*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PowerSpectrumData> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PowerSpectrumData*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<PowerSpectrumData*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PowerSpectrumData> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PowerSpectrumData*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<PowerSpectrumData*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PowerSpectrumData> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PowerSpectrumData*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<PowerSpectrumData*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PowerSpectrumData> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PowerSpectrumData*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<PowerSpectrumData*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PowerSpectrumData> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PowerSpectrumData*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<PowerSpectrumData*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PowerSpectrumData> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PowerSpectrumData*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<PowerSpectrumData*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PowerSpectrumData> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PowerSpectrumData*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<PowerSpectrumData*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PowerSpectrumData> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PowerSpectrumData*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<PowerSpectrumData*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PowerSpectrumData> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PowerSpectrumData*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<PowerSpectrumData*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PowerSpectrumData> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PowerSpectrumData*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<PowerSpectrumData*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PowerSpectrumData> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PowerSpectrumData*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<PowerSpectrumData*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PowerSpectrumData> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PowerSpectrumData*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<PowerSpectrumData*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PowerSpectrumData> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PowerSpectrumData*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<PowerSpectrumData*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PowerSpectrumData> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PowerSpectrumData*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<PowerSpectrumData*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PowerSpectrumData> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PowerSpectrumData*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<PowerSpectrumData*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PowerSpectrumData> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PowerSpectrumData*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<PowerSpectrumData*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<PowerSpectrumData> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<PowerSpectrumData*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<PowerSpectrumData*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class MeterData : virtual public ::IceProxy::Ice::Object
{
public:

    ::QS1R::MeterDataStruct getMeterData(::Ice::Int channel)
    {
        return getMeterData(channel, 0);
    }
    ::QS1R::MeterDataStruct getMeterData(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return getMeterData(channel, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getMeterData(::Ice::Int channel)
    {
        return begin_getMeterData(channel, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getMeterData(::Ice::Int channel, const ::Ice::Context& __ctx)
    {
        return begin_getMeterData(channel, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getMeterData(::Ice::Int channel, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getMeterData(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getMeterData(::Ice::Int channel, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getMeterData(channel, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getMeterData(::Ice::Int channel, const ::QS1R::Callback_MeterData_getMeterDataPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getMeterData(channel, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getMeterData(::Ice::Int channel, const ::Ice::Context& __ctx, const ::QS1R::Callback_MeterData_getMeterDataPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getMeterData(channel, &__ctx, __del, __cookie);
    }

    ::QS1R::MeterDataStruct end_getMeterData(const ::Ice::AsyncResultPtr&);
    
private:

    ::QS1R::MeterDataStruct getMeterData(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getMeterData(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<MeterData> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MeterData*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<MeterData*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MeterData> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MeterData*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<MeterData*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MeterData> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MeterData*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<MeterData*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MeterData> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MeterData*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<MeterData*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MeterData> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MeterData*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<MeterData*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MeterData> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MeterData*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<MeterData*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MeterData> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MeterData*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<MeterData*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MeterData> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MeterData*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<MeterData*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MeterData> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MeterData*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<MeterData*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MeterData> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MeterData*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<MeterData*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MeterData> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MeterData*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<MeterData*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MeterData> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MeterData*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<MeterData*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MeterData> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MeterData*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<MeterData*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MeterData> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MeterData*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<MeterData*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MeterData> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MeterData*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<MeterData*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MeterData> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MeterData*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<MeterData*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MeterData> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MeterData*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<MeterData*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MeterData> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MeterData*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<MeterData*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MeterData> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MeterData*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<MeterData*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

}

namespace IceDelegate
{

namespace QS1R
{

class RadioCommander : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual void setAgcMode(::Ice::Int, ::QS1R::AGCMODE, const ::Ice::Context*) = 0;

    virtual ::QS1R::AGCMODE getAgcMode(::Ice::Int, const ::Ice::Context*) = 0;

    virtual void setAgcMaxGain(::Ice::Int, ::Ice::Float, const ::Ice::Context*) = 0;

    virtual ::Ice::Float getAgcMaxGain(::Ice::Int, const ::Ice::Context*) = 0;

    virtual void setAgcFixedGain(::Ice::Int, ::Ice::Float, const ::Ice::Context*) = 0;

    virtual ::Ice::Float getAgcFixedGain(::Ice::Int, const ::Ice::Context*) = 0;

    virtual void setAgcAttack(::Ice::Int, ::Ice::Float, const ::Ice::Context*) = 0;

    virtual ::Ice::Float getAgcAttack(::Ice::Int, const ::Ice::Context*) = 0;

    virtual void setAgcDecay(::Ice::Int, ::Ice::Float, const ::Ice::Context*) = 0;

    virtual ::Ice::Float getAgcDecay(::Ice::Int, const ::Ice::Context*) = 0;

    virtual void setAgcHangTime(::Ice::Int, ::Ice::Float, const ::Ice::Context*) = 0;

    virtual ::Ice::Float getAgcHangTime(::Ice::Int, const ::Ice::Context*) = 0;

    virtual void setAgcHangThresh(::Ice::Int, ::Ice::Float, const ::Ice::Context*) = 0;

    virtual ::Ice::Float getAgcHangThresh(::Ice::Int, const ::Ice::Context*) = 0;

    virtual void setAgcSlope(::Ice::Int, ::Ice::Float, const ::Ice::Context*) = 0;

    virtual ::Ice::Float getAgcSlope(::Ice::Int, const ::Ice::Context*) = 0;

    virtual ::Ice::Float getAgcFastGain(::Ice::Int, const ::Ice::Context*) = 0;

    virtual ::Ice::Float getAgcCurrentGain(::Ice::Int, const ::Ice::Context*) = 0;

    virtual void setAnfSwitch(::Ice::Int, bool, const ::Ice::Context*) = 0;

    virtual bool getAnfSwitch(::Ice::Int, const ::Ice::Context*) = 0;

    virtual void setAnfDelay(::Ice::Int, ::Ice::Int, const ::Ice::Context*) = 0;

    virtual ::Ice::Int getAnfDelay(::Ice::Int, const ::Ice::Context*) = 0;

    virtual void setAnfTaps(::Ice::Int, ::Ice::Int, const ::Ice::Context*) = 0;

    virtual ::Ice::Int getAnfTaps(::Ice::Int, const ::Ice::Context*) = 0;

    virtual void setAnfGain(::Ice::Int, ::Ice::Float, const ::Ice::Context*) = 0;

    virtual ::Ice::Float getAnfGain(::Ice::Int, const ::Ice::Context*) = 0;

    virtual void setAnfLeak(::Ice::Int, ::Ice::Float, const ::Ice::Context*) = 0;

    virtual ::Ice::Float getAnfLeak(::Ice::Int, const ::Ice::Context*) = 0;

    virtual void setBinaural(bool, const ::Ice::Context*) = 0;

    virtual bool getBinaural(const ::Ice::Context*) = 0;

    virtual void setBlockSize(::Ice::Int, const ::Ice::Context*) = 0;

    virtual ::Ice::Int getBlockSize(const ::Ice::Context*) = 0;

    virtual void setDemodMode(::Ice::Int, ::QS1R::DEMODMODE, const ::Ice::Context*) = 0;

    virtual ::QS1R::DEMODMODE getDemodMode(::Ice::Int, const ::Ice::Context*) = 0;

    virtual void setControlRegister(::Ice::Int, const ::Ice::Context*) = 0;

    virtual ::Ice::Int getControlRegister(const ::Ice::Context*) = 0;

    virtual void setDecimationRegister(::Ice::Int, ::Ice::Int, const ::Ice::Context*) = 0;

    virtual ::Ice::Int getDecimationRegister(::Ice::Int, const ::Ice::Context*) = 0;

    virtual void setScalingRegister(::Ice::Int, ::Ice::Int, const ::Ice::Context*) = 0;

    virtual ::Ice::Int getScalingRegister(::Ice::Int, const ::Ice::Context*) = 0;

    virtual ::std::string getEepromEncFreqRegister(const ::Ice::Context*) = 0;

    virtual void setDither(bool, const ::Ice::Context*) = 0;

    virtual bool getDither(const ::Ice::Context*) = 0;

    virtual void setEncodeFreq(::Ice::Float, const ::Ice::Context*) = 0;

    virtual ::Ice::Float getEncodeFreq(const ::Ice::Context*) = 0;

    virtual void setMeterCalibrationOffset(::Ice::Float, const ::Ice::Context*) = 0;

    virtual ::Ice::Float getMeterCalibrationOffset(const ::Ice::Context*) = 0;

    virtual void setSpectrumCalibrationOffset(::Ice::Float, const ::Ice::Context*) = 0;

    virtual ::Ice::Float getSpectrumCalibrationOffset(const ::Ice::Context*) = 0;

    virtual void setNrSwitch(::Ice::Int, bool, const ::Ice::Context*) = 0;

    virtual bool getNrSwitch(::Ice::Int, const ::Ice::Context*) = 0;

    virtual void setNrTaps(::Ice::Int, ::Ice::Int, const ::Ice::Context*) = 0;

    virtual ::Ice::Int getNrTaps(::Ice::Int, const ::Ice::Context*) = 0;

    virtual void setNrDelay(::Ice::Int, ::Ice::Int, const ::Ice::Context*) = 0;

    virtual ::Ice::Int getNrDelay(::Ice::Int, const ::Ice::Context*) = 0;

    virtual void setNrGain(::Ice::Int, ::Ice::Float, const ::Ice::Context*) = 0;

    virtual ::Ice::Float getNrGain(::Ice::Int, const ::Ice::Context*) = 0;

    virtual void setNrLeak(::Ice::Int, ::Ice::Float, const ::Ice::Context*) = 0;

    virtual ::Ice::Float getNrLeak(::Ice::Int, const ::Ice::Context*) = 0;

    virtual void setExit(bool, const ::Ice::Context*) = 0;

    virtual void setFrequency(::Ice::Int, ::Ice::Float, const ::Ice::Context*) = 0;

    virtual ::Ice::Float getFrequency(::Ice::Int, const ::Ice::Context*) = 0;

    virtual void setFilterLo(::Ice::Int, ::Ice::Float, const ::Ice::Context*) = 0;

    virtual ::Ice::Float getFilterLo(::Ice::Int, const ::Ice::Context*) = 0;

    virtual void setFilterHi(::Ice::Int, ::Ice::Float, const ::Ice::Context*) = 0;

    virtual ::Ice::Float getFilterHi(::Ice::Int, const ::Ice::Context*) = 0;

    virtual void setFilter(::Ice::Int, ::Ice::Float, ::Ice::Float, const ::Ice::Context*) = 0;

    virtual void setMute(::Ice::Int, bool, const ::Ice::Context*) = 0;

    virtual bool getMute(::Ice::Int, const ::Ice::Context*) = 0;

    virtual void setNb1Switch(::Ice::Int, bool, const ::Ice::Context*) = 0;

    virtual void setNb1Thresh(::Ice::Int, ::Ice::Int, const ::Ice::Context*) = 0;

    virtual bool getNb1Switch(::Ice::Int, const ::Ice::Context*) = 0;

    virtual ::Ice::Int getNb1Thresh(::Ice::Int, const ::Ice::Context*) = 0;

    virtual void setNb2Switch(::Ice::Int, bool, const ::Ice::Context*) = 0;

    virtual void setNb2Thresh(::Ice::Int, ::Ice::Int, const ::Ice::Context*) = 0;

    virtual bool getNb2Switch(::Ice::Int, const ::Ice::Context*) = 0;

    virtual ::Ice::Int getNb2Thresh(::Ice::Int, const ::Ice::Context*) = 0;

    virtual void setPga(bool, const ::Ice::Context*) = 0;

    virtual bool getPga(const ::Ice::Context*) = 0;

    virtual void setInbandPsSwitch(::Ice::Int, bool, const ::Ice::Context*) = 0;

    virtual bool getInbandPsSwitch(::Ice::Int, const ::Ice::Context*) = 0;

    virtual ::Ice::Int getInbandPsSize(::Ice::Int, const ::Ice::Context*) = 0;

    virtual void setOutbandPsSwitch(::Ice::Int, bool, const ::Ice::Context*) = 0;

    virtual bool getOutbandPsSwitch(::Ice::Int, const ::Ice::Context*) = 0;

    virtual ::Ice::Int getOutbandPsSize(::Ice::Int, const ::Ice::Context*) = 0;

    virtual ::std::string getSpectrumBandwidth(::Ice::Int, const ::Ice::Context*) = 0;

    virtual void setSpectrumBandwidth(::Ice::Int, const ::std::string&, const ::Ice::Context*) = 0;

    virtual ::std::string getSpectrumBandwidths(::Ice::Int, const ::Ice::Context*) = 0;

    virtual void setRand(bool, const ::Ice::Context*) = 0;

    virtual bool getRand(const ::Ice::Context*) = 0;

    virtual ::std::string getVersion(const ::Ice::Context*) = 0;

    virtual void setSamplerate(::Ice::Int, ::Ice::Float, const ::Ice::Context*) = 0;

    virtual ::Ice::Float getSamplerate(::Ice::Int, const ::Ice::Context*) = 0;

    virtual void setSMeterCorrection(::Ice::Int, ::Ice::Float, const ::Ice::Context*) = 0;

    virtual ::Ice::Float getSMeterCorrection(::Ice::Int, const ::Ice::Context*) = 0;

    virtual ::Ice::Float getSMeterInstantaneous(::Ice::Int, const ::Ice::Context*) = 0;

    virtual ::Ice::Float getSMeterAverage(::Ice::Int, const ::Ice::Context*) = 0;

    virtual void setSquelchSwitch(::Ice::Int, bool, const ::Ice::Context*) = 0;

    virtual bool getSquelchSwitch(::Ice::Int, const ::Ice::Context*) = 0;

    virtual void setSquelchThresh(::Ice::Int, ::Ice::Float, const ::Ice::Context*) = 0;

    virtual ::Ice::Float getSquelchThresh(::Ice::Int, const ::Ice::Context*) = 0;

    virtual void setStart(bool, const ::Ice::Context*) = 0;

    virtual bool getStart(const ::Ice::Context*) = 0;

    virtual void setStop(bool, const ::Ice::Context*) = 0;

    virtual bool getStop(const ::Ice::Context*) = 0;

    virtual void setVolume(::Ice::Int, ::Ice::Float, ::Ice::Float, const ::Ice::Context*) = 0;

    virtual void setVolumeLeft(::Ice::Int, ::Ice::Float, const ::Ice::Context*) = 0;

    virtual ::Ice::Float getVolumeLeft(::Ice::Int, const ::Ice::Context*) = 0;

    virtual void setVolumeRight(::Ice::Int, ::Ice::Float, const ::Ice::Context*) = 0;

    virtual ::Ice::Float getVolumeRight(::Ice::Int, ::Ice::Float, const ::Ice::Context*) = 0;

    virtual void setLoadFirmware(bool, const ::Ice::Context*) = 0;

    virtual void setLoadFpga(bool, const ::Ice::Context*) = 0;

    virtual ::std::string getFpgaFileId(const ::Ice::Context*) = 0;

    virtual ::std::string getFirmwareFileName(const ::Ice::Context*) = 0;

    virtual ::std::string getFpgaRbfName(const ::Ice::Context*) = 0;

    virtual ::std::string getDateTime(const ::Ice::Context*) = 0;
};

class PowerSpectrumData : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual ::QS1R::SpecBuffer getSpecData(::Ice::Int, const ::Ice::Context*) = 0;

    virtual ::Ice::Int getSpecDataSize(::Ice::Int, const ::Ice::Context*) = 0;
};

class MeterData : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual ::QS1R::MeterDataStruct getMeterData(::Ice::Int, const ::Ice::Context*) = 0;
};

}

}

namespace IceDelegateM
{

namespace QS1R
{

class RadioCommander : virtual public ::IceDelegate::QS1R::RadioCommander,
                       virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual void setAgcMode(::Ice::Int, ::QS1R::AGCMODE, const ::Ice::Context*);

    virtual ::QS1R::AGCMODE getAgcMode(::Ice::Int, const ::Ice::Context*);

    virtual void setAgcMaxGain(::Ice::Int, ::Ice::Float, const ::Ice::Context*);

    virtual ::Ice::Float getAgcMaxGain(::Ice::Int, const ::Ice::Context*);

    virtual void setAgcFixedGain(::Ice::Int, ::Ice::Float, const ::Ice::Context*);

    virtual ::Ice::Float getAgcFixedGain(::Ice::Int, const ::Ice::Context*);

    virtual void setAgcAttack(::Ice::Int, ::Ice::Float, const ::Ice::Context*);

    virtual ::Ice::Float getAgcAttack(::Ice::Int, const ::Ice::Context*);

    virtual void setAgcDecay(::Ice::Int, ::Ice::Float, const ::Ice::Context*);

    virtual ::Ice::Float getAgcDecay(::Ice::Int, const ::Ice::Context*);

    virtual void setAgcHangTime(::Ice::Int, ::Ice::Float, const ::Ice::Context*);

    virtual ::Ice::Float getAgcHangTime(::Ice::Int, const ::Ice::Context*);

    virtual void setAgcHangThresh(::Ice::Int, ::Ice::Float, const ::Ice::Context*);

    virtual ::Ice::Float getAgcHangThresh(::Ice::Int, const ::Ice::Context*);

    virtual void setAgcSlope(::Ice::Int, ::Ice::Float, const ::Ice::Context*);

    virtual ::Ice::Float getAgcSlope(::Ice::Int, const ::Ice::Context*);

    virtual ::Ice::Float getAgcFastGain(::Ice::Int, const ::Ice::Context*);

    virtual ::Ice::Float getAgcCurrentGain(::Ice::Int, const ::Ice::Context*);

    virtual void setAnfSwitch(::Ice::Int, bool, const ::Ice::Context*);

    virtual bool getAnfSwitch(::Ice::Int, const ::Ice::Context*);

    virtual void setAnfDelay(::Ice::Int, ::Ice::Int, const ::Ice::Context*);

    virtual ::Ice::Int getAnfDelay(::Ice::Int, const ::Ice::Context*);

    virtual void setAnfTaps(::Ice::Int, ::Ice::Int, const ::Ice::Context*);

    virtual ::Ice::Int getAnfTaps(::Ice::Int, const ::Ice::Context*);

    virtual void setAnfGain(::Ice::Int, ::Ice::Float, const ::Ice::Context*);

    virtual ::Ice::Float getAnfGain(::Ice::Int, const ::Ice::Context*);

    virtual void setAnfLeak(::Ice::Int, ::Ice::Float, const ::Ice::Context*);

    virtual ::Ice::Float getAnfLeak(::Ice::Int, const ::Ice::Context*);

    virtual void setBinaural(bool, const ::Ice::Context*);

    virtual bool getBinaural(const ::Ice::Context*);

    virtual void setBlockSize(::Ice::Int, const ::Ice::Context*);

    virtual ::Ice::Int getBlockSize(const ::Ice::Context*);

    virtual void setDemodMode(::Ice::Int, ::QS1R::DEMODMODE, const ::Ice::Context*);

    virtual ::QS1R::DEMODMODE getDemodMode(::Ice::Int, const ::Ice::Context*);

    virtual void setControlRegister(::Ice::Int, const ::Ice::Context*);

    virtual ::Ice::Int getControlRegister(const ::Ice::Context*);

    virtual void setDecimationRegister(::Ice::Int, ::Ice::Int, const ::Ice::Context*);

    virtual ::Ice::Int getDecimationRegister(::Ice::Int, const ::Ice::Context*);

    virtual void setScalingRegister(::Ice::Int, ::Ice::Int, const ::Ice::Context*);

    virtual ::Ice::Int getScalingRegister(::Ice::Int, const ::Ice::Context*);

    virtual ::std::string getEepromEncFreqRegister(const ::Ice::Context*);

    virtual void setDither(bool, const ::Ice::Context*);

    virtual bool getDither(const ::Ice::Context*);

    virtual void setEncodeFreq(::Ice::Float, const ::Ice::Context*);

    virtual ::Ice::Float getEncodeFreq(const ::Ice::Context*);

    virtual void setMeterCalibrationOffset(::Ice::Float, const ::Ice::Context*);

    virtual ::Ice::Float getMeterCalibrationOffset(const ::Ice::Context*);

    virtual void setSpectrumCalibrationOffset(::Ice::Float, const ::Ice::Context*);

    virtual ::Ice::Float getSpectrumCalibrationOffset(const ::Ice::Context*);

    virtual void setNrSwitch(::Ice::Int, bool, const ::Ice::Context*);

    virtual bool getNrSwitch(::Ice::Int, const ::Ice::Context*);

    virtual void setNrTaps(::Ice::Int, ::Ice::Int, const ::Ice::Context*);

    virtual ::Ice::Int getNrTaps(::Ice::Int, const ::Ice::Context*);

    virtual void setNrDelay(::Ice::Int, ::Ice::Int, const ::Ice::Context*);

    virtual ::Ice::Int getNrDelay(::Ice::Int, const ::Ice::Context*);

    virtual void setNrGain(::Ice::Int, ::Ice::Float, const ::Ice::Context*);

    virtual ::Ice::Float getNrGain(::Ice::Int, const ::Ice::Context*);

    virtual void setNrLeak(::Ice::Int, ::Ice::Float, const ::Ice::Context*);

    virtual ::Ice::Float getNrLeak(::Ice::Int, const ::Ice::Context*);

    virtual void setExit(bool, const ::Ice::Context*);

    virtual void setFrequency(::Ice::Int, ::Ice::Float, const ::Ice::Context*);

    virtual ::Ice::Float getFrequency(::Ice::Int, const ::Ice::Context*);

    virtual void setFilterLo(::Ice::Int, ::Ice::Float, const ::Ice::Context*);

    virtual ::Ice::Float getFilterLo(::Ice::Int, const ::Ice::Context*);

    virtual void setFilterHi(::Ice::Int, ::Ice::Float, const ::Ice::Context*);

    virtual ::Ice::Float getFilterHi(::Ice::Int, const ::Ice::Context*);

    virtual void setFilter(::Ice::Int, ::Ice::Float, ::Ice::Float, const ::Ice::Context*);

    virtual void setMute(::Ice::Int, bool, const ::Ice::Context*);

    virtual bool getMute(::Ice::Int, const ::Ice::Context*);

    virtual void setNb1Switch(::Ice::Int, bool, const ::Ice::Context*);

    virtual void setNb1Thresh(::Ice::Int, ::Ice::Int, const ::Ice::Context*);

    virtual bool getNb1Switch(::Ice::Int, const ::Ice::Context*);

    virtual ::Ice::Int getNb1Thresh(::Ice::Int, const ::Ice::Context*);

    virtual void setNb2Switch(::Ice::Int, bool, const ::Ice::Context*);

    virtual void setNb2Thresh(::Ice::Int, ::Ice::Int, const ::Ice::Context*);

    virtual bool getNb2Switch(::Ice::Int, const ::Ice::Context*);

    virtual ::Ice::Int getNb2Thresh(::Ice::Int, const ::Ice::Context*);

    virtual void setPga(bool, const ::Ice::Context*);

    virtual bool getPga(const ::Ice::Context*);

    virtual void setInbandPsSwitch(::Ice::Int, bool, const ::Ice::Context*);

    virtual bool getInbandPsSwitch(::Ice::Int, const ::Ice::Context*);

    virtual ::Ice::Int getInbandPsSize(::Ice::Int, const ::Ice::Context*);

    virtual void setOutbandPsSwitch(::Ice::Int, bool, const ::Ice::Context*);

    virtual bool getOutbandPsSwitch(::Ice::Int, const ::Ice::Context*);

    virtual ::Ice::Int getOutbandPsSize(::Ice::Int, const ::Ice::Context*);

    virtual ::std::string getSpectrumBandwidth(::Ice::Int, const ::Ice::Context*);

    virtual void setSpectrumBandwidth(::Ice::Int, const ::std::string&, const ::Ice::Context*);

    virtual ::std::string getSpectrumBandwidths(::Ice::Int, const ::Ice::Context*);

    virtual void setRand(bool, const ::Ice::Context*);

    virtual bool getRand(const ::Ice::Context*);

    virtual ::std::string getVersion(const ::Ice::Context*);

    virtual void setSamplerate(::Ice::Int, ::Ice::Float, const ::Ice::Context*);

    virtual ::Ice::Float getSamplerate(::Ice::Int, const ::Ice::Context*);

    virtual void setSMeterCorrection(::Ice::Int, ::Ice::Float, const ::Ice::Context*);

    virtual ::Ice::Float getSMeterCorrection(::Ice::Int, const ::Ice::Context*);

    virtual ::Ice::Float getSMeterInstantaneous(::Ice::Int, const ::Ice::Context*);

    virtual ::Ice::Float getSMeterAverage(::Ice::Int, const ::Ice::Context*);

    virtual void setSquelchSwitch(::Ice::Int, bool, const ::Ice::Context*);

    virtual bool getSquelchSwitch(::Ice::Int, const ::Ice::Context*);

    virtual void setSquelchThresh(::Ice::Int, ::Ice::Float, const ::Ice::Context*);

    virtual ::Ice::Float getSquelchThresh(::Ice::Int, const ::Ice::Context*);

    virtual void setStart(bool, const ::Ice::Context*);

    virtual bool getStart(const ::Ice::Context*);

    virtual void setStop(bool, const ::Ice::Context*);

    virtual bool getStop(const ::Ice::Context*);

    virtual void setVolume(::Ice::Int, ::Ice::Float, ::Ice::Float, const ::Ice::Context*);

    virtual void setVolumeLeft(::Ice::Int, ::Ice::Float, const ::Ice::Context*);

    virtual ::Ice::Float getVolumeLeft(::Ice::Int, const ::Ice::Context*);

    virtual void setVolumeRight(::Ice::Int, ::Ice::Float, const ::Ice::Context*);

    virtual ::Ice::Float getVolumeRight(::Ice::Int, ::Ice::Float, const ::Ice::Context*);

    virtual void setLoadFirmware(bool, const ::Ice::Context*);

    virtual void setLoadFpga(bool, const ::Ice::Context*);

    virtual ::std::string getFpgaFileId(const ::Ice::Context*);

    virtual ::std::string getFirmwareFileName(const ::Ice::Context*);

    virtual ::std::string getFpgaRbfName(const ::Ice::Context*);

    virtual ::std::string getDateTime(const ::Ice::Context*);
};

class PowerSpectrumData : virtual public ::IceDelegate::QS1R::PowerSpectrumData,
                          virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual ::QS1R::SpecBuffer getSpecData(::Ice::Int, const ::Ice::Context*);

    virtual ::Ice::Int getSpecDataSize(::Ice::Int, const ::Ice::Context*);
};

class MeterData : virtual public ::IceDelegate::QS1R::MeterData,
                  virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual ::QS1R::MeterDataStruct getMeterData(::Ice::Int, const ::Ice::Context*);
};

}

}

namespace IceDelegateD
{

namespace QS1R
{

class RadioCommander : virtual public ::IceDelegate::QS1R::RadioCommander,
                       virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual void setAgcMode(::Ice::Int, ::QS1R::AGCMODE, const ::Ice::Context*);

    virtual ::QS1R::AGCMODE getAgcMode(::Ice::Int, const ::Ice::Context*);

    virtual void setAgcMaxGain(::Ice::Int, ::Ice::Float, const ::Ice::Context*);

    virtual ::Ice::Float getAgcMaxGain(::Ice::Int, const ::Ice::Context*);

    virtual void setAgcFixedGain(::Ice::Int, ::Ice::Float, const ::Ice::Context*);

    virtual ::Ice::Float getAgcFixedGain(::Ice::Int, const ::Ice::Context*);

    virtual void setAgcAttack(::Ice::Int, ::Ice::Float, const ::Ice::Context*);

    virtual ::Ice::Float getAgcAttack(::Ice::Int, const ::Ice::Context*);

    virtual void setAgcDecay(::Ice::Int, ::Ice::Float, const ::Ice::Context*);

    virtual ::Ice::Float getAgcDecay(::Ice::Int, const ::Ice::Context*);

    virtual void setAgcHangTime(::Ice::Int, ::Ice::Float, const ::Ice::Context*);

    virtual ::Ice::Float getAgcHangTime(::Ice::Int, const ::Ice::Context*);

    virtual void setAgcHangThresh(::Ice::Int, ::Ice::Float, const ::Ice::Context*);

    virtual ::Ice::Float getAgcHangThresh(::Ice::Int, const ::Ice::Context*);

    virtual void setAgcSlope(::Ice::Int, ::Ice::Float, const ::Ice::Context*);

    virtual ::Ice::Float getAgcSlope(::Ice::Int, const ::Ice::Context*);

    virtual ::Ice::Float getAgcFastGain(::Ice::Int, const ::Ice::Context*);

    virtual ::Ice::Float getAgcCurrentGain(::Ice::Int, const ::Ice::Context*);

    virtual void setAnfSwitch(::Ice::Int, bool, const ::Ice::Context*);

    virtual bool getAnfSwitch(::Ice::Int, const ::Ice::Context*);

    virtual void setAnfDelay(::Ice::Int, ::Ice::Int, const ::Ice::Context*);

    virtual ::Ice::Int getAnfDelay(::Ice::Int, const ::Ice::Context*);

    virtual void setAnfTaps(::Ice::Int, ::Ice::Int, const ::Ice::Context*);

    virtual ::Ice::Int getAnfTaps(::Ice::Int, const ::Ice::Context*);

    virtual void setAnfGain(::Ice::Int, ::Ice::Float, const ::Ice::Context*);

    virtual ::Ice::Float getAnfGain(::Ice::Int, const ::Ice::Context*);

    virtual void setAnfLeak(::Ice::Int, ::Ice::Float, const ::Ice::Context*);

    virtual ::Ice::Float getAnfLeak(::Ice::Int, const ::Ice::Context*);

    virtual void setBinaural(bool, const ::Ice::Context*);

    virtual bool getBinaural(const ::Ice::Context*);

    virtual void setBlockSize(::Ice::Int, const ::Ice::Context*);

    virtual ::Ice::Int getBlockSize(const ::Ice::Context*);

    virtual void setDemodMode(::Ice::Int, ::QS1R::DEMODMODE, const ::Ice::Context*);

    virtual ::QS1R::DEMODMODE getDemodMode(::Ice::Int, const ::Ice::Context*);

    virtual void setControlRegister(::Ice::Int, const ::Ice::Context*);

    virtual ::Ice::Int getControlRegister(const ::Ice::Context*);

    virtual void setDecimationRegister(::Ice::Int, ::Ice::Int, const ::Ice::Context*);

    virtual ::Ice::Int getDecimationRegister(::Ice::Int, const ::Ice::Context*);

    virtual void setScalingRegister(::Ice::Int, ::Ice::Int, const ::Ice::Context*);

    virtual ::Ice::Int getScalingRegister(::Ice::Int, const ::Ice::Context*);

    virtual ::std::string getEepromEncFreqRegister(const ::Ice::Context*);

    virtual void setDither(bool, const ::Ice::Context*);

    virtual bool getDither(const ::Ice::Context*);

    virtual void setEncodeFreq(::Ice::Float, const ::Ice::Context*);

    virtual ::Ice::Float getEncodeFreq(const ::Ice::Context*);

    virtual void setMeterCalibrationOffset(::Ice::Float, const ::Ice::Context*);

    virtual ::Ice::Float getMeterCalibrationOffset(const ::Ice::Context*);

    virtual void setSpectrumCalibrationOffset(::Ice::Float, const ::Ice::Context*);

    virtual ::Ice::Float getSpectrumCalibrationOffset(const ::Ice::Context*);

    virtual void setNrSwitch(::Ice::Int, bool, const ::Ice::Context*);

    virtual bool getNrSwitch(::Ice::Int, const ::Ice::Context*);

    virtual void setNrTaps(::Ice::Int, ::Ice::Int, const ::Ice::Context*);

    virtual ::Ice::Int getNrTaps(::Ice::Int, const ::Ice::Context*);

    virtual void setNrDelay(::Ice::Int, ::Ice::Int, const ::Ice::Context*);

    virtual ::Ice::Int getNrDelay(::Ice::Int, const ::Ice::Context*);

    virtual void setNrGain(::Ice::Int, ::Ice::Float, const ::Ice::Context*);

    virtual ::Ice::Float getNrGain(::Ice::Int, const ::Ice::Context*);

    virtual void setNrLeak(::Ice::Int, ::Ice::Float, const ::Ice::Context*);

    virtual ::Ice::Float getNrLeak(::Ice::Int, const ::Ice::Context*);

    virtual void setExit(bool, const ::Ice::Context*);

    virtual void setFrequency(::Ice::Int, ::Ice::Float, const ::Ice::Context*);

    virtual ::Ice::Float getFrequency(::Ice::Int, const ::Ice::Context*);

    virtual void setFilterLo(::Ice::Int, ::Ice::Float, const ::Ice::Context*);

    virtual ::Ice::Float getFilterLo(::Ice::Int, const ::Ice::Context*);

    virtual void setFilterHi(::Ice::Int, ::Ice::Float, const ::Ice::Context*);

    virtual ::Ice::Float getFilterHi(::Ice::Int, const ::Ice::Context*);

    virtual void setFilter(::Ice::Int, ::Ice::Float, ::Ice::Float, const ::Ice::Context*);

    virtual void setMute(::Ice::Int, bool, const ::Ice::Context*);

    virtual bool getMute(::Ice::Int, const ::Ice::Context*);

    virtual void setNb1Switch(::Ice::Int, bool, const ::Ice::Context*);

    virtual void setNb1Thresh(::Ice::Int, ::Ice::Int, const ::Ice::Context*);

    virtual bool getNb1Switch(::Ice::Int, const ::Ice::Context*);

    virtual ::Ice::Int getNb1Thresh(::Ice::Int, const ::Ice::Context*);

    virtual void setNb2Switch(::Ice::Int, bool, const ::Ice::Context*);

    virtual void setNb2Thresh(::Ice::Int, ::Ice::Int, const ::Ice::Context*);

    virtual bool getNb2Switch(::Ice::Int, const ::Ice::Context*);

    virtual ::Ice::Int getNb2Thresh(::Ice::Int, const ::Ice::Context*);

    virtual void setPga(bool, const ::Ice::Context*);

    virtual bool getPga(const ::Ice::Context*);

    virtual void setInbandPsSwitch(::Ice::Int, bool, const ::Ice::Context*);

    virtual bool getInbandPsSwitch(::Ice::Int, const ::Ice::Context*);

    virtual ::Ice::Int getInbandPsSize(::Ice::Int, const ::Ice::Context*);

    virtual void setOutbandPsSwitch(::Ice::Int, bool, const ::Ice::Context*);

    virtual bool getOutbandPsSwitch(::Ice::Int, const ::Ice::Context*);

    virtual ::Ice::Int getOutbandPsSize(::Ice::Int, const ::Ice::Context*);

    virtual ::std::string getSpectrumBandwidth(::Ice::Int, const ::Ice::Context*);

    virtual void setSpectrumBandwidth(::Ice::Int, const ::std::string&, const ::Ice::Context*);

    virtual ::std::string getSpectrumBandwidths(::Ice::Int, const ::Ice::Context*);

    virtual void setRand(bool, const ::Ice::Context*);

    virtual bool getRand(const ::Ice::Context*);

    virtual ::std::string getVersion(const ::Ice::Context*);

    virtual void setSamplerate(::Ice::Int, ::Ice::Float, const ::Ice::Context*);

    virtual ::Ice::Float getSamplerate(::Ice::Int, const ::Ice::Context*);

    virtual void setSMeterCorrection(::Ice::Int, ::Ice::Float, const ::Ice::Context*);

    virtual ::Ice::Float getSMeterCorrection(::Ice::Int, const ::Ice::Context*);

    virtual ::Ice::Float getSMeterInstantaneous(::Ice::Int, const ::Ice::Context*);

    virtual ::Ice::Float getSMeterAverage(::Ice::Int, const ::Ice::Context*);

    virtual void setSquelchSwitch(::Ice::Int, bool, const ::Ice::Context*);

    virtual bool getSquelchSwitch(::Ice::Int, const ::Ice::Context*);

    virtual void setSquelchThresh(::Ice::Int, ::Ice::Float, const ::Ice::Context*);

    virtual ::Ice::Float getSquelchThresh(::Ice::Int, const ::Ice::Context*);

    virtual void setStart(bool, const ::Ice::Context*);

    virtual bool getStart(const ::Ice::Context*);

    virtual void setStop(bool, const ::Ice::Context*);

    virtual bool getStop(const ::Ice::Context*);

    virtual void setVolume(::Ice::Int, ::Ice::Float, ::Ice::Float, const ::Ice::Context*);

    virtual void setVolumeLeft(::Ice::Int, ::Ice::Float, const ::Ice::Context*);

    virtual ::Ice::Float getVolumeLeft(::Ice::Int, const ::Ice::Context*);

    virtual void setVolumeRight(::Ice::Int, ::Ice::Float, const ::Ice::Context*);

    virtual ::Ice::Float getVolumeRight(::Ice::Int, ::Ice::Float, const ::Ice::Context*);

    virtual void setLoadFirmware(bool, const ::Ice::Context*);

    virtual void setLoadFpga(bool, const ::Ice::Context*);

    virtual ::std::string getFpgaFileId(const ::Ice::Context*);

    virtual ::std::string getFirmwareFileName(const ::Ice::Context*);

    virtual ::std::string getFpgaRbfName(const ::Ice::Context*);

    virtual ::std::string getDateTime(const ::Ice::Context*);
};

class PowerSpectrumData : virtual public ::IceDelegate::QS1R::PowerSpectrumData,
                          virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual ::QS1R::SpecBuffer getSpecData(::Ice::Int, const ::Ice::Context*);

    virtual ::Ice::Int getSpecDataSize(::Ice::Int, const ::Ice::Context*);
};

class MeterData : virtual public ::IceDelegate::QS1R::MeterData,
                  virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual ::QS1R::MeterDataStruct getMeterData(::Ice::Int, const ::Ice::Context*);
};

}

}

namespace QS1R
{

class RadioCommander : virtual public ::Ice::Object
{
public:

    typedef RadioCommanderPrx ProxyType;
    typedef RadioCommanderPtr PointerType;
    
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void setAgcMode(::Ice::Int, ::QS1R::AGCMODE, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setAgcMode(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::QS1R::AGCMODE getAgcMode(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getAgcMode(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setAgcMaxGain(::Ice::Int, ::Ice::Float, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setAgcMaxGain(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Float getAgcMaxGain(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getAgcMaxGain(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setAgcFixedGain(::Ice::Int, ::Ice::Float, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setAgcFixedGain(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Float getAgcFixedGain(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getAgcFixedGain(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setAgcAttack(::Ice::Int, ::Ice::Float, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setAgcAttack(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Float getAgcAttack(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getAgcAttack(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setAgcDecay(::Ice::Int, ::Ice::Float, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setAgcDecay(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Float getAgcDecay(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getAgcDecay(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setAgcHangTime(::Ice::Int, ::Ice::Float, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setAgcHangTime(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Float getAgcHangTime(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getAgcHangTime(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setAgcHangThresh(::Ice::Int, ::Ice::Float, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setAgcHangThresh(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Float getAgcHangThresh(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getAgcHangThresh(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setAgcSlope(::Ice::Int, ::Ice::Float, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setAgcSlope(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Float getAgcSlope(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getAgcSlope(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Float getAgcFastGain(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getAgcFastGain(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Float getAgcCurrentGain(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getAgcCurrentGain(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setAnfSwitch(::Ice::Int, bool, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setAnfSwitch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool getAnfSwitch(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getAnfSwitch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setAnfDelay(::Ice::Int, ::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setAnfDelay(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int getAnfDelay(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getAnfDelay(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setAnfTaps(::Ice::Int, ::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setAnfTaps(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int getAnfTaps(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getAnfTaps(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setAnfGain(::Ice::Int, ::Ice::Float, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setAnfGain(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Float getAnfGain(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getAnfGain(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setAnfLeak(::Ice::Int, ::Ice::Float, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setAnfLeak(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Float getAnfLeak(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getAnfLeak(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setBinaural(bool, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setBinaural(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool getBinaural(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getBinaural(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setBlockSize(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setBlockSize(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int getBlockSize(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getBlockSize(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setDemodMode(::Ice::Int, ::QS1R::DEMODMODE, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setDemodMode(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::QS1R::DEMODMODE getDemodMode(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getDemodMode(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setControlRegister(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setControlRegister(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int getControlRegister(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getControlRegister(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setDecimationRegister(::Ice::Int, ::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setDecimationRegister(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int getDecimationRegister(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getDecimationRegister(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setScalingRegister(::Ice::Int, ::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setScalingRegister(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int getScalingRegister(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getScalingRegister(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string getEepromEncFreqRegister(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getEepromEncFreqRegister(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setDither(bool, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setDither(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool getDither(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getDither(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setEncodeFreq(::Ice::Float, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setEncodeFreq(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Float getEncodeFreq(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getEncodeFreq(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setMeterCalibrationOffset(::Ice::Float, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setMeterCalibrationOffset(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Float getMeterCalibrationOffset(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getMeterCalibrationOffset(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setSpectrumCalibrationOffset(::Ice::Float, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setSpectrumCalibrationOffset(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Float getSpectrumCalibrationOffset(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getSpectrumCalibrationOffset(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setNrSwitch(::Ice::Int, bool, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setNrSwitch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool getNrSwitch(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getNrSwitch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setNrTaps(::Ice::Int, ::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setNrTaps(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int getNrTaps(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getNrTaps(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setNrDelay(::Ice::Int, ::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setNrDelay(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int getNrDelay(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getNrDelay(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setNrGain(::Ice::Int, ::Ice::Float, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setNrGain(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Float getNrGain(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getNrGain(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setNrLeak(::Ice::Int, ::Ice::Float, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setNrLeak(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Float getNrLeak(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getNrLeak(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setExit(bool, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setExit(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setFrequency(::Ice::Int, ::Ice::Float, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setFrequency(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Float getFrequency(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getFrequency(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setFilterLo(::Ice::Int, ::Ice::Float, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setFilterLo(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Float getFilterLo(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getFilterLo(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setFilterHi(::Ice::Int, ::Ice::Float, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setFilterHi(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Float getFilterHi(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getFilterHi(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setFilter(::Ice::Int, ::Ice::Float, ::Ice::Float, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setFilter(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setMute(::Ice::Int, bool, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setMute(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool getMute(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getMute(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setNb1Switch(::Ice::Int, bool, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setNb1Switch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setNb1Thresh(::Ice::Int, ::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setNb1Thresh(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool getNb1Switch(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getNb1Switch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int getNb1Thresh(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getNb1Thresh(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setNb2Switch(::Ice::Int, bool, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setNb2Switch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setNb2Thresh(::Ice::Int, ::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setNb2Thresh(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool getNb2Switch(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getNb2Switch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int getNb2Thresh(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getNb2Thresh(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setPga(bool, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setPga(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool getPga(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getPga(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setInbandPsSwitch(::Ice::Int, bool, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setInbandPsSwitch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool getInbandPsSwitch(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getInbandPsSwitch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int getInbandPsSize(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getInbandPsSize(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setOutbandPsSwitch(::Ice::Int, bool, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setOutbandPsSwitch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool getOutbandPsSwitch(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getOutbandPsSwitch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int getOutbandPsSize(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getOutbandPsSize(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string getSpectrumBandwidth(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getSpectrumBandwidth(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setSpectrumBandwidth(::Ice::Int, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setSpectrumBandwidth(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string getSpectrumBandwidths(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getSpectrumBandwidths(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setRand(bool, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setRand(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool getRand(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getRand(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string getVersion(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getVersion(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setSamplerate(::Ice::Int, ::Ice::Float, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setSamplerate(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Float getSamplerate(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getSamplerate(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setSMeterCorrection(::Ice::Int, ::Ice::Float, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setSMeterCorrection(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Float getSMeterCorrection(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getSMeterCorrection(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Float getSMeterInstantaneous(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getSMeterInstantaneous(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Float getSMeterAverage(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getSMeterAverage(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setSquelchSwitch(::Ice::Int, bool, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setSquelchSwitch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool getSquelchSwitch(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getSquelchSwitch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setSquelchThresh(::Ice::Int, ::Ice::Float, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setSquelchThresh(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Float getSquelchThresh(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getSquelchThresh(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setStart(bool, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setStart(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool getStart(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getStart(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setStop(bool, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setStop(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool getStop(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getStop(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setVolume(::Ice::Int, ::Ice::Float, ::Ice::Float, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setVolume(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setVolumeLeft(::Ice::Int, ::Ice::Float, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setVolumeLeft(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Float getVolumeLeft(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getVolumeLeft(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setVolumeRight(::Ice::Int, ::Ice::Float, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setVolumeRight(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Float getVolumeRight(::Ice::Int, ::Ice::Float, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getVolumeRight(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setLoadFirmware(bool, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setLoadFirmware(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setLoadFpga(bool, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setLoadFpga(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string getFpgaFileId(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getFpgaFileId(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string getFirmwareFileName(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getFirmwareFileName(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string getFpgaRbfName(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getFpgaRbfName(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string getDateTime(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getDateTime(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

inline bool operator==(const RadioCommander& l, const RadioCommander& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const RadioCommander& l, const RadioCommander& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class PowerSpectrumData : virtual public ::Ice::Object
{
public:

    typedef PowerSpectrumDataPrx ProxyType;
    typedef PowerSpectrumDataPtr PointerType;
    
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual ::QS1R::SpecBuffer getSpecData(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getSpecData(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int getSpecDataSize(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getSpecDataSize(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

inline bool operator==(const PowerSpectrumData& l, const PowerSpectrumData& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const PowerSpectrumData& l, const PowerSpectrumData& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class MeterData : virtual public ::Ice::Object
{
public:

    typedef MeterDataPrx ProxyType;
    typedef MeterDataPtr PointerType;
    
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual ::QS1R::MeterDataStruct getMeterData(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getMeterData(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

inline bool operator==(const MeterData& l, const MeterData& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const MeterData& l, const MeterData& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

namespace QS1R
{

template<class T>
class CallbackNC_RadioCommander_setAgcMode : public Callback_RadioCommander_setAgcMode_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setAgcMode(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setAgcModePtr
newCallback_RadioCommander_setAgcMode(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAgcMode<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setAgcModePtr
newCallback_RadioCommander_setAgcMode(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAgcMode<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setAgcModePtr
newCallback_RadioCommander_setAgcMode(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAgcMode<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setAgcModePtr
newCallback_RadioCommander_setAgcMode(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAgcMode<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setAgcMode : public Callback_RadioCommander_setAgcMode_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setAgcMode(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setAgcModePtr
newCallback_RadioCommander_setAgcMode(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAgcMode<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setAgcModePtr
newCallback_RadioCommander_setAgcMode(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAgcMode<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setAgcModePtr
newCallback_RadioCommander_setAgcMode(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAgcMode<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setAgcModePtr
newCallback_RadioCommander_setAgcMode(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAgcMode<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getAgcMode : public Callback_RadioCommander_getAgcMode_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::QS1R::AGCMODE);

    CallbackNC_RadioCommander_getAgcMode(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::QS1R::AGCMODE __ret;
        try
        {
            __ret = __proxy->end_getAgcMode(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getAgcModePtr
newCallback_RadioCommander_getAgcMode(const IceUtil::Handle<T>& instance, void (T::*cb)(::QS1R::AGCMODE), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getAgcMode<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getAgcModePtr
newCallback_RadioCommander_getAgcMode(T* instance, void (T::*cb)(::QS1R::AGCMODE), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getAgcMode<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getAgcMode : public Callback_RadioCommander_getAgcMode_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::QS1R::AGCMODE, const CT&);

    Callback_RadioCommander_getAgcMode(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::QS1R::AGCMODE __ret;
        try
        {
            __ret = __proxy->end_getAgcMode(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getAgcModePtr
newCallback_RadioCommander_getAgcMode(const IceUtil::Handle<T>& instance, void (T::*cb)(::QS1R::AGCMODE, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getAgcMode<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getAgcModePtr
newCallback_RadioCommander_getAgcMode(T* instance, void (T::*cb)(::QS1R::AGCMODE, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getAgcMode<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setAgcMaxGain : public Callback_RadioCommander_setAgcMaxGain_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setAgcMaxGain(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setAgcMaxGainPtr
newCallback_RadioCommander_setAgcMaxGain(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAgcMaxGain<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setAgcMaxGainPtr
newCallback_RadioCommander_setAgcMaxGain(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAgcMaxGain<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setAgcMaxGainPtr
newCallback_RadioCommander_setAgcMaxGain(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAgcMaxGain<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setAgcMaxGainPtr
newCallback_RadioCommander_setAgcMaxGain(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAgcMaxGain<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setAgcMaxGain : public Callback_RadioCommander_setAgcMaxGain_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setAgcMaxGain(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setAgcMaxGainPtr
newCallback_RadioCommander_setAgcMaxGain(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAgcMaxGain<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setAgcMaxGainPtr
newCallback_RadioCommander_setAgcMaxGain(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAgcMaxGain<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setAgcMaxGainPtr
newCallback_RadioCommander_setAgcMaxGain(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAgcMaxGain<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setAgcMaxGainPtr
newCallback_RadioCommander_setAgcMaxGain(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAgcMaxGain<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getAgcMaxGain : public Callback_RadioCommander_getAgcMaxGain_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Float);

    CallbackNC_RadioCommander_getAgcMaxGain(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getAgcMaxGain(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getAgcMaxGainPtr
newCallback_RadioCommander_getAgcMaxGain(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getAgcMaxGain<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getAgcMaxGainPtr
newCallback_RadioCommander_getAgcMaxGain(T* instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getAgcMaxGain<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getAgcMaxGain : public Callback_RadioCommander_getAgcMaxGain_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Float, const CT&);

    Callback_RadioCommander_getAgcMaxGain(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getAgcMaxGain(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getAgcMaxGainPtr
newCallback_RadioCommander_getAgcMaxGain(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getAgcMaxGain<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getAgcMaxGainPtr
newCallback_RadioCommander_getAgcMaxGain(T* instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getAgcMaxGain<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setAgcFixedGain : public Callback_RadioCommander_setAgcFixedGain_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setAgcFixedGain(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setAgcFixedGainPtr
newCallback_RadioCommander_setAgcFixedGain(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAgcFixedGain<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setAgcFixedGainPtr
newCallback_RadioCommander_setAgcFixedGain(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAgcFixedGain<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setAgcFixedGainPtr
newCallback_RadioCommander_setAgcFixedGain(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAgcFixedGain<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setAgcFixedGainPtr
newCallback_RadioCommander_setAgcFixedGain(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAgcFixedGain<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setAgcFixedGain : public Callback_RadioCommander_setAgcFixedGain_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setAgcFixedGain(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setAgcFixedGainPtr
newCallback_RadioCommander_setAgcFixedGain(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAgcFixedGain<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setAgcFixedGainPtr
newCallback_RadioCommander_setAgcFixedGain(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAgcFixedGain<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setAgcFixedGainPtr
newCallback_RadioCommander_setAgcFixedGain(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAgcFixedGain<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setAgcFixedGainPtr
newCallback_RadioCommander_setAgcFixedGain(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAgcFixedGain<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getAgcFixedGain : public Callback_RadioCommander_getAgcFixedGain_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Float);

    CallbackNC_RadioCommander_getAgcFixedGain(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getAgcFixedGain(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getAgcFixedGainPtr
newCallback_RadioCommander_getAgcFixedGain(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getAgcFixedGain<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getAgcFixedGainPtr
newCallback_RadioCommander_getAgcFixedGain(T* instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getAgcFixedGain<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getAgcFixedGain : public Callback_RadioCommander_getAgcFixedGain_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Float, const CT&);

    Callback_RadioCommander_getAgcFixedGain(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getAgcFixedGain(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getAgcFixedGainPtr
newCallback_RadioCommander_getAgcFixedGain(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getAgcFixedGain<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getAgcFixedGainPtr
newCallback_RadioCommander_getAgcFixedGain(T* instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getAgcFixedGain<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setAgcAttack : public Callback_RadioCommander_setAgcAttack_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setAgcAttack(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setAgcAttackPtr
newCallback_RadioCommander_setAgcAttack(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAgcAttack<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setAgcAttackPtr
newCallback_RadioCommander_setAgcAttack(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAgcAttack<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setAgcAttackPtr
newCallback_RadioCommander_setAgcAttack(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAgcAttack<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setAgcAttackPtr
newCallback_RadioCommander_setAgcAttack(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAgcAttack<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setAgcAttack : public Callback_RadioCommander_setAgcAttack_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setAgcAttack(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setAgcAttackPtr
newCallback_RadioCommander_setAgcAttack(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAgcAttack<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setAgcAttackPtr
newCallback_RadioCommander_setAgcAttack(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAgcAttack<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setAgcAttackPtr
newCallback_RadioCommander_setAgcAttack(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAgcAttack<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setAgcAttackPtr
newCallback_RadioCommander_setAgcAttack(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAgcAttack<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getAgcAttack : public Callback_RadioCommander_getAgcAttack_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Float);

    CallbackNC_RadioCommander_getAgcAttack(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getAgcAttack(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getAgcAttackPtr
newCallback_RadioCommander_getAgcAttack(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getAgcAttack<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getAgcAttackPtr
newCallback_RadioCommander_getAgcAttack(T* instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getAgcAttack<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getAgcAttack : public Callback_RadioCommander_getAgcAttack_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Float, const CT&);

    Callback_RadioCommander_getAgcAttack(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getAgcAttack(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getAgcAttackPtr
newCallback_RadioCommander_getAgcAttack(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getAgcAttack<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getAgcAttackPtr
newCallback_RadioCommander_getAgcAttack(T* instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getAgcAttack<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setAgcDecay : public Callback_RadioCommander_setAgcDecay_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setAgcDecay(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setAgcDecayPtr
newCallback_RadioCommander_setAgcDecay(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAgcDecay<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setAgcDecayPtr
newCallback_RadioCommander_setAgcDecay(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAgcDecay<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setAgcDecayPtr
newCallback_RadioCommander_setAgcDecay(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAgcDecay<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setAgcDecayPtr
newCallback_RadioCommander_setAgcDecay(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAgcDecay<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setAgcDecay : public Callback_RadioCommander_setAgcDecay_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setAgcDecay(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setAgcDecayPtr
newCallback_RadioCommander_setAgcDecay(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAgcDecay<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setAgcDecayPtr
newCallback_RadioCommander_setAgcDecay(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAgcDecay<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setAgcDecayPtr
newCallback_RadioCommander_setAgcDecay(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAgcDecay<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setAgcDecayPtr
newCallback_RadioCommander_setAgcDecay(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAgcDecay<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getAgcDecay : public Callback_RadioCommander_getAgcDecay_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Float);

    CallbackNC_RadioCommander_getAgcDecay(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getAgcDecay(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getAgcDecayPtr
newCallback_RadioCommander_getAgcDecay(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getAgcDecay<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getAgcDecayPtr
newCallback_RadioCommander_getAgcDecay(T* instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getAgcDecay<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getAgcDecay : public Callback_RadioCommander_getAgcDecay_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Float, const CT&);

    Callback_RadioCommander_getAgcDecay(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getAgcDecay(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getAgcDecayPtr
newCallback_RadioCommander_getAgcDecay(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getAgcDecay<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getAgcDecayPtr
newCallback_RadioCommander_getAgcDecay(T* instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getAgcDecay<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setAgcHangTime : public Callback_RadioCommander_setAgcHangTime_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setAgcHangTime(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setAgcHangTimePtr
newCallback_RadioCommander_setAgcHangTime(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAgcHangTime<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setAgcHangTimePtr
newCallback_RadioCommander_setAgcHangTime(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAgcHangTime<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setAgcHangTimePtr
newCallback_RadioCommander_setAgcHangTime(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAgcHangTime<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setAgcHangTimePtr
newCallback_RadioCommander_setAgcHangTime(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAgcHangTime<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setAgcHangTime : public Callback_RadioCommander_setAgcHangTime_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setAgcHangTime(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setAgcHangTimePtr
newCallback_RadioCommander_setAgcHangTime(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAgcHangTime<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setAgcHangTimePtr
newCallback_RadioCommander_setAgcHangTime(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAgcHangTime<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setAgcHangTimePtr
newCallback_RadioCommander_setAgcHangTime(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAgcHangTime<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setAgcHangTimePtr
newCallback_RadioCommander_setAgcHangTime(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAgcHangTime<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getAgcHangTime : public Callback_RadioCommander_getAgcHangTime_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Float);

    CallbackNC_RadioCommander_getAgcHangTime(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getAgcHangTime(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getAgcHangTimePtr
newCallback_RadioCommander_getAgcHangTime(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getAgcHangTime<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getAgcHangTimePtr
newCallback_RadioCommander_getAgcHangTime(T* instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getAgcHangTime<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getAgcHangTime : public Callback_RadioCommander_getAgcHangTime_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Float, const CT&);

    Callback_RadioCommander_getAgcHangTime(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getAgcHangTime(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getAgcHangTimePtr
newCallback_RadioCommander_getAgcHangTime(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getAgcHangTime<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getAgcHangTimePtr
newCallback_RadioCommander_getAgcHangTime(T* instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getAgcHangTime<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setAgcHangThresh : public Callback_RadioCommander_setAgcHangThresh_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setAgcHangThresh(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setAgcHangThreshPtr
newCallback_RadioCommander_setAgcHangThresh(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAgcHangThresh<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setAgcHangThreshPtr
newCallback_RadioCommander_setAgcHangThresh(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAgcHangThresh<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setAgcHangThreshPtr
newCallback_RadioCommander_setAgcHangThresh(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAgcHangThresh<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setAgcHangThreshPtr
newCallback_RadioCommander_setAgcHangThresh(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAgcHangThresh<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setAgcHangThresh : public Callback_RadioCommander_setAgcHangThresh_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setAgcHangThresh(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setAgcHangThreshPtr
newCallback_RadioCommander_setAgcHangThresh(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAgcHangThresh<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setAgcHangThreshPtr
newCallback_RadioCommander_setAgcHangThresh(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAgcHangThresh<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setAgcHangThreshPtr
newCallback_RadioCommander_setAgcHangThresh(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAgcHangThresh<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setAgcHangThreshPtr
newCallback_RadioCommander_setAgcHangThresh(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAgcHangThresh<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getAgcHangThresh : public Callback_RadioCommander_getAgcHangThresh_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Float);

    CallbackNC_RadioCommander_getAgcHangThresh(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getAgcHangThresh(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getAgcHangThreshPtr
newCallback_RadioCommander_getAgcHangThresh(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getAgcHangThresh<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getAgcHangThreshPtr
newCallback_RadioCommander_getAgcHangThresh(T* instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getAgcHangThresh<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getAgcHangThresh : public Callback_RadioCommander_getAgcHangThresh_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Float, const CT&);

    Callback_RadioCommander_getAgcHangThresh(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getAgcHangThresh(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getAgcHangThreshPtr
newCallback_RadioCommander_getAgcHangThresh(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getAgcHangThresh<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getAgcHangThreshPtr
newCallback_RadioCommander_getAgcHangThresh(T* instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getAgcHangThresh<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setAgcSlope : public Callback_RadioCommander_setAgcSlope_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setAgcSlope(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setAgcSlopePtr
newCallback_RadioCommander_setAgcSlope(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAgcSlope<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setAgcSlopePtr
newCallback_RadioCommander_setAgcSlope(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAgcSlope<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setAgcSlopePtr
newCallback_RadioCommander_setAgcSlope(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAgcSlope<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setAgcSlopePtr
newCallback_RadioCommander_setAgcSlope(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAgcSlope<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setAgcSlope : public Callback_RadioCommander_setAgcSlope_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setAgcSlope(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setAgcSlopePtr
newCallback_RadioCommander_setAgcSlope(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAgcSlope<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setAgcSlopePtr
newCallback_RadioCommander_setAgcSlope(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAgcSlope<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setAgcSlopePtr
newCallback_RadioCommander_setAgcSlope(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAgcSlope<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setAgcSlopePtr
newCallback_RadioCommander_setAgcSlope(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAgcSlope<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getAgcSlope : public Callback_RadioCommander_getAgcSlope_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Float);

    CallbackNC_RadioCommander_getAgcSlope(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getAgcSlope(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getAgcSlopePtr
newCallback_RadioCommander_getAgcSlope(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getAgcSlope<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getAgcSlopePtr
newCallback_RadioCommander_getAgcSlope(T* instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getAgcSlope<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getAgcSlope : public Callback_RadioCommander_getAgcSlope_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Float, const CT&);

    Callback_RadioCommander_getAgcSlope(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getAgcSlope(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getAgcSlopePtr
newCallback_RadioCommander_getAgcSlope(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getAgcSlope<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getAgcSlopePtr
newCallback_RadioCommander_getAgcSlope(T* instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getAgcSlope<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getAgcFastGain : public Callback_RadioCommander_getAgcFastGain_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Float);

    CallbackNC_RadioCommander_getAgcFastGain(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getAgcFastGain(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getAgcFastGainPtr
newCallback_RadioCommander_getAgcFastGain(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getAgcFastGain<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getAgcFastGainPtr
newCallback_RadioCommander_getAgcFastGain(T* instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getAgcFastGain<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getAgcFastGain : public Callback_RadioCommander_getAgcFastGain_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Float, const CT&);

    Callback_RadioCommander_getAgcFastGain(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getAgcFastGain(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getAgcFastGainPtr
newCallback_RadioCommander_getAgcFastGain(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getAgcFastGain<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getAgcFastGainPtr
newCallback_RadioCommander_getAgcFastGain(T* instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getAgcFastGain<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getAgcCurrentGain : public Callback_RadioCommander_getAgcCurrentGain_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Float);

    CallbackNC_RadioCommander_getAgcCurrentGain(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getAgcCurrentGain(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getAgcCurrentGainPtr
newCallback_RadioCommander_getAgcCurrentGain(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getAgcCurrentGain<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getAgcCurrentGainPtr
newCallback_RadioCommander_getAgcCurrentGain(T* instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getAgcCurrentGain<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getAgcCurrentGain : public Callback_RadioCommander_getAgcCurrentGain_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Float, const CT&);

    Callback_RadioCommander_getAgcCurrentGain(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getAgcCurrentGain(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getAgcCurrentGainPtr
newCallback_RadioCommander_getAgcCurrentGain(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getAgcCurrentGain<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getAgcCurrentGainPtr
newCallback_RadioCommander_getAgcCurrentGain(T* instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getAgcCurrentGain<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setAnfSwitch : public Callback_RadioCommander_setAnfSwitch_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setAnfSwitch(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setAnfSwitchPtr
newCallback_RadioCommander_setAnfSwitch(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAnfSwitch<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setAnfSwitchPtr
newCallback_RadioCommander_setAnfSwitch(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAnfSwitch<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setAnfSwitchPtr
newCallback_RadioCommander_setAnfSwitch(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAnfSwitch<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setAnfSwitchPtr
newCallback_RadioCommander_setAnfSwitch(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAnfSwitch<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setAnfSwitch : public Callback_RadioCommander_setAnfSwitch_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setAnfSwitch(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setAnfSwitchPtr
newCallback_RadioCommander_setAnfSwitch(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAnfSwitch<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setAnfSwitchPtr
newCallback_RadioCommander_setAnfSwitch(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAnfSwitch<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setAnfSwitchPtr
newCallback_RadioCommander_setAnfSwitch(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAnfSwitch<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setAnfSwitchPtr
newCallback_RadioCommander_setAnfSwitch(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAnfSwitch<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getAnfSwitch : public Callback_RadioCommander_getAnfSwitch_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_RadioCommander_getAnfSwitch(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_getAnfSwitch(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getAnfSwitchPtr
newCallback_RadioCommander_getAnfSwitch(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getAnfSwitch<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getAnfSwitchPtr
newCallback_RadioCommander_getAnfSwitch(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getAnfSwitch<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getAnfSwitch : public Callback_RadioCommander_getAnfSwitch_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_RadioCommander_getAnfSwitch(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_getAnfSwitch(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getAnfSwitchPtr
newCallback_RadioCommander_getAnfSwitch(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getAnfSwitch<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getAnfSwitchPtr
newCallback_RadioCommander_getAnfSwitch(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getAnfSwitch<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setAnfDelay : public Callback_RadioCommander_setAnfDelay_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setAnfDelay(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setAnfDelayPtr
newCallback_RadioCommander_setAnfDelay(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAnfDelay<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setAnfDelayPtr
newCallback_RadioCommander_setAnfDelay(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAnfDelay<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setAnfDelayPtr
newCallback_RadioCommander_setAnfDelay(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAnfDelay<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setAnfDelayPtr
newCallback_RadioCommander_setAnfDelay(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAnfDelay<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setAnfDelay : public Callback_RadioCommander_setAnfDelay_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setAnfDelay(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setAnfDelayPtr
newCallback_RadioCommander_setAnfDelay(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAnfDelay<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setAnfDelayPtr
newCallback_RadioCommander_setAnfDelay(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAnfDelay<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setAnfDelayPtr
newCallback_RadioCommander_setAnfDelay(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAnfDelay<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setAnfDelayPtr
newCallback_RadioCommander_setAnfDelay(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAnfDelay<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getAnfDelay : public Callback_RadioCommander_getAnfDelay_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_RadioCommander_getAnfDelay(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getAnfDelay(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getAnfDelayPtr
newCallback_RadioCommander_getAnfDelay(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getAnfDelay<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getAnfDelayPtr
newCallback_RadioCommander_getAnfDelay(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getAnfDelay<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getAnfDelay : public Callback_RadioCommander_getAnfDelay_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_RadioCommander_getAnfDelay(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getAnfDelay(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getAnfDelayPtr
newCallback_RadioCommander_getAnfDelay(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getAnfDelay<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getAnfDelayPtr
newCallback_RadioCommander_getAnfDelay(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getAnfDelay<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setAnfTaps : public Callback_RadioCommander_setAnfTaps_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setAnfTaps(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setAnfTapsPtr
newCallback_RadioCommander_setAnfTaps(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAnfTaps<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setAnfTapsPtr
newCallback_RadioCommander_setAnfTaps(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAnfTaps<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setAnfTapsPtr
newCallback_RadioCommander_setAnfTaps(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAnfTaps<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setAnfTapsPtr
newCallback_RadioCommander_setAnfTaps(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAnfTaps<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setAnfTaps : public Callback_RadioCommander_setAnfTaps_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setAnfTaps(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setAnfTapsPtr
newCallback_RadioCommander_setAnfTaps(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAnfTaps<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setAnfTapsPtr
newCallback_RadioCommander_setAnfTaps(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAnfTaps<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setAnfTapsPtr
newCallback_RadioCommander_setAnfTaps(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAnfTaps<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setAnfTapsPtr
newCallback_RadioCommander_setAnfTaps(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAnfTaps<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getAnfTaps : public Callback_RadioCommander_getAnfTaps_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_RadioCommander_getAnfTaps(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getAnfTaps(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getAnfTapsPtr
newCallback_RadioCommander_getAnfTaps(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getAnfTaps<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getAnfTapsPtr
newCallback_RadioCommander_getAnfTaps(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getAnfTaps<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getAnfTaps : public Callback_RadioCommander_getAnfTaps_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_RadioCommander_getAnfTaps(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getAnfTaps(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getAnfTapsPtr
newCallback_RadioCommander_getAnfTaps(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getAnfTaps<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getAnfTapsPtr
newCallback_RadioCommander_getAnfTaps(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getAnfTaps<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setAnfGain : public Callback_RadioCommander_setAnfGain_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setAnfGain(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setAnfGainPtr
newCallback_RadioCommander_setAnfGain(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAnfGain<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setAnfGainPtr
newCallback_RadioCommander_setAnfGain(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAnfGain<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setAnfGainPtr
newCallback_RadioCommander_setAnfGain(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAnfGain<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setAnfGainPtr
newCallback_RadioCommander_setAnfGain(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAnfGain<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setAnfGain : public Callback_RadioCommander_setAnfGain_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setAnfGain(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setAnfGainPtr
newCallback_RadioCommander_setAnfGain(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAnfGain<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setAnfGainPtr
newCallback_RadioCommander_setAnfGain(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAnfGain<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setAnfGainPtr
newCallback_RadioCommander_setAnfGain(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAnfGain<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setAnfGainPtr
newCallback_RadioCommander_setAnfGain(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAnfGain<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getAnfGain : public Callback_RadioCommander_getAnfGain_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Float);

    CallbackNC_RadioCommander_getAnfGain(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getAnfGain(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getAnfGainPtr
newCallback_RadioCommander_getAnfGain(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getAnfGain<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getAnfGainPtr
newCallback_RadioCommander_getAnfGain(T* instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getAnfGain<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getAnfGain : public Callback_RadioCommander_getAnfGain_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Float, const CT&);

    Callback_RadioCommander_getAnfGain(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getAnfGain(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getAnfGainPtr
newCallback_RadioCommander_getAnfGain(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getAnfGain<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getAnfGainPtr
newCallback_RadioCommander_getAnfGain(T* instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getAnfGain<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setAnfLeak : public Callback_RadioCommander_setAnfLeak_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setAnfLeak(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setAnfLeakPtr
newCallback_RadioCommander_setAnfLeak(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAnfLeak<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setAnfLeakPtr
newCallback_RadioCommander_setAnfLeak(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAnfLeak<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setAnfLeakPtr
newCallback_RadioCommander_setAnfLeak(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAnfLeak<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setAnfLeakPtr
newCallback_RadioCommander_setAnfLeak(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setAnfLeak<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setAnfLeak : public Callback_RadioCommander_setAnfLeak_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setAnfLeak(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setAnfLeakPtr
newCallback_RadioCommander_setAnfLeak(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAnfLeak<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setAnfLeakPtr
newCallback_RadioCommander_setAnfLeak(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAnfLeak<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setAnfLeakPtr
newCallback_RadioCommander_setAnfLeak(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAnfLeak<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setAnfLeakPtr
newCallback_RadioCommander_setAnfLeak(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setAnfLeak<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getAnfLeak : public Callback_RadioCommander_getAnfLeak_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Float);

    CallbackNC_RadioCommander_getAnfLeak(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getAnfLeak(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getAnfLeakPtr
newCallback_RadioCommander_getAnfLeak(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getAnfLeak<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getAnfLeakPtr
newCallback_RadioCommander_getAnfLeak(T* instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getAnfLeak<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getAnfLeak : public Callback_RadioCommander_getAnfLeak_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Float, const CT&);

    Callback_RadioCommander_getAnfLeak(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getAnfLeak(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getAnfLeakPtr
newCallback_RadioCommander_getAnfLeak(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getAnfLeak<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getAnfLeakPtr
newCallback_RadioCommander_getAnfLeak(T* instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getAnfLeak<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setBinaural : public Callback_RadioCommander_setBinaural_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setBinaural(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setBinauralPtr
newCallback_RadioCommander_setBinaural(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setBinaural<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setBinauralPtr
newCallback_RadioCommander_setBinaural(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setBinaural<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setBinauralPtr
newCallback_RadioCommander_setBinaural(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setBinaural<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setBinauralPtr
newCallback_RadioCommander_setBinaural(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setBinaural<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setBinaural : public Callback_RadioCommander_setBinaural_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setBinaural(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setBinauralPtr
newCallback_RadioCommander_setBinaural(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setBinaural<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setBinauralPtr
newCallback_RadioCommander_setBinaural(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setBinaural<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setBinauralPtr
newCallback_RadioCommander_setBinaural(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setBinaural<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setBinauralPtr
newCallback_RadioCommander_setBinaural(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setBinaural<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getBinaural : public Callback_RadioCommander_getBinaural_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_RadioCommander_getBinaural(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_getBinaural(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getBinauralPtr
newCallback_RadioCommander_getBinaural(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getBinaural<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getBinauralPtr
newCallback_RadioCommander_getBinaural(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getBinaural<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getBinaural : public Callback_RadioCommander_getBinaural_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_RadioCommander_getBinaural(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_getBinaural(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getBinauralPtr
newCallback_RadioCommander_getBinaural(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getBinaural<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getBinauralPtr
newCallback_RadioCommander_getBinaural(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getBinaural<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setBlockSize : public Callback_RadioCommander_setBlockSize_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setBlockSize(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setBlockSizePtr
newCallback_RadioCommander_setBlockSize(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setBlockSize<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setBlockSizePtr
newCallback_RadioCommander_setBlockSize(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setBlockSize<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setBlockSizePtr
newCallback_RadioCommander_setBlockSize(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setBlockSize<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setBlockSizePtr
newCallback_RadioCommander_setBlockSize(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setBlockSize<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setBlockSize : public Callback_RadioCommander_setBlockSize_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setBlockSize(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setBlockSizePtr
newCallback_RadioCommander_setBlockSize(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setBlockSize<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setBlockSizePtr
newCallback_RadioCommander_setBlockSize(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setBlockSize<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setBlockSizePtr
newCallback_RadioCommander_setBlockSize(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setBlockSize<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setBlockSizePtr
newCallback_RadioCommander_setBlockSize(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setBlockSize<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getBlockSize : public Callback_RadioCommander_getBlockSize_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_RadioCommander_getBlockSize(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getBlockSize(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getBlockSizePtr
newCallback_RadioCommander_getBlockSize(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getBlockSize<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getBlockSizePtr
newCallback_RadioCommander_getBlockSize(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getBlockSize<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getBlockSize : public Callback_RadioCommander_getBlockSize_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_RadioCommander_getBlockSize(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getBlockSize(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getBlockSizePtr
newCallback_RadioCommander_getBlockSize(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getBlockSize<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getBlockSizePtr
newCallback_RadioCommander_getBlockSize(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getBlockSize<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setDemodMode : public Callback_RadioCommander_setDemodMode_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setDemodMode(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setDemodModePtr
newCallback_RadioCommander_setDemodMode(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setDemodMode<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setDemodModePtr
newCallback_RadioCommander_setDemodMode(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setDemodMode<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setDemodModePtr
newCallback_RadioCommander_setDemodMode(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setDemodMode<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setDemodModePtr
newCallback_RadioCommander_setDemodMode(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setDemodMode<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setDemodMode : public Callback_RadioCommander_setDemodMode_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setDemodMode(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setDemodModePtr
newCallback_RadioCommander_setDemodMode(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setDemodMode<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setDemodModePtr
newCallback_RadioCommander_setDemodMode(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setDemodMode<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setDemodModePtr
newCallback_RadioCommander_setDemodMode(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setDemodMode<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setDemodModePtr
newCallback_RadioCommander_setDemodMode(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setDemodMode<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getDemodMode : public Callback_RadioCommander_getDemodMode_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::QS1R::DEMODMODE);

    CallbackNC_RadioCommander_getDemodMode(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::QS1R::DEMODMODE __ret;
        try
        {
            __ret = __proxy->end_getDemodMode(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getDemodModePtr
newCallback_RadioCommander_getDemodMode(const IceUtil::Handle<T>& instance, void (T::*cb)(::QS1R::DEMODMODE), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getDemodMode<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getDemodModePtr
newCallback_RadioCommander_getDemodMode(T* instance, void (T::*cb)(::QS1R::DEMODMODE), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getDemodMode<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getDemodMode : public Callback_RadioCommander_getDemodMode_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::QS1R::DEMODMODE, const CT&);

    Callback_RadioCommander_getDemodMode(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::QS1R::DEMODMODE __ret;
        try
        {
            __ret = __proxy->end_getDemodMode(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getDemodModePtr
newCallback_RadioCommander_getDemodMode(const IceUtil::Handle<T>& instance, void (T::*cb)(::QS1R::DEMODMODE, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getDemodMode<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getDemodModePtr
newCallback_RadioCommander_getDemodMode(T* instance, void (T::*cb)(::QS1R::DEMODMODE, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getDemodMode<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setControlRegister : public Callback_RadioCommander_setControlRegister_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setControlRegister(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setControlRegisterPtr
newCallback_RadioCommander_setControlRegister(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setControlRegister<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setControlRegisterPtr
newCallback_RadioCommander_setControlRegister(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setControlRegister<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setControlRegisterPtr
newCallback_RadioCommander_setControlRegister(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setControlRegister<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setControlRegisterPtr
newCallback_RadioCommander_setControlRegister(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setControlRegister<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setControlRegister : public Callback_RadioCommander_setControlRegister_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setControlRegister(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setControlRegisterPtr
newCallback_RadioCommander_setControlRegister(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setControlRegister<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setControlRegisterPtr
newCallback_RadioCommander_setControlRegister(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setControlRegister<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setControlRegisterPtr
newCallback_RadioCommander_setControlRegister(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setControlRegister<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setControlRegisterPtr
newCallback_RadioCommander_setControlRegister(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setControlRegister<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getControlRegister : public Callback_RadioCommander_getControlRegister_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_RadioCommander_getControlRegister(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getControlRegister(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getControlRegisterPtr
newCallback_RadioCommander_getControlRegister(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getControlRegister<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getControlRegisterPtr
newCallback_RadioCommander_getControlRegister(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getControlRegister<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getControlRegister : public Callback_RadioCommander_getControlRegister_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_RadioCommander_getControlRegister(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getControlRegister(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getControlRegisterPtr
newCallback_RadioCommander_getControlRegister(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getControlRegister<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getControlRegisterPtr
newCallback_RadioCommander_getControlRegister(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getControlRegister<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setDecimationRegister : public Callback_RadioCommander_setDecimationRegister_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setDecimationRegister(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setDecimationRegisterPtr
newCallback_RadioCommander_setDecimationRegister(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setDecimationRegister<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setDecimationRegisterPtr
newCallback_RadioCommander_setDecimationRegister(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setDecimationRegister<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setDecimationRegisterPtr
newCallback_RadioCommander_setDecimationRegister(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setDecimationRegister<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setDecimationRegisterPtr
newCallback_RadioCommander_setDecimationRegister(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setDecimationRegister<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setDecimationRegister : public Callback_RadioCommander_setDecimationRegister_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setDecimationRegister(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setDecimationRegisterPtr
newCallback_RadioCommander_setDecimationRegister(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setDecimationRegister<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setDecimationRegisterPtr
newCallback_RadioCommander_setDecimationRegister(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setDecimationRegister<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setDecimationRegisterPtr
newCallback_RadioCommander_setDecimationRegister(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setDecimationRegister<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setDecimationRegisterPtr
newCallback_RadioCommander_setDecimationRegister(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setDecimationRegister<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getDecimationRegister : public Callback_RadioCommander_getDecimationRegister_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_RadioCommander_getDecimationRegister(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getDecimationRegister(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getDecimationRegisterPtr
newCallback_RadioCommander_getDecimationRegister(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getDecimationRegister<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getDecimationRegisterPtr
newCallback_RadioCommander_getDecimationRegister(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getDecimationRegister<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getDecimationRegister : public Callback_RadioCommander_getDecimationRegister_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_RadioCommander_getDecimationRegister(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getDecimationRegister(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getDecimationRegisterPtr
newCallback_RadioCommander_getDecimationRegister(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getDecimationRegister<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getDecimationRegisterPtr
newCallback_RadioCommander_getDecimationRegister(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getDecimationRegister<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setScalingRegister : public Callback_RadioCommander_setScalingRegister_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setScalingRegister(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setScalingRegisterPtr
newCallback_RadioCommander_setScalingRegister(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setScalingRegister<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setScalingRegisterPtr
newCallback_RadioCommander_setScalingRegister(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setScalingRegister<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setScalingRegisterPtr
newCallback_RadioCommander_setScalingRegister(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setScalingRegister<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setScalingRegisterPtr
newCallback_RadioCommander_setScalingRegister(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setScalingRegister<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setScalingRegister : public Callback_RadioCommander_setScalingRegister_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setScalingRegister(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setScalingRegisterPtr
newCallback_RadioCommander_setScalingRegister(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setScalingRegister<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setScalingRegisterPtr
newCallback_RadioCommander_setScalingRegister(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setScalingRegister<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setScalingRegisterPtr
newCallback_RadioCommander_setScalingRegister(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setScalingRegister<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setScalingRegisterPtr
newCallback_RadioCommander_setScalingRegister(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setScalingRegister<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getScalingRegister : public Callback_RadioCommander_getScalingRegister_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_RadioCommander_getScalingRegister(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getScalingRegister(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getScalingRegisterPtr
newCallback_RadioCommander_getScalingRegister(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getScalingRegister<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getScalingRegisterPtr
newCallback_RadioCommander_getScalingRegister(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getScalingRegister<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getScalingRegister : public Callback_RadioCommander_getScalingRegister_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_RadioCommander_getScalingRegister(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getScalingRegister(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getScalingRegisterPtr
newCallback_RadioCommander_getScalingRegister(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getScalingRegister<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getScalingRegisterPtr
newCallback_RadioCommander_getScalingRegister(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getScalingRegister<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getEepromEncFreqRegister : public Callback_RadioCommander_getEepromEncFreqRegister_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_RadioCommander_getEepromEncFreqRegister(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getEepromEncFreqRegister(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getEepromEncFreqRegisterPtr
newCallback_RadioCommander_getEepromEncFreqRegister(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getEepromEncFreqRegister<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getEepromEncFreqRegisterPtr
newCallback_RadioCommander_getEepromEncFreqRegister(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getEepromEncFreqRegister<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getEepromEncFreqRegister : public Callback_RadioCommander_getEepromEncFreqRegister_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_RadioCommander_getEepromEncFreqRegister(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getEepromEncFreqRegister(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getEepromEncFreqRegisterPtr
newCallback_RadioCommander_getEepromEncFreqRegister(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getEepromEncFreqRegister<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getEepromEncFreqRegisterPtr
newCallback_RadioCommander_getEepromEncFreqRegister(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getEepromEncFreqRegister<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setDither : public Callback_RadioCommander_setDither_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setDither(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setDitherPtr
newCallback_RadioCommander_setDither(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setDither<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setDitherPtr
newCallback_RadioCommander_setDither(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setDither<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setDitherPtr
newCallback_RadioCommander_setDither(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setDither<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setDitherPtr
newCallback_RadioCommander_setDither(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setDither<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setDither : public Callback_RadioCommander_setDither_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setDither(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setDitherPtr
newCallback_RadioCommander_setDither(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setDither<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setDitherPtr
newCallback_RadioCommander_setDither(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setDither<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setDitherPtr
newCallback_RadioCommander_setDither(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setDither<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setDitherPtr
newCallback_RadioCommander_setDither(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setDither<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getDither : public Callback_RadioCommander_getDither_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_RadioCommander_getDither(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_getDither(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getDitherPtr
newCallback_RadioCommander_getDither(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getDither<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getDitherPtr
newCallback_RadioCommander_getDither(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getDither<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getDither : public Callback_RadioCommander_getDither_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_RadioCommander_getDither(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_getDither(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getDitherPtr
newCallback_RadioCommander_getDither(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getDither<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getDitherPtr
newCallback_RadioCommander_getDither(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getDither<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setEncodeFreq : public Callback_RadioCommander_setEncodeFreq_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setEncodeFreq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setEncodeFreqPtr
newCallback_RadioCommander_setEncodeFreq(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setEncodeFreq<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setEncodeFreqPtr
newCallback_RadioCommander_setEncodeFreq(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setEncodeFreq<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setEncodeFreqPtr
newCallback_RadioCommander_setEncodeFreq(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setEncodeFreq<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setEncodeFreqPtr
newCallback_RadioCommander_setEncodeFreq(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setEncodeFreq<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setEncodeFreq : public Callback_RadioCommander_setEncodeFreq_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setEncodeFreq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setEncodeFreqPtr
newCallback_RadioCommander_setEncodeFreq(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setEncodeFreq<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setEncodeFreqPtr
newCallback_RadioCommander_setEncodeFreq(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setEncodeFreq<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setEncodeFreqPtr
newCallback_RadioCommander_setEncodeFreq(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setEncodeFreq<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setEncodeFreqPtr
newCallback_RadioCommander_setEncodeFreq(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setEncodeFreq<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getEncodeFreq : public Callback_RadioCommander_getEncodeFreq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Float);

    CallbackNC_RadioCommander_getEncodeFreq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getEncodeFreq(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getEncodeFreqPtr
newCallback_RadioCommander_getEncodeFreq(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getEncodeFreq<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getEncodeFreqPtr
newCallback_RadioCommander_getEncodeFreq(T* instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getEncodeFreq<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getEncodeFreq : public Callback_RadioCommander_getEncodeFreq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Float, const CT&);

    Callback_RadioCommander_getEncodeFreq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getEncodeFreq(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getEncodeFreqPtr
newCallback_RadioCommander_getEncodeFreq(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getEncodeFreq<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getEncodeFreqPtr
newCallback_RadioCommander_getEncodeFreq(T* instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getEncodeFreq<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setMeterCalibrationOffset : public Callback_RadioCommander_setMeterCalibrationOffset_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setMeterCalibrationOffset(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setMeterCalibrationOffsetPtr
newCallback_RadioCommander_setMeterCalibrationOffset(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setMeterCalibrationOffset<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setMeterCalibrationOffsetPtr
newCallback_RadioCommander_setMeterCalibrationOffset(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setMeterCalibrationOffset<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setMeterCalibrationOffsetPtr
newCallback_RadioCommander_setMeterCalibrationOffset(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setMeterCalibrationOffset<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setMeterCalibrationOffsetPtr
newCallback_RadioCommander_setMeterCalibrationOffset(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setMeterCalibrationOffset<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setMeterCalibrationOffset : public Callback_RadioCommander_setMeterCalibrationOffset_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setMeterCalibrationOffset(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setMeterCalibrationOffsetPtr
newCallback_RadioCommander_setMeterCalibrationOffset(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setMeterCalibrationOffset<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setMeterCalibrationOffsetPtr
newCallback_RadioCommander_setMeterCalibrationOffset(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setMeterCalibrationOffset<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setMeterCalibrationOffsetPtr
newCallback_RadioCommander_setMeterCalibrationOffset(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setMeterCalibrationOffset<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setMeterCalibrationOffsetPtr
newCallback_RadioCommander_setMeterCalibrationOffset(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setMeterCalibrationOffset<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getMeterCalibrationOffset : public Callback_RadioCommander_getMeterCalibrationOffset_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Float);

    CallbackNC_RadioCommander_getMeterCalibrationOffset(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getMeterCalibrationOffset(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getMeterCalibrationOffsetPtr
newCallback_RadioCommander_getMeterCalibrationOffset(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getMeterCalibrationOffset<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getMeterCalibrationOffsetPtr
newCallback_RadioCommander_getMeterCalibrationOffset(T* instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getMeterCalibrationOffset<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getMeterCalibrationOffset : public Callback_RadioCommander_getMeterCalibrationOffset_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Float, const CT&);

    Callback_RadioCommander_getMeterCalibrationOffset(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getMeterCalibrationOffset(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getMeterCalibrationOffsetPtr
newCallback_RadioCommander_getMeterCalibrationOffset(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getMeterCalibrationOffset<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getMeterCalibrationOffsetPtr
newCallback_RadioCommander_getMeterCalibrationOffset(T* instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getMeterCalibrationOffset<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setSpectrumCalibrationOffset : public Callback_RadioCommander_setSpectrumCalibrationOffset_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setSpectrumCalibrationOffset(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setSpectrumCalibrationOffsetPtr
newCallback_RadioCommander_setSpectrumCalibrationOffset(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setSpectrumCalibrationOffset<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setSpectrumCalibrationOffsetPtr
newCallback_RadioCommander_setSpectrumCalibrationOffset(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setSpectrumCalibrationOffset<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setSpectrumCalibrationOffsetPtr
newCallback_RadioCommander_setSpectrumCalibrationOffset(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setSpectrumCalibrationOffset<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setSpectrumCalibrationOffsetPtr
newCallback_RadioCommander_setSpectrumCalibrationOffset(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setSpectrumCalibrationOffset<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setSpectrumCalibrationOffset : public Callback_RadioCommander_setSpectrumCalibrationOffset_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setSpectrumCalibrationOffset(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setSpectrumCalibrationOffsetPtr
newCallback_RadioCommander_setSpectrumCalibrationOffset(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setSpectrumCalibrationOffset<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setSpectrumCalibrationOffsetPtr
newCallback_RadioCommander_setSpectrumCalibrationOffset(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setSpectrumCalibrationOffset<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setSpectrumCalibrationOffsetPtr
newCallback_RadioCommander_setSpectrumCalibrationOffset(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setSpectrumCalibrationOffset<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setSpectrumCalibrationOffsetPtr
newCallback_RadioCommander_setSpectrumCalibrationOffset(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setSpectrumCalibrationOffset<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getSpectrumCalibrationOffset : public Callback_RadioCommander_getSpectrumCalibrationOffset_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Float);

    CallbackNC_RadioCommander_getSpectrumCalibrationOffset(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getSpectrumCalibrationOffset(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getSpectrumCalibrationOffsetPtr
newCallback_RadioCommander_getSpectrumCalibrationOffset(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getSpectrumCalibrationOffset<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getSpectrumCalibrationOffsetPtr
newCallback_RadioCommander_getSpectrumCalibrationOffset(T* instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getSpectrumCalibrationOffset<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getSpectrumCalibrationOffset : public Callback_RadioCommander_getSpectrumCalibrationOffset_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Float, const CT&);

    Callback_RadioCommander_getSpectrumCalibrationOffset(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getSpectrumCalibrationOffset(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getSpectrumCalibrationOffsetPtr
newCallback_RadioCommander_getSpectrumCalibrationOffset(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getSpectrumCalibrationOffset<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getSpectrumCalibrationOffsetPtr
newCallback_RadioCommander_getSpectrumCalibrationOffset(T* instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getSpectrumCalibrationOffset<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setNrSwitch : public Callback_RadioCommander_setNrSwitch_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setNrSwitch(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setNrSwitchPtr
newCallback_RadioCommander_setNrSwitch(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setNrSwitch<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setNrSwitchPtr
newCallback_RadioCommander_setNrSwitch(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setNrSwitch<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setNrSwitchPtr
newCallback_RadioCommander_setNrSwitch(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setNrSwitch<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setNrSwitchPtr
newCallback_RadioCommander_setNrSwitch(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setNrSwitch<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setNrSwitch : public Callback_RadioCommander_setNrSwitch_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setNrSwitch(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setNrSwitchPtr
newCallback_RadioCommander_setNrSwitch(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setNrSwitch<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setNrSwitchPtr
newCallback_RadioCommander_setNrSwitch(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setNrSwitch<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setNrSwitchPtr
newCallback_RadioCommander_setNrSwitch(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setNrSwitch<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setNrSwitchPtr
newCallback_RadioCommander_setNrSwitch(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setNrSwitch<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getNrSwitch : public Callback_RadioCommander_getNrSwitch_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_RadioCommander_getNrSwitch(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_getNrSwitch(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getNrSwitchPtr
newCallback_RadioCommander_getNrSwitch(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getNrSwitch<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getNrSwitchPtr
newCallback_RadioCommander_getNrSwitch(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getNrSwitch<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getNrSwitch : public Callback_RadioCommander_getNrSwitch_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_RadioCommander_getNrSwitch(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_getNrSwitch(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getNrSwitchPtr
newCallback_RadioCommander_getNrSwitch(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getNrSwitch<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getNrSwitchPtr
newCallback_RadioCommander_getNrSwitch(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getNrSwitch<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setNrTaps : public Callback_RadioCommander_setNrTaps_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setNrTaps(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setNrTapsPtr
newCallback_RadioCommander_setNrTaps(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setNrTaps<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setNrTapsPtr
newCallback_RadioCommander_setNrTaps(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setNrTaps<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setNrTapsPtr
newCallback_RadioCommander_setNrTaps(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setNrTaps<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setNrTapsPtr
newCallback_RadioCommander_setNrTaps(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setNrTaps<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setNrTaps : public Callback_RadioCommander_setNrTaps_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setNrTaps(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setNrTapsPtr
newCallback_RadioCommander_setNrTaps(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setNrTaps<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setNrTapsPtr
newCallback_RadioCommander_setNrTaps(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setNrTaps<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setNrTapsPtr
newCallback_RadioCommander_setNrTaps(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setNrTaps<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setNrTapsPtr
newCallback_RadioCommander_setNrTaps(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setNrTaps<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getNrTaps : public Callback_RadioCommander_getNrTaps_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_RadioCommander_getNrTaps(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getNrTaps(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getNrTapsPtr
newCallback_RadioCommander_getNrTaps(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getNrTaps<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getNrTapsPtr
newCallback_RadioCommander_getNrTaps(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getNrTaps<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getNrTaps : public Callback_RadioCommander_getNrTaps_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_RadioCommander_getNrTaps(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getNrTaps(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getNrTapsPtr
newCallback_RadioCommander_getNrTaps(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getNrTaps<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getNrTapsPtr
newCallback_RadioCommander_getNrTaps(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getNrTaps<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setNrDelay : public Callback_RadioCommander_setNrDelay_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setNrDelay(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setNrDelayPtr
newCallback_RadioCommander_setNrDelay(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setNrDelay<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setNrDelayPtr
newCallback_RadioCommander_setNrDelay(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setNrDelay<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setNrDelayPtr
newCallback_RadioCommander_setNrDelay(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setNrDelay<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setNrDelayPtr
newCallback_RadioCommander_setNrDelay(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setNrDelay<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setNrDelay : public Callback_RadioCommander_setNrDelay_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setNrDelay(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setNrDelayPtr
newCallback_RadioCommander_setNrDelay(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setNrDelay<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setNrDelayPtr
newCallback_RadioCommander_setNrDelay(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setNrDelay<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setNrDelayPtr
newCallback_RadioCommander_setNrDelay(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setNrDelay<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setNrDelayPtr
newCallback_RadioCommander_setNrDelay(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setNrDelay<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getNrDelay : public Callback_RadioCommander_getNrDelay_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_RadioCommander_getNrDelay(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getNrDelay(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getNrDelayPtr
newCallback_RadioCommander_getNrDelay(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getNrDelay<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getNrDelayPtr
newCallback_RadioCommander_getNrDelay(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getNrDelay<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getNrDelay : public Callback_RadioCommander_getNrDelay_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_RadioCommander_getNrDelay(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getNrDelay(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getNrDelayPtr
newCallback_RadioCommander_getNrDelay(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getNrDelay<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getNrDelayPtr
newCallback_RadioCommander_getNrDelay(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getNrDelay<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setNrGain : public Callback_RadioCommander_setNrGain_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setNrGain(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setNrGainPtr
newCallback_RadioCommander_setNrGain(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setNrGain<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setNrGainPtr
newCallback_RadioCommander_setNrGain(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setNrGain<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setNrGainPtr
newCallback_RadioCommander_setNrGain(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setNrGain<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setNrGainPtr
newCallback_RadioCommander_setNrGain(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setNrGain<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setNrGain : public Callback_RadioCommander_setNrGain_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setNrGain(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setNrGainPtr
newCallback_RadioCommander_setNrGain(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setNrGain<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setNrGainPtr
newCallback_RadioCommander_setNrGain(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setNrGain<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setNrGainPtr
newCallback_RadioCommander_setNrGain(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setNrGain<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setNrGainPtr
newCallback_RadioCommander_setNrGain(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setNrGain<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getNrGain : public Callback_RadioCommander_getNrGain_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Float);

    CallbackNC_RadioCommander_getNrGain(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getNrGain(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getNrGainPtr
newCallback_RadioCommander_getNrGain(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getNrGain<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getNrGainPtr
newCallback_RadioCommander_getNrGain(T* instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getNrGain<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getNrGain : public Callback_RadioCommander_getNrGain_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Float, const CT&);

    Callback_RadioCommander_getNrGain(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getNrGain(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getNrGainPtr
newCallback_RadioCommander_getNrGain(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getNrGain<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getNrGainPtr
newCallback_RadioCommander_getNrGain(T* instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getNrGain<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setNrLeak : public Callback_RadioCommander_setNrLeak_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setNrLeak(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setNrLeakPtr
newCallback_RadioCommander_setNrLeak(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setNrLeak<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setNrLeakPtr
newCallback_RadioCommander_setNrLeak(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setNrLeak<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setNrLeakPtr
newCallback_RadioCommander_setNrLeak(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setNrLeak<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setNrLeakPtr
newCallback_RadioCommander_setNrLeak(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setNrLeak<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setNrLeak : public Callback_RadioCommander_setNrLeak_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setNrLeak(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setNrLeakPtr
newCallback_RadioCommander_setNrLeak(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setNrLeak<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setNrLeakPtr
newCallback_RadioCommander_setNrLeak(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setNrLeak<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setNrLeakPtr
newCallback_RadioCommander_setNrLeak(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setNrLeak<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setNrLeakPtr
newCallback_RadioCommander_setNrLeak(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setNrLeak<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getNrLeak : public Callback_RadioCommander_getNrLeak_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Float);

    CallbackNC_RadioCommander_getNrLeak(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getNrLeak(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getNrLeakPtr
newCallback_RadioCommander_getNrLeak(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getNrLeak<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getNrLeakPtr
newCallback_RadioCommander_getNrLeak(T* instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getNrLeak<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getNrLeak : public Callback_RadioCommander_getNrLeak_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Float, const CT&);

    Callback_RadioCommander_getNrLeak(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getNrLeak(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getNrLeakPtr
newCallback_RadioCommander_getNrLeak(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getNrLeak<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getNrLeakPtr
newCallback_RadioCommander_getNrLeak(T* instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getNrLeak<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setExit : public Callback_RadioCommander_setExit_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setExit(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setExitPtr
newCallback_RadioCommander_setExit(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setExit<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setExitPtr
newCallback_RadioCommander_setExit(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setExit<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setExitPtr
newCallback_RadioCommander_setExit(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setExit<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setExitPtr
newCallback_RadioCommander_setExit(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setExit<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setExit : public Callback_RadioCommander_setExit_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setExit(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setExitPtr
newCallback_RadioCommander_setExit(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setExit<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setExitPtr
newCallback_RadioCommander_setExit(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setExit<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setExitPtr
newCallback_RadioCommander_setExit(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setExit<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setExitPtr
newCallback_RadioCommander_setExit(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setExit<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setFrequency : public Callback_RadioCommander_setFrequency_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setFrequency(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setFrequencyPtr
newCallback_RadioCommander_setFrequency(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setFrequency<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setFrequencyPtr
newCallback_RadioCommander_setFrequency(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setFrequency<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setFrequencyPtr
newCallback_RadioCommander_setFrequency(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setFrequency<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setFrequencyPtr
newCallback_RadioCommander_setFrequency(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setFrequency<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setFrequency : public Callback_RadioCommander_setFrequency_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setFrequency(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setFrequencyPtr
newCallback_RadioCommander_setFrequency(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setFrequency<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setFrequencyPtr
newCallback_RadioCommander_setFrequency(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setFrequency<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setFrequencyPtr
newCallback_RadioCommander_setFrequency(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setFrequency<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setFrequencyPtr
newCallback_RadioCommander_setFrequency(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setFrequency<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getFrequency : public Callback_RadioCommander_getFrequency_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Float);

    CallbackNC_RadioCommander_getFrequency(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getFrequency(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getFrequencyPtr
newCallback_RadioCommander_getFrequency(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getFrequency<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getFrequencyPtr
newCallback_RadioCommander_getFrequency(T* instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getFrequency<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getFrequency : public Callback_RadioCommander_getFrequency_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Float, const CT&);

    Callback_RadioCommander_getFrequency(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getFrequency(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getFrequencyPtr
newCallback_RadioCommander_getFrequency(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getFrequency<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getFrequencyPtr
newCallback_RadioCommander_getFrequency(T* instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getFrequency<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setFilterLo : public Callback_RadioCommander_setFilterLo_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setFilterLo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setFilterLoPtr
newCallback_RadioCommander_setFilterLo(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setFilterLo<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setFilterLoPtr
newCallback_RadioCommander_setFilterLo(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setFilterLo<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setFilterLoPtr
newCallback_RadioCommander_setFilterLo(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setFilterLo<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setFilterLoPtr
newCallback_RadioCommander_setFilterLo(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setFilterLo<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setFilterLo : public Callback_RadioCommander_setFilterLo_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setFilterLo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setFilterLoPtr
newCallback_RadioCommander_setFilterLo(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setFilterLo<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setFilterLoPtr
newCallback_RadioCommander_setFilterLo(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setFilterLo<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setFilterLoPtr
newCallback_RadioCommander_setFilterLo(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setFilterLo<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setFilterLoPtr
newCallback_RadioCommander_setFilterLo(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setFilterLo<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getFilterLo : public Callback_RadioCommander_getFilterLo_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Float);

    CallbackNC_RadioCommander_getFilterLo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getFilterLo(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getFilterLoPtr
newCallback_RadioCommander_getFilterLo(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getFilterLo<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getFilterLoPtr
newCallback_RadioCommander_getFilterLo(T* instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getFilterLo<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getFilterLo : public Callback_RadioCommander_getFilterLo_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Float, const CT&);

    Callback_RadioCommander_getFilterLo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getFilterLo(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getFilterLoPtr
newCallback_RadioCommander_getFilterLo(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getFilterLo<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getFilterLoPtr
newCallback_RadioCommander_getFilterLo(T* instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getFilterLo<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setFilterHi : public Callback_RadioCommander_setFilterHi_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setFilterHi(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setFilterHiPtr
newCallback_RadioCommander_setFilterHi(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setFilterHi<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setFilterHiPtr
newCallback_RadioCommander_setFilterHi(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setFilterHi<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setFilterHiPtr
newCallback_RadioCommander_setFilterHi(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setFilterHi<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setFilterHiPtr
newCallback_RadioCommander_setFilterHi(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setFilterHi<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setFilterHi : public Callback_RadioCommander_setFilterHi_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setFilterHi(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setFilterHiPtr
newCallback_RadioCommander_setFilterHi(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setFilterHi<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setFilterHiPtr
newCallback_RadioCommander_setFilterHi(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setFilterHi<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setFilterHiPtr
newCallback_RadioCommander_setFilterHi(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setFilterHi<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setFilterHiPtr
newCallback_RadioCommander_setFilterHi(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setFilterHi<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getFilterHi : public Callback_RadioCommander_getFilterHi_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Float);

    CallbackNC_RadioCommander_getFilterHi(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getFilterHi(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getFilterHiPtr
newCallback_RadioCommander_getFilterHi(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getFilterHi<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getFilterHiPtr
newCallback_RadioCommander_getFilterHi(T* instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getFilterHi<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getFilterHi : public Callback_RadioCommander_getFilterHi_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Float, const CT&);

    Callback_RadioCommander_getFilterHi(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getFilterHi(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getFilterHiPtr
newCallback_RadioCommander_getFilterHi(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getFilterHi<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getFilterHiPtr
newCallback_RadioCommander_getFilterHi(T* instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getFilterHi<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setFilter : public Callback_RadioCommander_setFilter_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setFilter(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setFilterPtr
newCallback_RadioCommander_setFilter(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setFilter<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setFilterPtr
newCallback_RadioCommander_setFilter(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setFilter<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setFilterPtr
newCallback_RadioCommander_setFilter(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setFilter<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setFilterPtr
newCallback_RadioCommander_setFilter(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setFilter<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setFilter : public Callback_RadioCommander_setFilter_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setFilter(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setFilterPtr
newCallback_RadioCommander_setFilter(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setFilter<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setFilterPtr
newCallback_RadioCommander_setFilter(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setFilter<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setFilterPtr
newCallback_RadioCommander_setFilter(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setFilter<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setFilterPtr
newCallback_RadioCommander_setFilter(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setFilter<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setMute : public Callback_RadioCommander_setMute_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setMute(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setMutePtr
newCallback_RadioCommander_setMute(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setMute<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setMutePtr
newCallback_RadioCommander_setMute(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setMute<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setMutePtr
newCallback_RadioCommander_setMute(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setMute<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setMutePtr
newCallback_RadioCommander_setMute(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setMute<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setMute : public Callback_RadioCommander_setMute_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setMute(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setMutePtr
newCallback_RadioCommander_setMute(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setMute<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setMutePtr
newCallback_RadioCommander_setMute(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setMute<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setMutePtr
newCallback_RadioCommander_setMute(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setMute<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setMutePtr
newCallback_RadioCommander_setMute(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setMute<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getMute : public Callback_RadioCommander_getMute_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_RadioCommander_getMute(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_getMute(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getMutePtr
newCallback_RadioCommander_getMute(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getMute<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getMutePtr
newCallback_RadioCommander_getMute(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getMute<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getMute : public Callback_RadioCommander_getMute_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_RadioCommander_getMute(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_getMute(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getMutePtr
newCallback_RadioCommander_getMute(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getMute<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getMutePtr
newCallback_RadioCommander_getMute(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getMute<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setNb1Switch : public Callback_RadioCommander_setNb1Switch_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setNb1Switch(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setNb1SwitchPtr
newCallback_RadioCommander_setNb1Switch(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setNb1Switch<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setNb1SwitchPtr
newCallback_RadioCommander_setNb1Switch(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setNb1Switch<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setNb1SwitchPtr
newCallback_RadioCommander_setNb1Switch(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setNb1Switch<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setNb1SwitchPtr
newCallback_RadioCommander_setNb1Switch(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setNb1Switch<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setNb1Switch : public Callback_RadioCommander_setNb1Switch_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setNb1Switch(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setNb1SwitchPtr
newCallback_RadioCommander_setNb1Switch(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setNb1Switch<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setNb1SwitchPtr
newCallback_RadioCommander_setNb1Switch(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setNb1Switch<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setNb1SwitchPtr
newCallback_RadioCommander_setNb1Switch(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setNb1Switch<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setNb1SwitchPtr
newCallback_RadioCommander_setNb1Switch(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setNb1Switch<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setNb1Thresh : public Callback_RadioCommander_setNb1Thresh_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setNb1Thresh(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setNb1ThreshPtr
newCallback_RadioCommander_setNb1Thresh(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setNb1Thresh<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setNb1ThreshPtr
newCallback_RadioCommander_setNb1Thresh(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setNb1Thresh<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setNb1ThreshPtr
newCallback_RadioCommander_setNb1Thresh(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setNb1Thresh<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setNb1ThreshPtr
newCallback_RadioCommander_setNb1Thresh(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setNb1Thresh<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setNb1Thresh : public Callback_RadioCommander_setNb1Thresh_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setNb1Thresh(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setNb1ThreshPtr
newCallback_RadioCommander_setNb1Thresh(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setNb1Thresh<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setNb1ThreshPtr
newCallback_RadioCommander_setNb1Thresh(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setNb1Thresh<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setNb1ThreshPtr
newCallback_RadioCommander_setNb1Thresh(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setNb1Thresh<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setNb1ThreshPtr
newCallback_RadioCommander_setNb1Thresh(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setNb1Thresh<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getNb1Switch : public Callback_RadioCommander_getNb1Switch_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_RadioCommander_getNb1Switch(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_getNb1Switch(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getNb1SwitchPtr
newCallback_RadioCommander_getNb1Switch(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getNb1Switch<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getNb1SwitchPtr
newCallback_RadioCommander_getNb1Switch(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getNb1Switch<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getNb1Switch : public Callback_RadioCommander_getNb1Switch_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_RadioCommander_getNb1Switch(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_getNb1Switch(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getNb1SwitchPtr
newCallback_RadioCommander_getNb1Switch(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getNb1Switch<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getNb1SwitchPtr
newCallback_RadioCommander_getNb1Switch(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getNb1Switch<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getNb1Thresh : public Callback_RadioCommander_getNb1Thresh_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_RadioCommander_getNb1Thresh(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getNb1Thresh(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getNb1ThreshPtr
newCallback_RadioCommander_getNb1Thresh(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getNb1Thresh<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getNb1ThreshPtr
newCallback_RadioCommander_getNb1Thresh(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getNb1Thresh<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getNb1Thresh : public Callback_RadioCommander_getNb1Thresh_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_RadioCommander_getNb1Thresh(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getNb1Thresh(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getNb1ThreshPtr
newCallback_RadioCommander_getNb1Thresh(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getNb1Thresh<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getNb1ThreshPtr
newCallback_RadioCommander_getNb1Thresh(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getNb1Thresh<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setNb2Switch : public Callback_RadioCommander_setNb2Switch_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setNb2Switch(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setNb2SwitchPtr
newCallback_RadioCommander_setNb2Switch(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setNb2Switch<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setNb2SwitchPtr
newCallback_RadioCommander_setNb2Switch(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setNb2Switch<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setNb2SwitchPtr
newCallback_RadioCommander_setNb2Switch(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setNb2Switch<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setNb2SwitchPtr
newCallback_RadioCommander_setNb2Switch(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setNb2Switch<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setNb2Switch : public Callback_RadioCommander_setNb2Switch_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setNb2Switch(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setNb2SwitchPtr
newCallback_RadioCommander_setNb2Switch(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setNb2Switch<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setNb2SwitchPtr
newCallback_RadioCommander_setNb2Switch(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setNb2Switch<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setNb2SwitchPtr
newCallback_RadioCommander_setNb2Switch(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setNb2Switch<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setNb2SwitchPtr
newCallback_RadioCommander_setNb2Switch(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setNb2Switch<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setNb2Thresh : public Callback_RadioCommander_setNb2Thresh_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setNb2Thresh(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setNb2ThreshPtr
newCallback_RadioCommander_setNb2Thresh(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setNb2Thresh<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setNb2ThreshPtr
newCallback_RadioCommander_setNb2Thresh(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setNb2Thresh<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setNb2ThreshPtr
newCallback_RadioCommander_setNb2Thresh(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setNb2Thresh<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setNb2ThreshPtr
newCallback_RadioCommander_setNb2Thresh(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setNb2Thresh<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setNb2Thresh : public Callback_RadioCommander_setNb2Thresh_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setNb2Thresh(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setNb2ThreshPtr
newCallback_RadioCommander_setNb2Thresh(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setNb2Thresh<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setNb2ThreshPtr
newCallback_RadioCommander_setNb2Thresh(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setNb2Thresh<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setNb2ThreshPtr
newCallback_RadioCommander_setNb2Thresh(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setNb2Thresh<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setNb2ThreshPtr
newCallback_RadioCommander_setNb2Thresh(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setNb2Thresh<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getNb2Switch : public Callback_RadioCommander_getNb2Switch_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_RadioCommander_getNb2Switch(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_getNb2Switch(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getNb2SwitchPtr
newCallback_RadioCommander_getNb2Switch(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getNb2Switch<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getNb2SwitchPtr
newCallback_RadioCommander_getNb2Switch(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getNb2Switch<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getNb2Switch : public Callback_RadioCommander_getNb2Switch_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_RadioCommander_getNb2Switch(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_getNb2Switch(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getNb2SwitchPtr
newCallback_RadioCommander_getNb2Switch(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getNb2Switch<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getNb2SwitchPtr
newCallback_RadioCommander_getNb2Switch(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getNb2Switch<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getNb2Thresh : public Callback_RadioCommander_getNb2Thresh_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_RadioCommander_getNb2Thresh(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getNb2Thresh(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getNb2ThreshPtr
newCallback_RadioCommander_getNb2Thresh(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getNb2Thresh<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getNb2ThreshPtr
newCallback_RadioCommander_getNb2Thresh(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getNb2Thresh<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getNb2Thresh : public Callback_RadioCommander_getNb2Thresh_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_RadioCommander_getNb2Thresh(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getNb2Thresh(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getNb2ThreshPtr
newCallback_RadioCommander_getNb2Thresh(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getNb2Thresh<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getNb2ThreshPtr
newCallback_RadioCommander_getNb2Thresh(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getNb2Thresh<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setPga : public Callback_RadioCommander_setPga_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setPga(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setPgaPtr
newCallback_RadioCommander_setPga(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setPga<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setPgaPtr
newCallback_RadioCommander_setPga(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setPga<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setPgaPtr
newCallback_RadioCommander_setPga(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setPga<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setPgaPtr
newCallback_RadioCommander_setPga(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setPga<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setPga : public Callback_RadioCommander_setPga_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setPga(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setPgaPtr
newCallback_RadioCommander_setPga(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setPga<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setPgaPtr
newCallback_RadioCommander_setPga(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setPga<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setPgaPtr
newCallback_RadioCommander_setPga(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setPga<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setPgaPtr
newCallback_RadioCommander_setPga(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setPga<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getPga : public Callback_RadioCommander_getPga_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_RadioCommander_getPga(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_getPga(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getPgaPtr
newCallback_RadioCommander_getPga(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getPga<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getPgaPtr
newCallback_RadioCommander_getPga(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getPga<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getPga : public Callback_RadioCommander_getPga_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_RadioCommander_getPga(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_getPga(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getPgaPtr
newCallback_RadioCommander_getPga(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getPga<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getPgaPtr
newCallback_RadioCommander_getPga(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getPga<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setInbandPsSwitch : public Callback_RadioCommander_setInbandPsSwitch_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setInbandPsSwitch(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setInbandPsSwitchPtr
newCallback_RadioCommander_setInbandPsSwitch(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setInbandPsSwitch<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setInbandPsSwitchPtr
newCallback_RadioCommander_setInbandPsSwitch(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setInbandPsSwitch<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setInbandPsSwitchPtr
newCallback_RadioCommander_setInbandPsSwitch(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setInbandPsSwitch<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setInbandPsSwitchPtr
newCallback_RadioCommander_setInbandPsSwitch(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setInbandPsSwitch<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setInbandPsSwitch : public Callback_RadioCommander_setInbandPsSwitch_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setInbandPsSwitch(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setInbandPsSwitchPtr
newCallback_RadioCommander_setInbandPsSwitch(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setInbandPsSwitch<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setInbandPsSwitchPtr
newCallback_RadioCommander_setInbandPsSwitch(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setInbandPsSwitch<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setInbandPsSwitchPtr
newCallback_RadioCommander_setInbandPsSwitch(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setInbandPsSwitch<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setInbandPsSwitchPtr
newCallback_RadioCommander_setInbandPsSwitch(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setInbandPsSwitch<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getInbandPsSwitch : public Callback_RadioCommander_getInbandPsSwitch_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_RadioCommander_getInbandPsSwitch(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_getInbandPsSwitch(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getInbandPsSwitchPtr
newCallback_RadioCommander_getInbandPsSwitch(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getInbandPsSwitch<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getInbandPsSwitchPtr
newCallback_RadioCommander_getInbandPsSwitch(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getInbandPsSwitch<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getInbandPsSwitch : public Callback_RadioCommander_getInbandPsSwitch_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_RadioCommander_getInbandPsSwitch(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_getInbandPsSwitch(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getInbandPsSwitchPtr
newCallback_RadioCommander_getInbandPsSwitch(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getInbandPsSwitch<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getInbandPsSwitchPtr
newCallback_RadioCommander_getInbandPsSwitch(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getInbandPsSwitch<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getInbandPsSize : public Callback_RadioCommander_getInbandPsSize_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_RadioCommander_getInbandPsSize(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getInbandPsSize(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getInbandPsSizePtr
newCallback_RadioCommander_getInbandPsSize(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getInbandPsSize<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getInbandPsSizePtr
newCallback_RadioCommander_getInbandPsSize(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getInbandPsSize<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getInbandPsSize : public Callback_RadioCommander_getInbandPsSize_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_RadioCommander_getInbandPsSize(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getInbandPsSize(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getInbandPsSizePtr
newCallback_RadioCommander_getInbandPsSize(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getInbandPsSize<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getInbandPsSizePtr
newCallback_RadioCommander_getInbandPsSize(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getInbandPsSize<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setOutbandPsSwitch : public Callback_RadioCommander_setOutbandPsSwitch_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setOutbandPsSwitch(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setOutbandPsSwitchPtr
newCallback_RadioCommander_setOutbandPsSwitch(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setOutbandPsSwitch<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setOutbandPsSwitchPtr
newCallback_RadioCommander_setOutbandPsSwitch(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setOutbandPsSwitch<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setOutbandPsSwitchPtr
newCallback_RadioCommander_setOutbandPsSwitch(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setOutbandPsSwitch<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setOutbandPsSwitchPtr
newCallback_RadioCommander_setOutbandPsSwitch(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setOutbandPsSwitch<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setOutbandPsSwitch : public Callback_RadioCommander_setOutbandPsSwitch_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setOutbandPsSwitch(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setOutbandPsSwitchPtr
newCallback_RadioCommander_setOutbandPsSwitch(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setOutbandPsSwitch<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setOutbandPsSwitchPtr
newCallback_RadioCommander_setOutbandPsSwitch(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setOutbandPsSwitch<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setOutbandPsSwitchPtr
newCallback_RadioCommander_setOutbandPsSwitch(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setOutbandPsSwitch<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setOutbandPsSwitchPtr
newCallback_RadioCommander_setOutbandPsSwitch(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setOutbandPsSwitch<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getOutbandPsSwitch : public Callback_RadioCommander_getOutbandPsSwitch_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_RadioCommander_getOutbandPsSwitch(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_getOutbandPsSwitch(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getOutbandPsSwitchPtr
newCallback_RadioCommander_getOutbandPsSwitch(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getOutbandPsSwitch<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getOutbandPsSwitchPtr
newCallback_RadioCommander_getOutbandPsSwitch(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getOutbandPsSwitch<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getOutbandPsSwitch : public Callback_RadioCommander_getOutbandPsSwitch_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_RadioCommander_getOutbandPsSwitch(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_getOutbandPsSwitch(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getOutbandPsSwitchPtr
newCallback_RadioCommander_getOutbandPsSwitch(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getOutbandPsSwitch<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getOutbandPsSwitchPtr
newCallback_RadioCommander_getOutbandPsSwitch(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getOutbandPsSwitch<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getOutbandPsSize : public Callback_RadioCommander_getOutbandPsSize_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_RadioCommander_getOutbandPsSize(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getOutbandPsSize(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getOutbandPsSizePtr
newCallback_RadioCommander_getOutbandPsSize(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getOutbandPsSize<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getOutbandPsSizePtr
newCallback_RadioCommander_getOutbandPsSize(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getOutbandPsSize<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getOutbandPsSize : public Callback_RadioCommander_getOutbandPsSize_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_RadioCommander_getOutbandPsSize(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getOutbandPsSize(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getOutbandPsSizePtr
newCallback_RadioCommander_getOutbandPsSize(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getOutbandPsSize<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getOutbandPsSizePtr
newCallback_RadioCommander_getOutbandPsSize(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getOutbandPsSize<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getSpectrumBandwidth : public Callback_RadioCommander_getSpectrumBandwidth_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_RadioCommander_getSpectrumBandwidth(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getSpectrumBandwidth(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getSpectrumBandwidthPtr
newCallback_RadioCommander_getSpectrumBandwidth(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getSpectrumBandwidth<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getSpectrumBandwidthPtr
newCallback_RadioCommander_getSpectrumBandwidth(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getSpectrumBandwidth<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getSpectrumBandwidth : public Callback_RadioCommander_getSpectrumBandwidth_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_RadioCommander_getSpectrumBandwidth(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getSpectrumBandwidth(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getSpectrumBandwidthPtr
newCallback_RadioCommander_getSpectrumBandwidth(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getSpectrumBandwidth<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getSpectrumBandwidthPtr
newCallback_RadioCommander_getSpectrumBandwidth(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getSpectrumBandwidth<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setSpectrumBandwidth : public Callback_RadioCommander_setSpectrumBandwidth_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setSpectrumBandwidth(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setSpectrumBandwidthPtr
newCallback_RadioCommander_setSpectrumBandwidth(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setSpectrumBandwidth<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setSpectrumBandwidthPtr
newCallback_RadioCommander_setSpectrumBandwidth(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setSpectrumBandwidth<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setSpectrumBandwidthPtr
newCallback_RadioCommander_setSpectrumBandwidth(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setSpectrumBandwidth<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setSpectrumBandwidthPtr
newCallback_RadioCommander_setSpectrumBandwidth(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setSpectrumBandwidth<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setSpectrumBandwidth : public Callback_RadioCommander_setSpectrumBandwidth_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setSpectrumBandwidth(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setSpectrumBandwidthPtr
newCallback_RadioCommander_setSpectrumBandwidth(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setSpectrumBandwidth<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setSpectrumBandwidthPtr
newCallback_RadioCommander_setSpectrumBandwidth(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setSpectrumBandwidth<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setSpectrumBandwidthPtr
newCallback_RadioCommander_setSpectrumBandwidth(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setSpectrumBandwidth<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setSpectrumBandwidthPtr
newCallback_RadioCommander_setSpectrumBandwidth(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setSpectrumBandwidth<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getSpectrumBandwidths : public Callback_RadioCommander_getSpectrumBandwidths_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_RadioCommander_getSpectrumBandwidths(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getSpectrumBandwidths(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getSpectrumBandwidthsPtr
newCallback_RadioCommander_getSpectrumBandwidths(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getSpectrumBandwidths<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getSpectrumBandwidthsPtr
newCallback_RadioCommander_getSpectrumBandwidths(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getSpectrumBandwidths<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getSpectrumBandwidths : public Callback_RadioCommander_getSpectrumBandwidths_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_RadioCommander_getSpectrumBandwidths(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getSpectrumBandwidths(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getSpectrumBandwidthsPtr
newCallback_RadioCommander_getSpectrumBandwidths(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getSpectrumBandwidths<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getSpectrumBandwidthsPtr
newCallback_RadioCommander_getSpectrumBandwidths(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getSpectrumBandwidths<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setRand : public Callback_RadioCommander_setRand_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setRand(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setRandPtr
newCallback_RadioCommander_setRand(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setRand<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setRandPtr
newCallback_RadioCommander_setRand(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setRand<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setRandPtr
newCallback_RadioCommander_setRand(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setRand<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setRandPtr
newCallback_RadioCommander_setRand(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setRand<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setRand : public Callback_RadioCommander_setRand_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setRand(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setRandPtr
newCallback_RadioCommander_setRand(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setRand<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setRandPtr
newCallback_RadioCommander_setRand(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setRand<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setRandPtr
newCallback_RadioCommander_setRand(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setRand<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setRandPtr
newCallback_RadioCommander_setRand(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setRand<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getRand : public Callback_RadioCommander_getRand_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_RadioCommander_getRand(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_getRand(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getRandPtr
newCallback_RadioCommander_getRand(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getRand<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getRandPtr
newCallback_RadioCommander_getRand(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getRand<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getRand : public Callback_RadioCommander_getRand_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_RadioCommander_getRand(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_getRand(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getRandPtr
newCallback_RadioCommander_getRand(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getRand<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getRandPtr
newCallback_RadioCommander_getRand(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getRand<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getVersion : public Callback_RadioCommander_getVersion_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_RadioCommander_getVersion(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getVersion(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getVersionPtr
newCallback_RadioCommander_getVersion(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getVersion<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getVersionPtr
newCallback_RadioCommander_getVersion(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getVersion<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getVersion : public Callback_RadioCommander_getVersion_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_RadioCommander_getVersion(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getVersion(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getVersionPtr
newCallback_RadioCommander_getVersion(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getVersion<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getVersionPtr
newCallback_RadioCommander_getVersion(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getVersion<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setSamplerate : public Callback_RadioCommander_setSamplerate_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setSamplerate(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setSampleratePtr
newCallback_RadioCommander_setSamplerate(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setSamplerate<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setSampleratePtr
newCallback_RadioCommander_setSamplerate(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setSamplerate<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setSampleratePtr
newCallback_RadioCommander_setSamplerate(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setSamplerate<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setSampleratePtr
newCallback_RadioCommander_setSamplerate(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setSamplerate<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setSamplerate : public Callback_RadioCommander_setSamplerate_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setSamplerate(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setSampleratePtr
newCallback_RadioCommander_setSamplerate(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setSamplerate<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setSampleratePtr
newCallback_RadioCommander_setSamplerate(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setSamplerate<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setSampleratePtr
newCallback_RadioCommander_setSamplerate(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setSamplerate<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setSampleratePtr
newCallback_RadioCommander_setSamplerate(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setSamplerate<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getSamplerate : public Callback_RadioCommander_getSamplerate_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Float);

    CallbackNC_RadioCommander_getSamplerate(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getSamplerate(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getSampleratePtr
newCallback_RadioCommander_getSamplerate(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getSamplerate<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getSampleratePtr
newCallback_RadioCommander_getSamplerate(T* instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getSamplerate<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getSamplerate : public Callback_RadioCommander_getSamplerate_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Float, const CT&);

    Callback_RadioCommander_getSamplerate(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getSamplerate(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getSampleratePtr
newCallback_RadioCommander_getSamplerate(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getSamplerate<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getSampleratePtr
newCallback_RadioCommander_getSamplerate(T* instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getSamplerate<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setSMeterCorrection : public Callback_RadioCommander_setSMeterCorrection_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setSMeterCorrection(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setSMeterCorrectionPtr
newCallback_RadioCommander_setSMeterCorrection(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setSMeterCorrection<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setSMeterCorrectionPtr
newCallback_RadioCommander_setSMeterCorrection(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setSMeterCorrection<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setSMeterCorrectionPtr
newCallback_RadioCommander_setSMeterCorrection(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setSMeterCorrection<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setSMeterCorrectionPtr
newCallback_RadioCommander_setSMeterCorrection(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setSMeterCorrection<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setSMeterCorrection : public Callback_RadioCommander_setSMeterCorrection_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setSMeterCorrection(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setSMeterCorrectionPtr
newCallback_RadioCommander_setSMeterCorrection(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setSMeterCorrection<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setSMeterCorrectionPtr
newCallback_RadioCommander_setSMeterCorrection(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setSMeterCorrection<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setSMeterCorrectionPtr
newCallback_RadioCommander_setSMeterCorrection(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setSMeterCorrection<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setSMeterCorrectionPtr
newCallback_RadioCommander_setSMeterCorrection(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setSMeterCorrection<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getSMeterCorrection : public Callback_RadioCommander_getSMeterCorrection_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Float);

    CallbackNC_RadioCommander_getSMeterCorrection(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getSMeterCorrection(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getSMeterCorrectionPtr
newCallback_RadioCommander_getSMeterCorrection(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getSMeterCorrection<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getSMeterCorrectionPtr
newCallback_RadioCommander_getSMeterCorrection(T* instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getSMeterCorrection<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getSMeterCorrection : public Callback_RadioCommander_getSMeterCorrection_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Float, const CT&);

    Callback_RadioCommander_getSMeterCorrection(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getSMeterCorrection(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getSMeterCorrectionPtr
newCallback_RadioCommander_getSMeterCorrection(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getSMeterCorrection<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getSMeterCorrectionPtr
newCallback_RadioCommander_getSMeterCorrection(T* instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getSMeterCorrection<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getSMeterInstantaneous : public Callback_RadioCommander_getSMeterInstantaneous_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Float);

    CallbackNC_RadioCommander_getSMeterInstantaneous(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getSMeterInstantaneous(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getSMeterInstantaneousPtr
newCallback_RadioCommander_getSMeterInstantaneous(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getSMeterInstantaneous<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getSMeterInstantaneousPtr
newCallback_RadioCommander_getSMeterInstantaneous(T* instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getSMeterInstantaneous<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getSMeterInstantaneous : public Callback_RadioCommander_getSMeterInstantaneous_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Float, const CT&);

    Callback_RadioCommander_getSMeterInstantaneous(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getSMeterInstantaneous(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getSMeterInstantaneousPtr
newCallback_RadioCommander_getSMeterInstantaneous(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getSMeterInstantaneous<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getSMeterInstantaneousPtr
newCallback_RadioCommander_getSMeterInstantaneous(T* instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getSMeterInstantaneous<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getSMeterAverage : public Callback_RadioCommander_getSMeterAverage_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Float);

    CallbackNC_RadioCommander_getSMeterAverage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getSMeterAverage(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getSMeterAveragePtr
newCallback_RadioCommander_getSMeterAverage(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getSMeterAverage<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getSMeterAveragePtr
newCallback_RadioCommander_getSMeterAverage(T* instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getSMeterAverage<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getSMeterAverage : public Callback_RadioCommander_getSMeterAverage_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Float, const CT&);

    Callback_RadioCommander_getSMeterAverage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getSMeterAverage(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getSMeterAveragePtr
newCallback_RadioCommander_getSMeterAverage(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getSMeterAverage<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getSMeterAveragePtr
newCallback_RadioCommander_getSMeterAverage(T* instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getSMeterAverage<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setSquelchSwitch : public Callback_RadioCommander_setSquelchSwitch_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setSquelchSwitch(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setSquelchSwitchPtr
newCallback_RadioCommander_setSquelchSwitch(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setSquelchSwitch<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setSquelchSwitchPtr
newCallback_RadioCommander_setSquelchSwitch(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setSquelchSwitch<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setSquelchSwitchPtr
newCallback_RadioCommander_setSquelchSwitch(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setSquelchSwitch<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setSquelchSwitchPtr
newCallback_RadioCommander_setSquelchSwitch(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setSquelchSwitch<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setSquelchSwitch : public Callback_RadioCommander_setSquelchSwitch_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setSquelchSwitch(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setSquelchSwitchPtr
newCallback_RadioCommander_setSquelchSwitch(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setSquelchSwitch<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setSquelchSwitchPtr
newCallback_RadioCommander_setSquelchSwitch(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setSquelchSwitch<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setSquelchSwitchPtr
newCallback_RadioCommander_setSquelchSwitch(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setSquelchSwitch<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setSquelchSwitchPtr
newCallback_RadioCommander_setSquelchSwitch(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setSquelchSwitch<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getSquelchSwitch : public Callback_RadioCommander_getSquelchSwitch_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_RadioCommander_getSquelchSwitch(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_getSquelchSwitch(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getSquelchSwitchPtr
newCallback_RadioCommander_getSquelchSwitch(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getSquelchSwitch<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getSquelchSwitchPtr
newCallback_RadioCommander_getSquelchSwitch(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getSquelchSwitch<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getSquelchSwitch : public Callback_RadioCommander_getSquelchSwitch_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_RadioCommander_getSquelchSwitch(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_getSquelchSwitch(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getSquelchSwitchPtr
newCallback_RadioCommander_getSquelchSwitch(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getSquelchSwitch<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getSquelchSwitchPtr
newCallback_RadioCommander_getSquelchSwitch(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getSquelchSwitch<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setSquelchThresh : public Callback_RadioCommander_setSquelchThresh_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setSquelchThresh(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setSquelchThreshPtr
newCallback_RadioCommander_setSquelchThresh(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setSquelchThresh<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setSquelchThreshPtr
newCallback_RadioCommander_setSquelchThresh(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setSquelchThresh<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setSquelchThreshPtr
newCallback_RadioCommander_setSquelchThresh(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setSquelchThresh<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setSquelchThreshPtr
newCallback_RadioCommander_setSquelchThresh(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setSquelchThresh<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setSquelchThresh : public Callback_RadioCommander_setSquelchThresh_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setSquelchThresh(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setSquelchThreshPtr
newCallback_RadioCommander_setSquelchThresh(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setSquelchThresh<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setSquelchThreshPtr
newCallback_RadioCommander_setSquelchThresh(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setSquelchThresh<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setSquelchThreshPtr
newCallback_RadioCommander_setSquelchThresh(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setSquelchThresh<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setSquelchThreshPtr
newCallback_RadioCommander_setSquelchThresh(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setSquelchThresh<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getSquelchThresh : public Callback_RadioCommander_getSquelchThresh_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Float);

    CallbackNC_RadioCommander_getSquelchThresh(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getSquelchThresh(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getSquelchThreshPtr
newCallback_RadioCommander_getSquelchThresh(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getSquelchThresh<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getSquelchThreshPtr
newCallback_RadioCommander_getSquelchThresh(T* instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getSquelchThresh<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getSquelchThresh : public Callback_RadioCommander_getSquelchThresh_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Float, const CT&);

    Callback_RadioCommander_getSquelchThresh(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getSquelchThresh(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getSquelchThreshPtr
newCallback_RadioCommander_getSquelchThresh(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getSquelchThresh<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getSquelchThreshPtr
newCallback_RadioCommander_getSquelchThresh(T* instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getSquelchThresh<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setStart : public Callback_RadioCommander_setStart_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setStart(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setStartPtr
newCallback_RadioCommander_setStart(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setStart<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setStartPtr
newCallback_RadioCommander_setStart(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setStart<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setStartPtr
newCallback_RadioCommander_setStart(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setStart<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setStartPtr
newCallback_RadioCommander_setStart(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setStart<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setStart : public Callback_RadioCommander_setStart_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setStart(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setStartPtr
newCallback_RadioCommander_setStart(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setStart<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setStartPtr
newCallback_RadioCommander_setStart(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setStart<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setStartPtr
newCallback_RadioCommander_setStart(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setStart<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setStartPtr
newCallback_RadioCommander_setStart(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setStart<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getStart : public Callback_RadioCommander_getStart_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_RadioCommander_getStart(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_getStart(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getStartPtr
newCallback_RadioCommander_getStart(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getStart<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getStartPtr
newCallback_RadioCommander_getStart(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getStart<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getStart : public Callback_RadioCommander_getStart_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_RadioCommander_getStart(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_getStart(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getStartPtr
newCallback_RadioCommander_getStart(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getStart<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getStartPtr
newCallback_RadioCommander_getStart(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getStart<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setStop : public Callback_RadioCommander_setStop_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setStop(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setStopPtr
newCallback_RadioCommander_setStop(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setStop<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setStopPtr
newCallback_RadioCommander_setStop(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setStop<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setStopPtr
newCallback_RadioCommander_setStop(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setStop<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setStopPtr
newCallback_RadioCommander_setStop(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setStop<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setStop : public Callback_RadioCommander_setStop_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setStop(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setStopPtr
newCallback_RadioCommander_setStop(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setStop<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setStopPtr
newCallback_RadioCommander_setStop(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setStop<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setStopPtr
newCallback_RadioCommander_setStop(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setStop<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setStopPtr
newCallback_RadioCommander_setStop(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setStop<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getStop : public Callback_RadioCommander_getStop_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_RadioCommander_getStop(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_getStop(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getStopPtr
newCallback_RadioCommander_getStop(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getStop<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getStopPtr
newCallback_RadioCommander_getStop(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getStop<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getStop : public Callback_RadioCommander_getStop_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_RadioCommander_getStop(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_getStop(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getStopPtr
newCallback_RadioCommander_getStop(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getStop<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getStopPtr
newCallback_RadioCommander_getStop(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getStop<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setVolume : public Callback_RadioCommander_setVolume_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setVolume(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setVolumePtr
newCallback_RadioCommander_setVolume(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setVolume<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setVolumePtr
newCallback_RadioCommander_setVolume(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setVolume<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setVolumePtr
newCallback_RadioCommander_setVolume(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setVolume<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setVolumePtr
newCallback_RadioCommander_setVolume(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setVolume<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setVolume : public Callback_RadioCommander_setVolume_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setVolume(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setVolumePtr
newCallback_RadioCommander_setVolume(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setVolume<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setVolumePtr
newCallback_RadioCommander_setVolume(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setVolume<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setVolumePtr
newCallback_RadioCommander_setVolume(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setVolume<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setVolumePtr
newCallback_RadioCommander_setVolume(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setVolume<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setVolumeLeft : public Callback_RadioCommander_setVolumeLeft_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setVolumeLeft(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setVolumeLeftPtr
newCallback_RadioCommander_setVolumeLeft(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setVolumeLeft<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setVolumeLeftPtr
newCallback_RadioCommander_setVolumeLeft(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setVolumeLeft<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setVolumeLeftPtr
newCallback_RadioCommander_setVolumeLeft(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setVolumeLeft<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setVolumeLeftPtr
newCallback_RadioCommander_setVolumeLeft(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setVolumeLeft<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setVolumeLeft : public Callback_RadioCommander_setVolumeLeft_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setVolumeLeft(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setVolumeLeftPtr
newCallback_RadioCommander_setVolumeLeft(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setVolumeLeft<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setVolumeLeftPtr
newCallback_RadioCommander_setVolumeLeft(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setVolumeLeft<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setVolumeLeftPtr
newCallback_RadioCommander_setVolumeLeft(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setVolumeLeft<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setVolumeLeftPtr
newCallback_RadioCommander_setVolumeLeft(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setVolumeLeft<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getVolumeLeft : public Callback_RadioCommander_getVolumeLeft_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Float);

    CallbackNC_RadioCommander_getVolumeLeft(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getVolumeLeft(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getVolumeLeftPtr
newCallback_RadioCommander_getVolumeLeft(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getVolumeLeft<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getVolumeLeftPtr
newCallback_RadioCommander_getVolumeLeft(T* instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getVolumeLeft<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getVolumeLeft : public Callback_RadioCommander_getVolumeLeft_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Float, const CT&);

    Callback_RadioCommander_getVolumeLeft(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getVolumeLeft(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getVolumeLeftPtr
newCallback_RadioCommander_getVolumeLeft(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getVolumeLeft<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getVolumeLeftPtr
newCallback_RadioCommander_getVolumeLeft(T* instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getVolumeLeft<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setVolumeRight : public Callback_RadioCommander_setVolumeRight_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setVolumeRight(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setVolumeRightPtr
newCallback_RadioCommander_setVolumeRight(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setVolumeRight<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setVolumeRightPtr
newCallback_RadioCommander_setVolumeRight(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setVolumeRight<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setVolumeRightPtr
newCallback_RadioCommander_setVolumeRight(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setVolumeRight<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setVolumeRightPtr
newCallback_RadioCommander_setVolumeRight(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setVolumeRight<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setVolumeRight : public Callback_RadioCommander_setVolumeRight_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setVolumeRight(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setVolumeRightPtr
newCallback_RadioCommander_setVolumeRight(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setVolumeRight<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setVolumeRightPtr
newCallback_RadioCommander_setVolumeRight(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setVolumeRight<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setVolumeRightPtr
newCallback_RadioCommander_setVolumeRight(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setVolumeRight<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setVolumeRightPtr
newCallback_RadioCommander_setVolumeRight(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setVolumeRight<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getVolumeRight : public Callback_RadioCommander_getVolumeRight_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Float);

    CallbackNC_RadioCommander_getVolumeRight(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getVolumeRight(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getVolumeRightPtr
newCallback_RadioCommander_getVolumeRight(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getVolumeRight<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getVolumeRightPtr
newCallback_RadioCommander_getVolumeRight(T* instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getVolumeRight<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getVolumeRight : public Callback_RadioCommander_getVolumeRight_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Float, const CT&);

    Callback_RadioCommander_getVolumeRight(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::Ice::Float __ret;
        try
        {
            __ret = __proxy->end_getVolumeRight(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getVolumeRightPtr
newCallback_RadioCommander_getVolumeRight(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getVolumeRight<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getVolumeRightPtr
newCallback_RadioCommander_getVolumeRight(T* instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getVolumeRight<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setLoadFirmware : public Callback_RadioCommander_setLoadFirmware_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setLoadFirmware(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setLoadFirmwarePtr
newCallback_RadioCommander_setLoadFirmware(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setLoadFirmware<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setLoadFirmwarePtr
newCallback_RadioCommander_setLoadFirmware(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setLoadFirmware<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setLoadFirmwarePtr
newCallback_RadioCommander_setLoadFirmware(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setLoadFirmware<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setLoadFirmwarePtr
newCallback_RadioCommander_setLoadFirmware(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setLoadFirmware<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setLoadFirmware : public Callback_RadioCommander_setLoadFirmware_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setLoadFirmware(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setLoadFirmwarePtr
newCallback_RadioCommander_setLoadFirmware(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setLoadFirmware<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setLoadFirmwarePtr
newCallback_RadioCommander_setLoadFirmware(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setLoadFirmware<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setLoadFirmwarePtr
newCallback_RadioCommander_setLoadFirmware(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setLoadFirmware<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setLoadFirmwarePtr
newCallback_RadioCommander_setLoadFirmware(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setLoadFirmware<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_setLoadFpga : public Callback_RadioCommander_setLoadFpga_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_RadioCommander_setLoadFpga(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_RadioCommander_setLoadFpgaPtr
newCallback_RadioCommander_setLoadFpga(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setLoadFpga<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setLoadFpgaPtr
newCallback_RadioCommander_setLoadFpga(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setLoadFpga<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_RadioCommander_setLoadFpgaPtr
newCallback_RadioCommander_setLoadFpga(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setLoadFpga<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_setLoadFpgaPtr
newCallback_RadioCommander_setLoadFpga(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_setLoadFpga<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_setLoadFpga : public Callback_RadioCommander_setLoadFpga_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_RadioCommander_setLoadFpga(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_RadioCommander_setLoadFpgaPtr
newCallback_RadioCommander_setLoadFpga(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setLoadFpga<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setLoadFpgaPtr
newCallback_RadioCommander_setLoadFpga(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setLoadFpga<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setLoadFpgaPtr
newCallback_RadioCommander_setLoadFpga(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setLoadFpga<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_setLoadFpgaPtr
newCallback_RadioCommander_setLoadFpga(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_setLoadFpga<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getFpgaFileId : public Callback_RadioCommander_getFpgaFileId_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_RadioCommander_getFpgaFileId(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getFpgaFileId(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getFpgaFileIdPtr
newCallback_RadioCommander_getFpgaFileId(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getFpgaFileId<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getFpgaFileIdPtr
newCallback_RadioCommander_getFpgaFileId(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getFpgaFileId<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getFpgaFileId : public Callback_RadioCommander_getFpgaFileId_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_RadioCommander_getFpgaFileId(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getFpgaFileId(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getFpgaFileIdPtr
newCallback_RadioCommander_getFpgaFileId(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getFpgaFileId<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getFpgaFileIdPtr
newCallback_RadioCommander_getFpgaFileId(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getFpgaFileId<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getFirmwareFileName : public Callback_RadioCommander_getFirmwareFileName_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_RadioCommander_getFirmwareFileName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getFirmwareFileName(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getFirmwareFileNamePtr
newCallback_RadioCommander_getFirmwareFileName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getFirmwareFileName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getFirmwareFileNamePtr
newCallback_RadioCommander_getFirmwareFileName(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getFirmwareFileName<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getFirmwareFileName : public Callback_RadioCommander_getFirmwareFileName_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_RadioCommander_getFirmwareFileName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getFirmwareFileName(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getFirmwareFileNamePtr
newCallback_RadioCommander_getFirmwareFileName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getFirmwareFileName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getFirmwareFileNamePtr
newCallback_RadioCommander_getFirmwareFileName(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getFirmwareFileName<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getFpgaRbfName : public Callback_RadioCommander_getFpgaRbfName_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_RadioCommander_getFpgaRbfName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getFpgaRbfName(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getFpgaRbfNamePtr
newCallback_RadioCommander_getFpgaRbfName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getFpgaRbfName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getFpgaRbfNamePtr
newCallback_RadioCommander_getFpgaRbfName(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getFpgaRbfName<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getFpgaRbfName : public Callback_RadioCommander_getFpgaRbfName_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_RadioCommander_getFpgaRbfName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getFpgaRbfName(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getFpgaRbfNamePtr
newCallback_RadioCommander_getFpgaRbfName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getFpgaRbfName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getFpgaRbfNamePtr
newCallback_RadioCommander_getFpgaRbfName(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getFpgaRbfName<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_RadioCommander_getDateTime : public Callback_RadioCommander_getDateTime_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_RadioCommander_getDateTime(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getDateTime(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_RadioCommander_getDateTimePtr
newCallback_RadioCommander_getDateTime(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getDateTime<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_RadioCommander_getDateTimePtr
newCallback_RadioCommander_getDateTime(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_RadioCommander_getDateTime<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_RadioCommander_getDateTime : public Callback_RadioCommander_getDateTime_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_RadioCommander_getDateTime(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::RadioCommanderPrx __proxy = ::QS1R::RadioCommanderPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getDateTime(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_RadioCommander_getDateTimePtr
newCallback_RadioCommander_getDateTime(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getDateTime<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_RadioCommander_getDateTimePtr
newCallback_RadioCommander_getDateTime(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_RadioCommander_getDateTime<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_PowerSpectrumData_getSpecData : public Callback_PowerSpectrumData_getSpecData_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::QS1R::SpecBuffer&);

    CallbackNC_PowerSpectrumData_getSpecData(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::PowerSpectrumDataPrx __proxy = ::QS1R::PowerSpectrumDataPrx::uncheckedCast(__result->getProxy());
        ::QS1R::SpecBuffer __ret;
        try
        {
            __ret = __proxy->end_getSpecData(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_PowerSpectrumData_getSpecDataPtr
newCallback_PowerSpectrumData_getSpecData(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::QS1R::SpecBuffer&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_PowerSpectrumData_getSpecData<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_PowerSpectrumData_getSpecDataPtr
newCallback_PowerSpectrumData_getSpecData(T* instance, void (T::*cb)(const ::QS1R::SpecBuffer&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_PowerSpectrumData_getSpecData<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_PowerSpectrumData_getSpecData : public Callback_PowerSpectrumData_getSpecData_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::QS1R::SpecBuffer&, const CT&);

    Callback_PowerSpectrumData_getSpecData(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::PowerSpectrumDataPrx __proxy = ::QS1R::PowerSpectrumDataPrx::uncheckedCast(__result->getProxy());
        ::QS1R::SpecBuffer __ret;
        try
        {
            __ret = __proxy->end_getSpecData(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_PowerSpectrumData_getSpecDataPtr
newCallback_PowerSpectrumData_getSpecData(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::QS1R::SpecBuffer&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_PowerSpectrumData_getSpecData<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_PowerSpectrumData_getSpecDataPtr
newCallback_PowerSpectrumData_getSpecData(T* instance, void (T::*cb)(const ::QS1R::SpecBuffer&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_PowerSpectrumData_getSpecData<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_PowerSpectrumData_getSpecDataSize : public Callback_PowerSpectrumData_getSpecDataSize_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_PowerSpectrumData_getSpecDataSize(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::PowerSpectrumDataPrx __proxy = ::QS1R::PowerSpectrumDataPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getSpecDataSize(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_PowerSpectrumData_getSpecDataSizePtr
newCallback_PowerSpectrumData_getSpecDataSize(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_PowerSpectrumData_getSpecDataSize<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_PowerSpectrumData_getSpecDataSizePtr
newCallback_PowerSpectrumData_getSpecDataSize(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_PowerSpectrumData_getSpecDataSize<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_PowerSpectrumData_getSpecDataSize : public Callback_PowerSpectrumData_getSpecDataSize_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_PowerSpectrumData_getSpecDataSize(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::PowerSpectrumDataPrx __proxy = ::QS1R::PowerSpectrumDataPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getSpecDataSize(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_PowerSpectrumData_getSpecDataSizePtr
newCallback_PowerSpectrumData_getSpecDataSize(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_PowerSpectrumData_getSpecDataSize<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_PowerSpectrumData_getSpecDataSizePtr
newCallback_PowerSpectrumData_getSpecDataSize(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_PowerSpectrumData_getSpecDataSize<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_MeterData_getMeterData : public Callback_MeterData_getMeterData_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::QS1R::MeterDataStruct&);

    CallbackNC_MeterData_getMeterData(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::MeterDataPrx __proxy = ::QS1R::MeterDataPrx::uncheckedCast(__result->getProxy());
        ::QS1R::MeterDataStruct __ret;
        try
        {
            __ret = __proxy->end_getMeterData(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_MeterData_getMeterDataPtr
newCallback_MeterData_getMeterData(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::QS1R::MeterDataStruct&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MeterData_getMeterData<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MeterData_getMeterDataPtr
newCallback_MeterData_getMeterData(T* instance, void (T::*cb)(const ::QS1R::MeterDataStruct&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MeterData_getMeterData<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_MeterData_getMeterData : public Callback_MeterData_getMeterData_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::QS1R::MeterDataStruct&, const CT&);

    Callback_MeterData_getMeterData(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::QS1R::MeterDataPrx __proxy = ::QS1R::MeterDataPrx::uncheckedCast(__result->getProxy());
        ::QS1R::MeterDataStruct __ret;
        try
        {
            __ret = __proxy->end_getMeterData(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_MeterData_getMeterDataPtr
newCallback_MeterData_getMeterData(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::QS1R::MeterDataStruct&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MeterData_getMeterData<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MeterData_getMeterDataPtr
newCallback_MeterData_getMeterData(T* instance, void (T::*cb)(const ::QS1R::MeterDataStruct&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MeterData_getMeterData<T, CT>(instance, cb, excb, sentcb);
}

}

#endif
